var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var require_index_001 = __commonJS({
  "assets/index-BIt8DA9z.js"(exports, module) {
    var _a;
    (function polyfill() {
      const relList = document.createElement("link").relList;
      if (relList && relList.supports && relList.supports("modulepreload")) {
        return;
      }
      for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
        processPreload(link);
      }
      new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (mutation.type !== "childList") {
            continue;
          }
          for (const node of mutation.addedNodes) {
            if (node.tagName === "LINK" && node.rel === "modulepreload")
              processPreload(node);
          }
        }
      }).observe(document, { childList: true, subtree: true });
      function getFetchOpts(link) {
        const fetchOpts = {};
        if (link.integrity) fetchOpts.integrity = link.integrity;
        if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
        if (link.crossOrigin === "use-credentials")
          fetchOpts.credentials = "include";
        else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
        else fetchOpts.credentials = "same-origin";
        return fetchOpts;
      }
      function processPreload(link) {
        if (link.ep)
          return;
        link.ep = true;
        const fetchOpts = getFetchOpts(link);
        fetch(link.href, fetchOpts);
      }
    })();
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    function getDefaultExportFromCjs(x) {
      return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
    }
    var jsxRuntime = { exports: {} };
    var reactJsxRuntime_production_min = {};
    var react = { exports: {} };
    var react_production_min = {};
    /**
     * @license React
     * react.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var hasRequiredReact_production_min;
    function requireReact_production_min() {
      if (hasRequiredReact_production_min) return react_production_min;
      hasRequiredReact_production_min = 1;
      var l = Symbol.for("react.element"), n = Symbol.for("react.portal"), p = Symbol.for("react.fragment"), q = Symbol.for("react.strict_mode"), r = Symbol.for("react.profiler"), t = Symbol.for("react.provider"), u = Symbol.for("react.context"), v = Symbol.for("react.forward_ref"), w = Symbol.for("react.suspense"), x = Symbol.for("react.memo"), y = Symbol.for("react.lazy"), z = Symbol.iterator;
      function A(a) {
        if (null === a || "object" !== typeof a) return null;
        a = z && a[z] || a["@@iterator"];
        return "function" === typeof a ? a : null;
      }
      var B = { isMounted: function() {
        return false;
      }, enqueueForceUpdate: function() {
      }, enqueueReplaceState: function() {
      }, enqueueSetState: function() {
      } }, C = Object.assign, D = {};
      function E(a, b, e) {
        this.props = a;
        this.context = b;
        this.refs = D;
        this.updater = e || B;
      }
      E.prototype.isReactComponent = {};
      E.prototype.setState = function(a, b) {
        if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, a, b, "setState");
      };
      E.prototype.forceUpdate = function(a) {
        this.updater.enqueueForceUpdate(this, a, "forceUpdate");
      };
      function F() {
      }
      F.prototype = E.prototype;
      function G(a, b, e) {
        this.props = a;
        this.context = b;
        this.refs = D;
        this.updater = e || B;
      }
      var H = G.prototype = new F();
      H.constructor = G;
      C(H, E.prototype);
      H.isPureReactComponent = true;
      var I = Array.isArray, J = Object.prototype.hasOwnProperty, K = { current: null }, L = { key: true, ref: true, __self: true, __source: true };
      function M(a, b, e) {
        var d, c = {}, k = null, h = null;
        if (null != b) for (d in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b) J.call(b, d) && !L.hasOwnProperty(d) && (c[d] = b[d]);
        var g = arguments.length - 2;
        if (1 === g) c.children = e;
        else if (1 < g) {
          for (var f = Array(g), m = 0; m < g; m++) f[m] = arguments[m + 2];
          c.children = f;
        }
        if (a && a.defaultProps) for (d in g = a.defaultProps, g) void 0 === c[d] && (c[d] = g[d]);
        return { $$typeof: l, type: a, key: k, ref: h, props: c, _owner: K.current };
      }
      function N(a, b) {
        return { $$typeof: l, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
      }
      function O(a) {
        return "object" === typeof a && null !== a && a.$$typeof === l;
      }
      function escape(a) {
        var b = { "=": "=0", ":": "=2" };
        return "$" + a.replace(/[=:]/g, function(a2) {
          return b[a2];
        });
      }
      var P = /\/+/g;
      function Q(a, b) {
        return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
      }
      function R(a, b, e, d, c) {
        var k = typeof a;
        if ("undefined" === k || "boolean" === k) a = null;
        var h = false;
        if (null === a) h = true;
        else switch (k) {
          case "string":
          case "number":
            h = true;
            break;
          case "object":
            switch (a.$$typeof) {
              case l:
              case n:
                h = true;
            }
        }
        if (h) return h = a, c = c(h), a = "" === d ? "." + Q(h, 0) : d, I(c) ? (e = "", null != a && (e = a.replace(P, "$&/") + "/"), R(c, b, e, "", function(a2) {
          return a2;
        })) : null != c && (O(c) && (c = N(c, e + (!c.key || h && h.key === c.key ? "" : ("" + c.key).replace(P, "$&/") + "/") + a)), b.push(c)), 1;
        h = 0;
        d = "" === d ? "." : d + ":";
        if (I(a)) for (var g = 0; g < a.length; g++) {
          k = a[g];
          var f = d + Q(k, g);
          h += R(k, b, e, f, c);
        }
        else if (f = A(a), "function" === typeof f) for (a = f.call(a), g = 0; !(k = a.next()).done; ) k = k.value, f = d + Q(k, g++), h += R(k, b, e, f, c);
        else if ("object" === k) throw b = String(a), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b) + "). If you meant to render a collection of children, use an array instead.");
        return h;
      }
      function S(a, b, e) {
        if (null == a) return a;
        var d = [], c = 0;
        R(a, d, "", "", function(a2) {
          return b.call(e, a2, c++);
        });
        return d;
      }
      function T(a) {
        if (-1 === a._status) {
          var b = a._result;
          b = b();
          b.then(function(b2) {
            if (0 === a._status || -1 === a._status) a._status = 1, a._result = b2;
          }, function(b2) {
            if (0 === a._status || -1 === a._status) a._status = 2, a._result = b2;
          });
          -1 === a._status && (a._status = 0, a._result = b);
        }
        if (1 === a._status) return a._result.default;
        throw a._result;
      }
      var U = { current: null }, V = { transition: null }, W = { ReactCurrentDispatcher: U, ReactCurrentBatchConfig: V, ReactCurrentOwner: K };
      function X() {
        throw Error("act(...) is not supported in production builds of React.");
      }
      react_production_min.Children = { map: S, forEach: function(a, b, e) {
        S(a, function() {
          b.apply(this, arguments);
        }, e);
      }, count: function(a) {
        var b = 0;
        S(a, function() {
          b++;
        });
        return b;
      }, toArray: function(a) {
        return S(a, function(a2) {
          return a2;
        }) || [];
      }, only: function(a) {
        if (!O(a)) throw Error("React.Children.only expected to receive a single React element child.");
        return a;
      } };
      react_production_min.Component = E;
      react_production_min.Fragment = p;
      react_production_min.Profiler = r;
      react_production_min.PureComponent = G;
      react_production_min.StrictMode = q;
      react_production_min.Suspense = w;
      react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W;
      react_production_min.act = X;
      react_production_min.cloneElement = function(a, b, e) {
        if (null === a || void 0 === a) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a + ".");
        var d = C({}, a.props), c = a.key, k = a.ref, h = a._owner;
        if (null != b) {
          void 0 !== b.ref && (k = b.ref, h = K.current);
          void 0 !== b.key && (c = "" + b.key);
          if (a.type && a.type.defaultProps) var g = a.type.defaultProps;
          for (f in b) J.call(b, f) && !L.hasOwnProperty(f) && (d[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
        }
        var f = arguments.length - 2;
        if (1 === f) d.children = e;
        else if (1 < f) {
          g = Array(f);
          for (var m = 0; m < f; m++) g[m] = arguments[m + 2];
          d.children = g;
        }
        return { $$typeof: l, type: a.type, key: c, ref: k, props: d, _owner: h };
      };
      react_production_min.createContext = function(a) {
        a = { $$typeof: u, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
        a.Provider = { $$typeof: t, _context: a };
        return a.Consumer = a;
      };
      react_production_min.createElement = M;
      react_production_min.createFactory = function(a) {
        var b = M.bind(null, a);
        b.type = a;
        return b;
      };
      react_production_min.createRef = function() {
        return { current: null };
      };
      react_production_min.forwardRef = function(a) {
        return { $$typeof: v, render: a };
      };
      react_production_min.isValidElement = O;
      react_production_min.lazy = function(a) {
        return { $$typeof: y, _payload: { _status: -1, _result: a }, _init: T };
      };
      react_production_min.memo = function(a, b) {
        return { $$typeof: x, type: a, compare: void 0 === b ? null : b };
      };
      react_production_min.startTransition = function(a) {
        var b = V.transition;
        V.transition = {};
        try {
          a();
        } finally {
          V.transition = b;
        }
      };
      react_production_min.unstable_act = X;
      react_production_min.useCallback = function(a, b) {
        return U.current.useCallback(a, b);
      };
      react_production_min.useContext = function(a) {
        return U.current.useContext(a);
      };
      react_production_min.useDebugValue = function() {
      };
      react_production_min.useDeferredValue = function(a) {
        return U.current.useDeferredValue(a);
      };
      react_production_min.useEffect = function(a, b) {
        return U.current.useEffect(a, b);
      };
      react_production_min.useId = function() {
        return U.current.useId();
      };
      react_production_min.useImperativeHandle = function(a, b, e) {
        return U.current.useImperativeHandle(a, b, e);
      };
      react_production_min.useInsertionEffect = function(a, b) {
        return U.current.useInsertionEffect(a, b);
      };
      react_production_min.useLayoutEffect = function(a, b) {
        return U.current.useLayoutEffect(a, b);
      };
      react_production_min.useMemo = function(a, b) {
        return U.current.useMemo(a, b);
      };
      react_production_min.useReducer = function(a, b, e) {
        return U.current.useReducer(a, b, e);
      };
      react_production_min.useRef = function(a) {
        return U.current.useRef(a);
      };
      react_production_min.useState = function(a) {
        return U.current.useState(a);
      };
      react_production_min.useSyncExternalStore = function(a, b, e) {
        return U.current.useSyncExternalStore(a, b, e);
      };
      react_production_min.useTransition = function() {
        return U.current.useTransition();
      };
      react_production_min.version = "18.3.1";
      return react_production_min;
    }
    var hasRequiredReact;
    function requireReact() {
      if (hasRequiredReact) return react.exports;
      hasRequiredReact = 1;
      {
        react.exports = requireReact_production_min();
      }
      return react.exports;
    }
    /**
     * @license React
     * react-jsx-runtime.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var hasRequiredReactJsxRuntime_production_min;
    function requireReactJsxRuntime_production_min() {
      if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
      hasRequiredReactJsxRuntime_production_min = 1;
      var f = requireReact(), k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = { key: true, ref: true, __self: true, __source: true };
      function q(c, a, g) {
        var b, d = {}, e = null, h = null;
        void 0 !== g && (e = "" + g);
        void 0 !== a.key && (e = "" + a.key);
        void 0 !== a.ref && (h = a.ref);
        for (b in a) m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);
        if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d[b] && (d[b] = a[b]);
        return { $$typeof: k, type: c, key: e, ref: h, props: d, _owner: n.current };
      }
      reactJsxRuntime_production_min.Fragment = l;
      reactJsxRuntime_production_min.jsx = q;
      reactJsxRuntime_production_min.jsxs = q;
      return reactJsxRuntime_production_min;
    }
    var hasRequiredJsxRuntime;
    function requireJsxRuntime() {
      if (hasRequiredJsxRuntime) return jsxRuntime.exports;
      hasRequiredJsxRuntime = 1;
      {
        jsxRuntime.exports = requireReactJsxRuntime_production_min();
      }
      return jsxRuntime.exports;
    }
    var jsxRuntimeExports = requireJsxRuntime();
    var reactExports = requireReact();
    const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
    var client = {};
    var reactDom = { exports: {} };
    var reactDom_production_min = {};
    var scheduler = { exports: {} };
    var scheduler_production_min = {};
    /**
     * @license React
     * scheduler.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var hasRequiredScheduler_production_min;
    function requireScheduler_production_min() {
      if (hasRequiredScheduler_production_min) return scheduler_production_min;
      hasRequiredScheduler_production_min = 1;
      (function(exports2) {
        function f(a, b) {
          var c = a.length;
          a.push(b);
          a: for (; 0 < c; ) {
            var d = c - 1 >>> 1, e = a[d];
            if (0 < g(e, b)) a[d] = b, a[c] = e, c = d;
            else break a;
          }
        }
        function h(a) {
          return 0 === a.length ? null : a[0];
        }
        function k(a) {
          if (0 === a.length) return null;
          var b = a[0], c = a.pop();
          if (c !== b) {
            a[0] = c;
            a: for (var d = 0, e = a.length, w = e >>> 1; d < w; ) {
              var m = 2 * (d + 1) - 1, C = a[m], n = m + 1, x = a[n];
              if (0 > g(C, c)) n < e && 0 > g(x, C) ? (a[d] = x, a[n] = c, d = n) : (a[d] = C, a[m] = c, d = m);
              else if (n < e && 0 > g(x, c)) a[d] = x, a[n] = c, d = n;
              else break a;
            }
          }
          return b;
        }
        function g(a, b) {
          var c = a.sortIndex - b.sortIndex;
          return 0 !== c ? c : a.id - b.id;
        }
        if ("object" === typeof performance && "function" === typeof performance.now) {
          var l = performance;
          exports2.unstable_now = function() {
            return l.now();
          };
        } else {
          var p = Date, q = p.now();
          exports2.unstable_now = function() {
            return p.now() - q;
          };
        }
        var r = [], t = [], u = 1, v = null, y = 3, z = false, A = false, B = false, D = "function" === typeof setTimeout ? setTimeout : null, E = "function" === typeof clearTimeout ? clearTimeout : null, F = "undefined" !== typeof setImmediate ? setImmediate : null;
        "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
        function G(a) {
          for (var b = h(t); null !== b; ) {
            if (null === b.callback) k(t);
            else if (b.startTime <= a) k(t), b.sortIndex = b.expirationTime, f(r, b);
            else break;
            b = h(t);
          }
        }
        function H(a) {
          B = false;
          G(a);
          if (!A) if (null !== h(r)) A = true, I(J);
          else {
            var b = h(t);
            null !== b && K(H, b.startTime - a);
          }
        }
        function J(a, b) {
          A = false;
          B && (B = false, E(L), L = -1);
          z = true;
          var c = y;
          try {
            G(b);
            for (v = h(r); null !== v && (!(v.expirationTime > b) || a && !M()); ) {
              var d = v.callback;
              if ("function" === typeof d) {
                v.callback = null;
                y = v.priorityLevel;
                var e = d(v.expirationTime <= b);
                b = exports2.unstable_now();
                "function" === typeof e ? v.callback = e : v === h(r) && k(r);
                G(b);
              } else k(r);
              v = h(r);
            }
            if (null !== v) var w = true;
            else {
              var m = h(t);
              null !== m && K(H, m.startTime - b);
              w = false;
            }
            return w;
          } finally {
            v = null, y = c, z = false;
          }
        }
        var N = false, O = null, L = -1, P = 5, Q = -1;
        function M() {
          return exports2.unstable_now() - Q < P ? false : true;
        }
        function R() {
          if (null !== O) {
            var a = exports2.unstable_now();
            Q = a;
            var b = true;
            try {
              b = O(true, a);
            } finally {
              b ? S() : (N = false, O = null);
            }
          } else N = false;
        }
        var S;
        if ("function" === typeof F) S = function() {
          F(R);
        };
        else if ("undefined" !== typeof MessageChannel) {
          var T = new MessageChannel(), U = T.port2;
          T.port1.onmessage = R;
          S = function() {
            U.postMessage(null);
          };
        } else S = function() {
          D(R, 0);
        };
        function I(a) {
          O = a;
          N || (N = true, S());
        }
        function K(a, b) {
          L = D(function() {
            a(exports2.unstable_now());
          }, b);
        }
        exports2.unstable_IdlePriority = 5;
        exports2.unstable_ImmediatePriority = 1;
        exports2.unstable_LowPriority = 4;
        exports2.unstable_NormalPriority = 3;
        exports2.unstable_Profiling = null;
        exports2.unstable_UserBlockingPriority = 2;
        exports2.unstable_cancelCallback = function(a) {
          a.callback = null;
        };
        exports2.unstable_continueExecution = function() {
          A || z || (A = true, I(J));
        };
        exports2.unstable_forceFrameRate = function(a) {
          0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P = 0 < a ? Math.floor(1e3 / a) : 5;
        };
        exports2.unstable_getCurrentPriorityLevel = function() {
          return y;
        };
        exports2.unstable_getFirstCallbackNode = function() {
          return h(r);
        };
        exports2.unstable_next = function(a) {
          switch (y) {
            case 1:
            case 2:
            case 3:
              var b = 3;
              break;
            default:
              b = y;
          }
          var c = y;
          y = b;
          try {
            return a();
          } finally {
            y = c;
          }
        };
        exports2.unstable_pauseExecution = function() {
        };
        exports2.unstable_requestPaint = function() {
        };
        exports2.unstable_runWithPriority = function(a, b) {
          switch (a) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
              break;
            default:
              a = 3;
          }
          var c = y;
          y = a;
          try {
            return b();
          } finally {
            y = c;
          }
        };
        exports2.unstable_scheduleCallback = function(a, b, c) {
          var d = exports2.unstable_now();
          "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;
          switch (a) {
            case 1:
              var e = -1;
              break;
            case 2:
              e = 250;
              break;
            case 5:
              e = 1073741823;
              break;
            case 4:
              e = 1e4;
              break;
            default:
              e = 5e3;
          }
          e = c + e;
          a = { id: u++, callback: b, priorityLevel: a, startTime: c, expirationTime: e, sortIndex: -1 };
          c > d ? (a.sortIndex = c, f(t, a), null === h(r) && a === h(t) && (B ? (E(L), L = -1) : B = true, K(H, c - d))) : (a.sortIndex = e, f(r, a), A || z || (A = true, I(J)));
          return a;
        };
        exports2.unstable_shouldYield = M;
        exports2.unstable_wrapCallback = function(a) {
          var b = y;
          return function() {
            var c = y;
            y = b;
            try {
              return a.apply(this, arguments);
            } finally {
              y = c;
            }
          };
        };
      })(scheduler_production_min);
      return scheduler_production_min;
    }
    var hasRequiredScheduler;
    function requireScheduler() {
      if (hasRequiredScheduler) return scheduler.exports;
      hasRequiredScheduler = 1;
      {
        scheduler.exports = requireScheduler_production_min();
      }
      return scheduler.exports;
    }
    /**
     * @license React
     * react-dom.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var hasRequiredReactDom_production_min;
    function requireReactDom_production_min() {
      if (hasRequiredReactDom_production_min) return reactDom_production_min;
      hasRequiredReactDom_production_min = 1;
      var aa = requireReact(), ca = requireScheduler();
      function p(a) {
        for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);
        return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      var da = /* @__PURE__ */ new Set(), ea = {};
      function fa(a, b) {
        ha(a, b);
        ha(a + "Capture", b);
      }
      function ha(a, b) {
        ea[a] = b;
        for (a = 0; a < b.length; a++) da.add(b[a]);
      }
      var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
      function oa(a) {
        if (ja.call(ma, a)) return true;
        if (ja.call(la, a)) return false;
        if (ka.test(a)) return ma[a] = true;
        la[a] = true;
        return false;
      }
      function pa(a, b, c, d) {
        if (null !== c && 0 === c.type) return false;
        switch (typeof b) {
          case "function":
          case "symbol":
            return true;
          case "boolean":
            if (d) return false;
            if (null !== c) return !c.acceptsBooleans;
            a = a.toLowerCase().slice(0, 5);
            return "data-" !== a && "aria-" !== a;
          default:
            return false;
        }
      }
      function qa(a, b, c, d) {
        if (null === b || "undefined" === typeof b || pa(a, b, c, d)) return true;
        if (d) return false;
        if (null !== c) switch (c.type) {
          case 3:
            return !b;
          case 4:
            return false === b;
          case 5:
            return isNaN(b);
          case 6:
            return isNaN(b) || 1 > b;
        }
        return false;
      }
      function v(a, b, c, d, e, f, g) {
        this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
        this.attributeName = d;
        this.attributeNamespace = e;
        this.mustUseProperty = c;
        this.propertyName = a;
        this.type = b;
        this.sanitizeURL = f;
        this.removeEmptyString = g;
      }
      var z = {};
      "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
        z[a] = new v(a, 0, false, a, null, false, false);
      });
      [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
        var b = a[0];
        z[b] = new v(b, 1, false, a[1], null, false, false);
      });
      ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
        z[a] = new v(a, 2, false, a.toLowerCase(), null, false, false);
      });
      ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
        z[a] = new v(a, 2, false, a, null, false, false);
      });
      "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
        z[a] = new v(a, 3, false, a.toLowerCase(), null, false, false);
      });
      ["checked", "multiple", "muted", "selected"].forEach(function(a) {
        z[a] = new v(a, 3, true, a, null, false, false);
      });
      ["capture", "download"].forEach(function(a) {
        z[a] = new v(a, 4, false, a, null, false, false);
      });
      ["cols", "rows", "size", "span"].forEach(function(a) {
        z[a] = new v(a, 6, false, a, null, false, false);
      });
      ["rowSpan", "start"].forEach(function(a) {
        z[a] = new v(a, 5, false, a.toLowerCase(), null, false, false);
      });
      var ra = /[\-:]([a-z])/g;
      function sa(a) {
        return a[1].toUpperCase();
      }
      "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
        var b = a.replace(
          ra,
          sa
        );
        z[b] = new v(b, 1, false, a, null, false, false);
      });
      "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
        var b = a.replace(ra, sa);
        z[b] = new v(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
      });
      ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
        var b = a.replace(ra, sa);
        z[b] = new v(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
      });
      ["tabIndex", "crossOrigin"].forEach(function(a) {
        z[a] = new v(a, 1, false, a.toLowerCase(), null, false, false);
      });
      z.xlinkHref = new v("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
      ["src", "href", "action", "formAction"].forEach(function(a) {
        z[a] = new v(a, 1, false, a.toLowerCase(), null, true, true);
      });
      function ta(a, b, c, d) {
        var e = z.hasOwnProperty(b) ? z[b] : null;
        if (null !== e ? 0 !== e.type : d || !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1]) qa(b, c, e, d) && (c = null), d || null === e ? oa(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? false : "" : c : (b = e.attributeName, d = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && true === c ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c)));
      }
      var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
      var Ia = Symbol.for("react.offscreen");
      var Ja = Symbol.iterator;
      function Ka(a) {
        if (null === a || "object" !== typeof a) return null;
        a = Ja && a[Ja] || a["@@iterator"];
        return "function" === typeof a ? a : null;
      }
      var A = Object.assign, La;
      function Ma(a) {
        if (void 0 === La) try {
          throw Error();
        } catch (c) {
          var b = c.stack.trim().match(/\n( *(at )?)/);
          La = b && b[1] || "";
        }
        return "\n" + La + a;
      }
      var Na = false;
      function Oa(a, b) {
        if (!a || Na) return "";
        Na = true;
        var c = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
          if (b) if (b = function() {
            throw Error();
          }, Object.defineProperty(b.prototype, "props", { set: function() {
            throw Error();
          } }), "object" === typeof Reflect && Reflect.construct) {
            try {
              Reflect.construct(b, []);
            } catch (l) {
              var d = l;
            }
            Reflect.construct(a, [], b);
          } else {
            try {
              b.call();
            } catch (l) {
              d = l;
            }
            a.call(b.prototype);
          }
          else {
            try {
              throw Error();
            } catch (l) {
              d = l;
            }
            a();
          }
        } catch (l) {
          if (l && d && "string" === typeof l.stack) {
            for (var e = l.stack.split("\n"), f = d.stack.split("\n"), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h]; ) h--;
            for (; 1 <= g && 0 <= h; g--, h--) if (e[g] !== f[h]) {
              if (1 !== g || 1 !== h) {
                do
                  if (g--, h--, 0 > h || e[g] !== f[h]) {
                    var k = "\n" + e[g].replace(" at new ", " at ");
                    a.displayName && k.includes("<anonymous>") && (k = k.replace("<anonymous>", a.displayName));
                    return k;
                  }
                while (1 <= g && 0 <= h);
              }
              break;
            }
          }
        } finally {
          Na = false, Error.prepareStackTrace = c;
        }
        return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
      }
      function Pa(a) {
        switch (a.tag) {
          case 5:
            return Ma(a.type);
          case 16:
            return Ma("Lazy");
          case 13:
            return Ma("Suspense");
          case 19:
            return Ma("SuspenseList");
          case 0:
          case 2:
          case 15:
            return a = Oa(a.type, false), a;
          case 11:
            return a = Oa(a.type.render, false), a;
          case 1:
            return a = Oa(a.type, true), a;
          default:
            return "";
        }
      }
      function Qa(a) {
        if (null == a) return null;
        if ("function" === typeof a) return a.displayName || a.name || null;
        if ("string" === typeof a) return a;
        switch (a) {
          case ya:
            return "Fragment";
          case wa:
            return "Portal";
          case Aa:
            return "Profiler";
          case za:
            return "StrictMode";
          case Ea:
            return "Suspense";
          case Fa:
            return "SuspenseList";
        }
        if ("object" === typeof a) switch (a.$$typeof) {
          case Ca:
            return (a.displayName || "Context") + ".Consumer";
          case Ba:
            return (a._context.displayName || "Context") + ".Provider";
          case Da:
            var b = a.render;
            a = a.displayName;
            a || (a = b.displayName || b.name || "", a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
            return a;
          case Ga:
            return b = a.displayName || null, null !== b ? b : Qa(a.type) || "Memo";
          case Ha:
            b = a._payload;
            a = a._init;
            try {
              return Qa(a(b));
            } catch (c) {
            }
        }
        return null;
      }
      function Ra(a) {
        var b = a.type;
        switch (a.tag) {
          case 24:
            return "Cache";
          case 9:
            return (b.displayName || "Context") + ".Consumer";
          case 10:
            return (b._context.displayName || "Context") + ".Provider";
          case 18:
            return "DehydratedFragment";
          case 11:
            return a = b.render, a = a.displayName || a.name || "", b.displayName || ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef");
          case 7:
            return "Fragment";
          case 5:
            return b;
          case 4:
            return "Portal";
          case 3:
            return "Root";
          case 6:
            return "Text";
          case 16:
            return Qa(b);
          case 8:
            return b === za ? "StrictMode" : "Mode";
          case 22:
            return "Offscreen";
          case 12:
            return "Profiler";
          case 21:
            return "Scope";
          case 13:
            return "Suspense";
          case 19:
            return "SuspenseList";
          case 25:
            return "TracingMarker";
          case 1:
          case 0:
          case 17:
          case 2:
          case 14:
          case 15:
            if ("function" === typeof b) return b.displayName || b.name || null;
            if ("string" === typeof b) return b;
        }
        return null;
      }
      function Sa(a) {
        switch (typeof a) {
          case "boolean":
          case "number":
          case "string":
          case "undefined":
            return a;
          case "object":
            return a;
          default:
            return "";
        }
      }
      function Ta(a) {
        var b = a.type;
        return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
      }
      function Ua(a) {
        var b = Ta(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d = "" + a[b];
        if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
          var e = c.get, f = c.set;
          Object.defineProperty(a, b, { configurable: true, get: function() {
            return e.call(this);
          }, set: function(a2) {
            d = "" + a2;
            f.call(this, a2);
          } });
          Object.defineProperty(a, b, { enumerable: c.enumerable });
          return { getValue: function() {
            return d;
          }, setValue: function(a2) {
            d = "" + a2;
          }, stopTracking: function() {
            a._valueTracker = null;
            delete a[b];
          } };
        }
      }
      function Va(a) {
        a._valueTracker || (a._valueTracker = Ua(a));
      }
      function Wa(a) {
        if (!a) return false;
        var b = a._valueTracker;
        if (!b) return true;
        var c = b.getValue();
        var d = "";
        a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
        a = d;
        return a !== c ? (b.setValue(a), true) : false;
      }
      function Xa(a) {
        a = a || ("undefined" !== typeof document ? document : void 0);
        if ("undefined" === typeof a) return null;
        try {
          return a.activeElement || a.body;
        } catch (b) {
          return a.body;
        }
      }
      function Ya(a, b) {
        var c = b.checked;
        return A({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c ? c : a._wrapperState.initialChecked });
      }
      function Za(a, b) {
        var c = null == b.defaultValue ? "" : b.defaultValue, d = null != b.checked ? b.checked : b.defaultChecked;
        c = Sa(null != b.value ? b.value : c);
        a._wrapperState = { initialChecked: d, initialValue: c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
      }
      function ab(a, b) {
        b = b.checked;
        null != b && ta(a, "checked", b, false);
      }
      function bb(a, b) {
        ab(a, b);
        var c = Sa(b.value), d = b.type;
        if (null != c) if ("number" === d) {
          if (0 === c && "" === a.value || a.value != c) a.value = "" + c;
        } else a.value !== "" + c && (a.value = "" + c);
        else if ("submit" === d || "reset" === d) {
          a.removeAttribute("value");
          return;
        }
        b.hasOwnProperty("value") ? cb(a, b.type, c) : b.hasOwnProperty("defaultValue") && cb(a, b.type, Sa(b.defaultValue));
        null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
      }
      function db(a, b, c) {
        if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
          var d = b.type;
          if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value)) return;
          b = "" + a._wrapperState.initialValue;
          c || b === a.value || (a.value = b);
          a.defaultValue = b;
        }
        c = a.name;
        "" !== c && (a.name = "");
        a.defaultChecked = !!a._wrapperState.initialChecked;
        "" !== c && (a.name = c);
      }
      function cb(a, b, c) {
        if ("number" !== b || Xa(a.ownerDocument) !== a) null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
      }
      var eb = Array.isArray;
      function fb(a, b, c, d) {
        a = a.options;
        if (b) {
          b = {};
          for (var e = 0; e < c.length; e++) b["$" + c[e]] = true;
          for (c = 0; c < a.length; c++) e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = true);
        } else {
          c = "" + Sa(c);
          b = null;
          for (e = 0; e < a.length; e++) {
            if (a[e].value === c) {
              a[e].selected = true;
              d && (a[e].defaultSelected = true);
              return;
            }
            null !== b || a[e].disabled || (b = a[e]);
          }
          null !== b && (b.selected = true);
        }
      }
      function gb(a, b) {
        if (null != b.dangerouslySetInnerHTML) throw Error(p(91));
        return A({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
      }
      function hb(a, b) {
        var c = b.value;
        if (null == c) {
          c = b.children;
          b = b.defaultValue;
          if (null != c) {
            if (null != b) throw Error(p(92));
            if (eb(c)) {
              if (1 < c.length) throw Error(p(93));
              c = c[0];
            }
            b = c;
          }
          null == b && (b = "");
          c = b;
        }
        a._wrapperState = { initialValue: Sa(c) };
      }
      function ib(a, b) {
        var c = Sa(b.value), d = Sa(b.defaultValue);
        null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
        null != d && (a.defaultValue = "" + d);
      }
      function jb(a) {
        var b = a.textContent;
        b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
      }
      function kb(a) {
        switch (a) {
          case "svg":
            return "http://www.w3.org/2000/svg";
          case "math":
            return "http://www.w3.org/1998/Math/MathML";
          default:
            return "http://www.w3.org/1999/xhtml";
        }
      }
      function lb(a, b) {
        return null == a || "http://www.w3.org/1999/xhtml" === a ? kb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
      }
      var mb, nb = function(a) {
        return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b, c, d, e) {
          MSApp.execUnsafeLocalFunction(function() {
            return a(b, c, d, e);
          });
        } : a;
      }(function(a, b) {
        if ("http://www.w3.org/2000/svg" !== a.namespaceURI || "innerHTML" in a) a.innerHTML = b;
        else {
          mb = mb || document.createElement("div");
          mb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
          for (b = mb.firstChild; a.firstChild; ) a.removeChild(a.firstChild);
          for (; b.firstChild; ) a.appendChild(b.firstChild);
        }
      });
      function ob(a, b) {
        if (b) {
          var c = a.firstChild;
          if (c && c === a.lastChild && 3 === c.nodeType) {
            c.nodeValue = b;
            return;
          }
        }
        a.textContent = b;
      }
      var pb = {
        animationIterationCount: true,
        aspectRatio: true,
        borderImageOutset: true,
        borderImageSlice: true,
        borderImageWidth: true,
        boxFlex: true,
        boxFlexGroup: true,
        boxOrdinalGroup: true,
        columnCount: true,
        columns: true,
        flex: true,
        flexGrow: true,
        flexPositive: true,
        flexShrink: true,
        flexNegative: true,
        flexOrder: true,
        gridArea: true,
        gridRow: true,
        gridRowEnd: true,
        gridRowSpan: true,
        gridRowStart: true,
        gridColumn: true,
        gridColumnEnd: true,
        gridColumnSpan: true,
        gridColumnStart: true,
        fontWeight: true,
        lineClamp: true,
        lineHeight: true,
        opacity: true,
        order: true,
        orphans: true,
        tabSize: true,
        widows: true,
        zIndex: true,
        zoom: true,
        fillOpacity: true,
        floodOpacity: true,
        stopOpacity: true,
        strokeDasharray: true,
        strokeDashoffset: true,
        strokeMiterlimit: true,
        strokeOpacity: true,
        strokeWidth: true
      }, qb = ["Webkit", "ms", "Moz", "O"];
      Object.keys(pb).forEach(function(a) {
        qb.forEach(function(b) {
          b = b + a.charAt(0).toUpperCase() + a.substring(1);
          pb[b] = pb[a];
        });
      });
      function rb(a, b, c) {
        return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || pb.hasOwnProperty(a) && pb[a] ? ("" + b).trim() : b + "px";
      }
      function sb(a, b) {
        a = a.style;
        for (var c in b) if (b.hasOwnProperty(c)) {
          var d = 0 === c.indexOf("--"), e = rb(c, b[c], d);
          "float" === c && (c = "cssFloat");
          d ? a.setProperty(c, e) : a[c] = e;
        }
      }
      var tb = A({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
      function ub(a, b) {
        if (b) {
          if (tb[a] && (null != b.children || null != b.dangerouslySetInnerHTML)) throw Error(p(137, a));
          if (null != b.dangerouslySetInnerHTML) {
            if (null != b.children) throw Error(p(60));
            if ("object" !== typeof b.dangerouslySetInnerHTML || !("__html" in b.dangerouslySetInnerHTML)) throw Error(p(61));
          }
          if (null != b.style && "object" !== typeof b.style) throw Error(p(62));
        }
      }
      function vb(a, b) {
        if (-1 === a.indexOf("-")) return "string" === typeof b.is;
        switch (a) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return false;
          default:
            return true;
        }
      }
      var wb = null;
      function xb(a) {
        a = a.target || a.srcElement || window;
        a.correspondingUseElement && (a = a.correspondingUseElement);
        return 3 === a.nodeType ? a.parentNode : a;
      }
      var yb = null, zb = null, Ab = null;
      function Bb(a) {
        if (a = Cb(a)) {
          if ("function" !== typeof yb) throw Error(p(280));
          var b = a.stateNode;
          b && (b = Db(b), yb(a.stateNode, a.type, b));
        }
      }
      function Eb(a) {
        zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
      }
      function Fb() {
        if (zb) {
          var a = zb, b = Ab;
          Ab = zb = null;
          Bb(a);
          if (b) for (a = 0; a < b.length; a++) Bb(b[a]);
        }
      }
      function Gb(a, b) {
        return a(b);
      }
      function Hb() {
      }
      var Ib = false;
      function Jb(a, b, c) {
        if (Ib) return a(b, c);
        Ib = true;
        try {
          return Gb(a, b, c);
        } finally {
          if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
        }
      }
      function Kb(a, b) {
        var c = a.stateNode;
        if (null === c) return null;
        var d = Db(c);
        if (null === d) return null;
        c = d[b];
        a: switch (b) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
            a = !d;
            break a;
          default:
            a = false;
        }
        if (a) return null;
        if (c && "function" !== typeof c) throw Error(p(231, b, typeof c));
        return c;
      }
      var Lb = false;
      if (ia) try {
        var Mb = {};
        Object.defineProperty(Mb, "passive", { get: function() {
          Lb = true;
        } });
        window.addEventListener("test", Mb, Mb);
        window.removeEventListener("test", Mb, Mb);
      } catch (a) {
        Lb = false;
      }
      function Nb(a, b, c, d, e, f, g, h, k) {
        var l = Array.prototype.slice.call(arguments, 3);
        try {
          b.apply(c, l);
        } catch (m) {
          this.onError(m);
        }
      }
      var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a) {
        Ob = true;
        Pb = a;
      } };
      function Tb(a, b, c, d, e, f, g, h, k) {
        Ob = false;
        Pb = null;
        Nb.apply(Sb, arguments);
      }
      function Ub(a, b, c, d, e, f, g, h, k) {
        Tb.apply(this, arguments);
        if (Ob) {
          if (Ob) {
            var l = Pb;
            Ob = false;
            Pb = null;
          } else throw Error(p(198));
          Qb || (Qb = true, Rb = l);
        }
      }
      function Vb(a) {
        var b = a, c = a;
        if (a.alternate) for (; b.return; ) b = b.return;
        else {
          a = b;
          do
            b = a, 0 !== (b.flags & 4098) && (c = b.return), a = b.return;
          while (a);
        }
        return 3 === b.tag ? c : null;
      }
      function Wb(a) {
        if (13 === a.tag) {
          var b = a.memoizedState;
          null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
          if (null !== b) return b.dehydrated;
        }
        return null;
      }
      function Xb(a) {
        if (Vb(a) !== a) throw Error(p(188));
      }
      function Yb(a) {
        var b = a.alternate;
        if (!b) {
          b = Vb(a);
          if (null === b) throw Error(p(188));
          return b !== a ? null : a;
        }
        for (var c = a, d = b; ; ) {
          var e = c.return;
          if (null === e) break;
          var f = e.alternate;
          if (null === f) {
            d = e.return;
            if (null !== d) {
              c = d;
              continue;
            }
            break;
          }
          if (e.child === f.child) {
            for (f = e.child; f; ) {
              if (f === c) return Xb(e), a;
              if (f === d) return Xb(e), b;
              f = f.sibling;
            }
            throw Error(p(188));
          }
          if (c.return !== d.return) c = e, d = f;
          else {
            for (var g = false, h = e.child; h; ) {
              if (h === c) {
                g = true;
                c = e;
                d = f;
                break;
              }
              if (h === d) {
                g = true;
                d = e;
                c = f;
                break;
              }
              h = h.sibling;
            }
            if (!g) {
              for (h = f.child; h; ) {
                if (h === c) {
                  g = true;
                  c = f;
                  d = e;
                  break;
                }
                if (h === d) {
                  g = true;
                  d = f;
                  c = e;
                  break;
                }
                h = h.sibling;
              }
              if (!g) throw Error(p(189));
            }
          }
          if (c.alternate !== d) throw Error(p(190));
        }
        if (3 !== c.tag) throw Error(p(188));
        return c.stateNode.current === c ? a : b;
      }
      function Zb(a) {
        a = Yb(a);
        return null !== a ? $b(a) : null;
      }
      function $b(a) {
        if (5 === a.tag || 6 === a.tag) return a;
        for (a = a.child; null !== a; ) {
          var b = $b(a);
          if (null !== b) return b;
          a = a.sibling;
        }
        return null;
      }
      var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
      function mc(a) {
        if (lc && "function" === typeof lc.onCommitFiberRoot) try {
          lc.onCommitFiberRoot(kc, a, void 0, 128 === (a.current.flags & 128));
        } catch (b) {
        }
      }
      var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
      function nc(a) {
        a >>>= 0;
        return 0 === a ? 32 : 31 - (pc(a) / qc | 0) | 0;
      }
      var rc = 64, sc = 4194304;
      function tc(a) {
        switch (a & -a) {
          case 1:
            return 1;
          case 2:
            return 2;
          case 4:
            return 4;
          case 8:
            return 8;
          case 16:
            return 16;
          case 32:
            return 32;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return a & 4194240;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            return a & 130023424;
          case 134217728:
            return 134217728;
          case 268435456:
            return 268435456;
          case 536870912:
            return 536870912;
          case 1073741824:
            return 1073741824;
          default:
            return a;
        }
      }
      function uc(a, b) {
        var c = a.pendingLanes;
        if (0 === c) return 0;
        var d = 0, e = a.suspendedLanes, f = a.pingedLanes, g = c & 268435455;
        if (0 !== g) {
          var h = g & ~e;
          0 !== h ? d = tc(h) : (f &= g, 0 !== f && (d = tc(f)));
        } else g = c & ~e, 0 !== g ? d = tc(g) : 0 !== f && (d = tc(f));
        if (0 === d) return 0;
        if (0 !== b && b !== d && 0 === (b & e) && (e = d & -d, f = b & -b, e >= f || 16 === e && 0 !== (f & 4194240))) return b;
        0 !== (d & 4) && (d |= c & 16);
        b = a.entangledLanes;
        if (0 !== b) for (a = a.entanglements, b &= d; 0 < b; ) c = 31 - oc(b), e = 1 << c, d |= a[c], b &= ~e;
        return d;
      }
      function vc(a, b) {
        switch (a) {
          case 1:
          case 2:
          case 4:
            return b + 250;
          case 8:
          case 16:
          case 32:
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return b + 5e3;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            return -1;
          case 134217728:
          case 268435456:
          case 536870912:
          case 1073741824:
            return -1;
          default:
            return -1;
        }
      }
      function wc(a, b) {
        for (var c = a.suspendedLanes, d = a.pingedLanes, e = a.expirationTimes, f = a.pendingLanes; 0 < f; ) {
          var g = 31 - oc(f), h = 1 << g, k = e[g];
          if (-1 === k) {
            if (0 === (h & c) || 0 !== (h & d)) e[g] = vc(h, b);
          } else k <= b && (a.expiredLanes |= h);
          f &= ~h;
        }
      }
      function xc(a) {
        a = a.pendingLanes & -1073741825;
        return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
      }
      function yc() {
        var a = rc;
        rc <<= 1;
        0 === (rc & 4194240) && (rc = 64);
        return a;
      }
      function zc(a) {
        for (var b = [], c = 0; 31 > c; c++) b.push(a);
        return b;
      }
      function Ac(a, b, c) {
        a.pendingLanes |= b;
        536870912 !== b && (a.suspendedLanes = 0, a.pingedLanes = 0);
        a = a.eventTimes;
        b = 31 - oc(b);
        a[b] = c;
      }
      function Bc(a, b) {
        var c = a.pendingLanes & ~b;
        a.pendingLanes = b;
        a.suspendedLanes = 0;
        a.pingedLanes = 0;
        a.expiredLanes &= b;
        a.mutableReadLanes &= b;
        a.entangledLanes &= b;
        b = a.entanglements;
        var d = a.eventTimes;
        for (a = a.expirationTimes; 0 < c; ) {
          var e = 31 - oc(c), f = 1 << e;
          b[e] = 0;
          d[e] = -1;
          a[e] = -1;
          c &= ~f;
        }
      }
      function Cc(a, b) {
        var c = a.entangledLanes |= b;
        for (a = a.entanglements; c; ) {
          var d = 31 - oc(c), e = 1 << d;
          e & b | a[d] & b && (a[d] |= b);
          c &= ~e;
        }
      }
      var C = 0;
      function Dc(a) {
        a &= -a;
        return 1 < a ? 4 < a ? 0 !== (a & 268435455) ? 16 : 536870912 : 4 : 1;
      }
      var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
      function Sc(a, b) {
        switch (a) {
          case "focusin":
          case "focusout":
            Lc = null;
            break;
          case "dragenter":
          case "dragleave":
            Mc = null;
            break;
          case "mouseover":
          case "mouseout":
            Nc = null;
            break;
          case "pointerover":
          case "pointerout":
            Oc.delete(b.pointerId);
            break;
          case "gotpointercapture":
          case "lostpointercapture":
            Pc.delete(b.pointerId);
        }
      }
      function Tc(a, b, c, d, e, f) {
        if (null === a || a.nativeEvent !== f) return a = { blockedOn: b, domEventName: c, eventSystemFlags: d, nativeEvent: f, targetContainers: [e] }, null !== b && (b = Cb(b), null !== b && Fc(b)), a;
        a.eventSystemFlags |= d;
        b = a.targetContainers;
        null !== e && -1 === b.indexOf(e) && b.push(e);
        return a;
      }
      function Uc(a, b, c, d, e) {
        switch (b) {
          case "focusin":
            return Lc = Tc(Lc, a, b, c, d, e), true;
          case "dragenter":
            return Mc = Tc(Mc, a, b, c, d, e), true;
          case "mouseover":
            return Nc = Tc(Nc, a, b, c, d, e), true;
          case "pointerover":
            var f = e.pointerId;
            Oc.set(f, Tc(Oc.get(f) || null, a, b, c, d, e));
            return true;
          case "gotpointercapture":
            return f = e.pointerId, Pc.set(f, Tc(Pc.get(f) || null, a, b, c, d, e)), true;
        }
        return false;
      }
      function Vc(a) {
        var b = Wc(a.target);
        if (null !== b) {
          var c = Vb(b);
          if (null !== c) {
            if (b = c.tag, 13 === b) {
              if (b = Wb(c), null !== b) {
                a.blockedOn = b;
                Ic(a.priority, function() {
                  Gc(c);
                });
                return;
              }
            } else if (3 === b && c.stateNode.current.memoizedState.isDehydrated) {
              a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
              return;
            }
          }
        }
        a.blockedOn = null;
      }
      function Xc(a) {
        if (null !== a.blockedOn) return false;
        for (var b = a.targetContainers; 0 < b.length; ) {
          var c = Yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
          if (null === c) {
            c = a.nativeEvent;
            var d = new c.constructor(c.type, c);
            wb = d;
            c.target.dispatchEvent(d);
            wb = null;
          } else return b = Cb(c), null !== b && Fc(b), a.blockedOn = c, false;
          b.shift();
        }
        return true;
      }
      function Zc(a, b, c) {
        Xc(a) && c.delete(b);
      }
      function $c() {
        Jc = false;
        null !== Lc && Xc(Lc) && (Lc = null);
        null !== Mc && Xc(Mc) && (Mc = null);
        null !== Nc && Xc(Nc) && (Nc = null);
        Oc.forEach(Zc);
        Pc.forEach(Zc);
      }
      function ad(a, b) {
        a.blockedOn === b && (a.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
      }
      function bd(a) {
        function b(b2) {
          return ad(b2, a);
        }
        if (0 < Kc.length) {
          ad(Kc[0], a);
          for (var c = 1; c < Kc.length; c++) {
            var d = Kc[c];
            d.blockedOn === a && (d.blockedOn = null);
          }
        }
        null !== Lc && ad(Lc, a);
        null !== Mc && ad(Mc, a);
        null !== Nc && ad(Nc, a);
        Oc.forEach(b);
        Pc.forEach(b);
        for (c = 0; c < Qc.length; c++) d = Qc[c], d.blockedOn === a && (d.blockedOn = null);
        for (; 0 < Qc.length && (c = Qc[0], null === c.blockedOn); ) Vc(c), null === c.blockedOn && Qc.shift();
      }
      var cd = ua.ReactCurrentBatchConfig, dd = true;
      function ed(a, b, c, d) {
        var e = C, f = cd.transition;
        cd.transition = null;
        try {
          C = 1, fd(a, b, c, d);
        } finally {
          C = e, cd.transition = f;
        }
      }
      function gd(a, b, c, d) {
        var e = C, f = cd.transition;
        cd.transition = null;
        try {
          C = 4, fd(a, b, c, d);
        } finally {
          C = e, cd.transition = f;
        }
      }
      function fd(a, b, c, d) {
        if (dd) {
          var e = Yc(a, b, c, d);
          if (null === e) hd(a, b, d, id, c), Sc(a, d);
          else if (Uc(e, a, b, c, d)) d.stopPropagation();
          else if (Sc(a, d), b & 4 && -1 < Rc.indexOf(a)) {
            for (; null !== e; ) {
              var f = Cb(e);
              null !== f && Ec(f);
              f = Yc(a, b, c, d);
              null === f && hd(a, b, d, id, c);
              if (f === e) break;
              e = f;
            }
            null !== e && d.stopPropagation();
          } else hd(a, b, d, null, c);
        }
      }
      var id = null;
      function Yc(a, b, c, d) {
        id = null;
        a = xb(d);
        a = Wc(a);
        if (null !== a) if (b = Vb(a), null === b) a = null;
        else if (c = b.tag, 13 === c) {
          a = Wb(b);
          if (null !== a) return a;
          a = null;
        } else if (3 === c) {
          if (b.stateNode.current.memoizedState.isDehydrated) return 3 === b.tag ? b.stateNode.containerInfo : null;
          a = null;
        } else b !== a && (a = null);
        id = a;
        return null;
      }
      function jd(a) {
        switch (a) {
          case "cancel":
          case "click":
          case "close":
          case "contextmenu":
          case "copy":
          case "cut":
          case "auxclick":
          case "dblclick":
          case "dragend":
          case "dragstart":
          case "drop":
          case "focusin":
          case "focusout":
          case "input":
          case "invalid":
          case "keydown":
          case "keypress":
          case "keyup":
          case "mousedown":
          case "mouseup":
          case "paste":
          case "pause":
          case "play":
          case "pointercancel":
          case "pointerdown":
          case "pointerup":
          case "ratechange":
          case "reset":
          case "resize":
          case "seeked":
          case "submit":
          case "touchcancel":
          case "touchend":
          case "touchstart":
          case "volumechange":
          case "change":
          case "selectionchange":
          case "textInput":
          case "compositionstart":
          case "compositionend":
          case "compositionupdate":
          case "beforeblur":
          case "afterblur":
          case "beforeinput":
          case "blur":
          case "fullscreenchange":
          case "focus":
          case "hashchange":
          case "popstate":
          case "select":
          case "selectstart":
            return 1;
          case "drag":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "mousemove":
          case "mouseout":
          case "mouseover":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "scroll":
          case "toggle":
          case "touchmove":
          case "wheel":
          case "mouseenter":
          case "mouseleave":
          case "pointerenter":
          case "pointerleave":
            return 4;
          case "message":
            switch (ec()) {
              case fc:
                return 1;
              case gc:
                return 4;
              case hc:
              case ic:
                return 16;
              case jc:
                return 536870912;
              default:
                return 16;
            }
          default:
            return 16;
        }
      }
      var kd = null, ld = null, md = null;
      function nd() {
        if (md) return md;
        var a, b = ld, c = b.length, d, e = "value" in kd ? kd.value : kd.textContent, f = e.length;
        for (a = 0; a < c && b[a] === e[a]; a++) ;
        var g = c - a;
        for (d = 1; d <= g && b[c - d] === e[f - d]; d++) ;
        return md = e.slice(a, 1 < d ? 1 - d : void 0);
      }
      function od(a) {
        var b = a.keyCode;
        "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
        10 === a && (a = 13);
        return 32 <= a || 13 === a ? a : 0;
      }
      function pd() {
        return true;
      }
      function qd() {
        return false;
      }
      function rd(a) {
        function b(b2, d, e, f, g) {
          this._reactName = b2;
          this._targetInst = e;
          this.type = d;
          this.nativeEvent = f;
          this.target = g;
          this.currentTarget = null;
          for (var c in a) a.hasOwnProperty(c) && (b2 = a[c], this[c] = b2 ? b2(f) : f[c]);
          this.isDefaultPrevented = (null != f.defaultPrevented ? f.defaultPrevented : false === f.returnValue) ? pd : qd;
          this.isPropagationStopped = qd;
          return this;
        }
        A(b.prototype, { preventDefault: function() {
          this.defaultPrevented = true;
          var a2 = this.nativeEvent;
          a2 && (a2.preventDefault ? a2.preventDefault() : "unknown" !== typeof a2.returnValue && (a2.returnValue = false), this.isDefaultPrevented = pd);
        }, stopPropagation: function() {
          var a2 = this.nativeEvent;
          a2 && (a2.stopPropagation ? a2.stopPropagation() : "unknown" !== typeof a2.cancelBubble && (a2.cancelBubble = true), this.isPropagationStopped = pd);
        }, persist: function() {
        }, isPersistent: pd });
        return b;
      }
      var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
        return a.timeStamp || Date.now();
      }, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
        return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
      }, movementX: function(a) {
        if ("movementX" in a) return a.movementX;
        a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
        return wd;
      }, movementY: function(a) {
        return "movementY" in a ? a.movementY : xd;
      } }), Bd = rd(Ad), Cd = A({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A({}, sd, { clipboardData: function(a) {
        return "clipboardData" in a ? a.clipboardData : window.clipboardData;
      } }), Jd = rd(Id), Kd = A({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
      }, Nd = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
      }, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
      function Pd(a) {
        var b = this.nativeEvent;
        return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : false;
      }
      function zd() {
        return Pd;
      }
      var Qd = A({}, ud, { key: function(a) {
        if (a.key) {
          var b = Md[a.key] || a.key;
          if ("Unidentified" !== b) return b;
        }
        return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
      }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
        return "keypress" === a.type ? od(a) : 0;
      }, keyCode: function(a) {
        return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
      }, which: function(a) {
        return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
      } }), Rd = rd(Qd), Sd = A({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A({}, Ad, {
        deltaX: function(a) {
          return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
        },
        deltaY: function(a) {
          return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
        },
        deltaZ: 0,
        deltaMode: 0
      }), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
      ia && "documentMode" in document && (be = document.documentMode);
      var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
      function ge(a, b) {
        switch (a) {
          case "keyup":
            return -1 !== $d.indexOf(b.keyCode);
          case "keydown":
            return 229 !== b.keyCode;
          case "keypress":
          case "mousedown":
          case "focusout":
            return true;
          default:
            return false;
        }
      }
      function he(a) {
        a = a.detail;
        return "object" === typeof a && "data" in a ? a.data : null;
      }
      var ie = false;
      function je(a, b) {
        switch (a) {
          case "compositionend":
            return he(b);
          case "keypress":
            if (32 !== b.which) return null;
            fe = true;
            return ee;
          case "textInput":
            return a = b.data, a === ee && fe ? null : a;
          default:
            return null;
        }
      }
      function ke(a, b) {
        if (ie) return "compositionend" === a || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = false, a) : null;
        switch (a) {
          case "paste":
            return null;
          case "keypress":
            if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
              if (b.char && 1 < b.char.length) return b.char;
              if (b.which) return String.fromCharCode(b.which);
            }
            return null;
          case "compositionend":
            return de && "ko" !== b.locale ? null : b.data;
          default:
            return null;
        }
      }
      var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
      function me(a) {
        var b = a && a.nodeName && a.nodeName.toLowerCase();
        return "input" === b ? !!le[a.type] : "textarea" === b ? true : false;
      }
      function ne(a, b, c, d) {
        Eb(d);
        b = oe(b, "onChange");
        0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({ event: c, listeners: b }));
      }
      var pe = null, qe = null;
      function re(a) {
        se(a, 0);
      }
      function te(a) {
        var b = ue(a);
        if (Wa(b)) return a;
      }
      function ve(a, b) {
        if ("change" === a) return b;
      }
      var we = false;
      if (ia) {
        var xe;
        if (ia) {
          var ye = "oninput" in document;
          if (!ye) {
            var ze = document.createElement("div");
            ze.setAttribute("oninput", "return;");
            ye = "function" === typeof ze.oninput;
          }
          xe = ye;
        } else xe = false;
        we = xe && (!document.documentMode || 9 < document.documentMode);
      }
      function Ae() {
        pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
      }
      function Be(a) {
        if ("value" === a.propertyName && te(qe)) {
          var b = [];
          ne(b, qe, a, xb(a));
          Jb(re, b);
        }
      }
      function Ce(a, b, c) {
        "focusin" === a ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
      }
      function De(a) {
        if ("selectionchange" === a || "keyup" === a || "keydown" === a) return te(qe);
      }
      function Ee(a, b) {
        if ("click" === a) return te(b);
      }
      function Fe(a, b) {
        if ("input" === a || "change" === a) return te(b);
      }
      function Ge(a, b) {
        return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
      }
      var He = "function" === typeof Object.is ? Object.is : Ge;
      function Ie(a, b) {
        if (He(a, b)) return true;
        if ("object" !== typeof a || null === a || "object" !== typeof b || null === b) return false;
        var c = Object.keys(a), d = Object.keys(b);
        if (c.length !== d.length) return false;
        for (d = 0; d < c.length; d++) {
          var e = c[d];
          if (!ja.call(b, e) || !He(a[e], b[e])) return false;
        }
        return true;
      }
      function Je(a) {
        for (; a && a.firstChild; ) a = a.firstChild;
        return a;
      }
      function Ke(a, b) {
        var c = Je(a);
        a = 0;
        for (var d; c; ) {
          if (3 === c.nodeType) {
            d = a + c.textContent.length;
            if (a <= b && d >= b) return { node: c, offset: b - a };
            a = d;
          }
          a: {
            for (; c; ) {
              if (c.nextSibling) {
                c = c.nextSibling;
                break a;
              }
              c = c.parentNode;
            }
            c = void 0;
          }
          c = Je(c);
        }
      }
      function Le(a, b) {
        return a && b ? a === b ? true : a && 3 === a.nodeType ? false : b && 3 === b.nodeType ? Le(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : false : false;
      }
      function Me() {
        for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement; ) {
          try {
            var c = "string" === typeof b.contentWindow.location.href;
          } catch (d) {
            c = false;
          }
          if (c) a = b.contentWindow;
          else break;
          b = Xa(a.document);
        }
        return b;
      }
      function Ne(a) {
        var b = a && a.nodeName && a.nodeName.toLowerCase();
        return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
      }
      function Oe(a) {
        var b = Me(), c = a.focusedElem, d = a.selectionRange;
        if (b !== c && c && c.ownerDocument && Le(c.ownerDocument.documentElement, c)) {
          if (null !== d && Ne(c)) {
            if (b = d.start, a = d.end, void 0 === a && (a = b), "selectionStart" in c) c.selectionStart = b, c.selectionEnd = Math.min(a, c.value.length);
            else if (a = (b = c.ownerDocument || document) && b.defaultView || window, a.getSelection) {
              a = a.getSelection();
              var e = c.textContent.length, f = Math.min(d.start, e);
              d = void 0 === d.end ? f : Math.min(d.end, e);
              !a.extend && f > d && (e = d, d = f, f = e);
              e = Ke(c, f);
              var g = Ke(
                c,
                d
              );
              e && g && (1 !== a.rangeCount || a.anchorNode !== e.node || a.anchorOffset !== e.offset || a.focusNode !== g.node || a.focusOffset !== g.offset) && (b = b.createRange(), b.setStart(e.node, e.offset), a.removeAllRanges(), f > d ? (a.addRange(b), a.extend(g.node, g.offset)) : (b.setEnd(g.node, g.offset), a.addRange(b)));
            }
          }
          b = [];
          for (a = c; a = a.parentNode; ) 1 === a.nodeType && b.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
          "function" === typeof c.focus && c.focus();
          for (c = 0; c < b.length; c++) a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
        }
      }
      var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
      function Ue(a, b, c) {
        var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
        Te || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Ne(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Se && Ie(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({ event: b, listeners: d }), b.target = Qe)));
      }
      function Ve(a, b) {
        var c = {};
        c[a.toLowerCase()] = b.toLowerCase();
        c["Webkit" + a] = "webkit" + b;
        c["Moz" + a] = "moz" + b;
        return c;
      }
      var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
      ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
      function Ze(a) {
        if (Xe[a]) return Xe[a];
        if (!We[a]) return a;
        var b = We[a], c;
        for (c in b) if (b.hasOwnProperty(c) && c in Ye) return Xe[a] = b[c];
        return a;
      }
      var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
      function ff(a, b) {
        df.set(a, b);
        fa(b, [a]);
      }
      for (var gf = 0; gf < ef.length; gf++) {
        var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
        ff(jf, "on" + kf);
      }
      ff($e, "onAnimationEnd");
      ff(af, "onAnimationIteration");
      ff(bf, "onAnimationStart");
      ff("dblclick", "onDoubleClick");
      ff("focusin", "onFocus");
      ff("focusout", "onBlur");
      ff(cf, "onTransitionEnd");
      ha("onMouseEnter", ["mouseout", "mouseover"]);
      ha("onMouseLeave", ["mouseout", "mouseover"]);
      ha("onPointerEnter", ["pointerout", "pointerover"]);
      ha("onPointerLeave", ["pointerout", "pointerover"]);
      fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
      fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
      fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
      fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
      fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
      fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
      var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
      function nf(a, b, c) {
        var d = a.type || "unknown-event";
        a.currentTarget = c;
        Ub(d, b, void 0, a);
        a.currentTarget = null;
      }
      function se(a, b) {
        b = 0 !== (b & 4);
        for (var c = 0; c < a.length; c++) {
          var d = a[c], e = d.event;
          d = d.listeners;
          a: {
            var f = void 0;
            if (b) for (var g = d.length - 1; 0 <= g; g--) {
              var h = d[g], k = h.instance, l = h.currentTarget;
              h = h.listener;
              if (k !== f && e.isPropagationStopped()) break a;
              nf(e, h, l);
              f = k;
            }
            else for (g = 0; g < d.length; g++) {
              h = d[g];
              k = h.instance;
              l = h.currentTarget;
              h = h.listener;
              if (k !== f && e.isPropagationStopped()) break a;
              nf(e, h, l);
              f = k;
            }
          }
        }
        if (Qb) throw a = Rb, Qb = false, Rb = null, a;
      }
      function D(a, b) {
        var c = b[of];
        void 0 === c && (c = b[of] = /* @__PURE__ */ new Set());
        var d = a + "__bubble";
        c.has(d) || (pf(b, a, 2, false), c.add(d));
      }
      function qf(a, b, c) {
        var d = 0;
        b && (d |= 4);
        pf(c, a, d, b);
      }
      var rf = "_reactListening" + Math.random().toString(36).slice(2);
      function sf(a) {
        if (!a[rf]) {
          a[rf] = true;
          da.forEach(function(b2) {
            "selectionchange" !== b2 && (mf.has(b2) || qf(b2, false, a), qf(b2, true, a));
          });
          var b = 9 === a.nodeType ? a : a.ownerDocument;
          null === b || b[rf] || (b[rf] = true, qf("selectionchange", false, b));
        }
      }
      function pf(a, b, c, d) {
        switch (jd(b)) {
          case 1:
            var e = ed;
            break;
          case 4:
            e = gd;
            break;
          default:
            e = fd;
        }
        c = e.bind(null, b, c, a);
        e = void 0;
        !Lb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = true);
        d ? void 0 !== e ? a.addEventListener(b, c, { capture: true, passive: e }) : a.addEventListener(b, c, true) : void 0 !== e ? a.addEventListener(b, c, { passive: e }) : a.addEventListener(b, c, false);
      }
      function hd(a, b, c, d, e) {
        var f = d;
        if (0 === (b & 1) && 0 === (b & 2) && null !== d) a: for (; ; ) {
          if (null === d) return;
          var g = d.tag;
          if (3 === g || 4 === g) {
            var h = d.stateNode.containerInfo;
            if (h === e || 8 === h.nodeType && h.parentNode === e) break;
            if (4 === g) for (g = d.return; null !== g; ) {
              var k = g.tag;
              if (3 === k || 4 === k) {
                if (k = g.stateNode.containerInfo, k === e || 8 === k.nodeType && k.parentNode === e) return;
              }
              g = g.return;
            }
            for (; null !== h; ) {
              g = Wc(h);
              if (null === g) return;
              k = g.tag;
              if (5 === k || 6 === k) {
                d = f = g;
                continue a;
              }
              h = h.parentNode;
            }
          }
          d = d.return;
        }
        Jb(function() {
          var d2 = f, e2 = xb(c), g2 = [];
          a: {
            var h2 = df.get(a);
            if (void 0 !== h2) {
              var k2 = td, n = a;
              switch (a) {
                case "keypress":
                  if (0 === od(c)) break a;
                case "keydown":
                case "keyup":
                  k2 = Rd;
                  break;
                case "focusin":
                  n = "focus";
                  k2 = Fd;
                  break;
                case "focusout":
                  n = "blur";
                  k2 = Fd;
                  break;
                case "beforeblur":
                case "afterblur":
                  k2 = Fd;
                  break;
                case "click":
                  if (2 === c.button) break a;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                  k2 = Bd;
                  break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                  k2 = Dd;
                  break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                  k2 = Vd;
                  break;
                case $e:
                case af:
                case bf:
                  k2 = Hd;
                  break;
                case cf:
                  k2 = Xd;
                  break;
                case "scroll":
                  k2 = vd;
                  break;
                case "wheel":
                  k2 = Zd;
                  break;
                case "copy":
                case "cut":
                case "paste":
                  k2 = Jd;
                  break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                  k2 = Td;
              }
              var t = 0 !== (b & 4), J = !t && "scroll" === a, x = t ? null !== h2 ? h2 + "Capture" : null : h2;
              t = [];
              for (var w = d2, u; null !== w; ) {
                u = w;
                var F = u.stateNode;
                5 === u.tag && null !== F && (u = F, null !== x && (F = Kb(w, x), null != F && t.push(tf(w, F, u))));
                if (J) break;
                w = w.return;
              }
              0 < t.length && (h2 = new k2(h2, n, null, c, e2), g2.push({ event: h2, listeners: t }));
            }
          }
          if (0 === (b & 7)) {
            a: {
              h2 = "mouseover" === a || "pointerover" === a;
              k2 = "mouseout" === a || "pointerout" === a;
              if (h2 && c !== wb && (n = c.relatedTarget || c.fromElement) && (Wc(n) || n[uf])) break a;
              if (k2 || h2) {
                h2 = e2.window === e2 ? e2 : (h2 = e2.ownerDocument) ? h2.defaultView || h2.parentWindow : window;
                if (k2) {
                  if (n = c.relatedTarget || c.toElement, k2 = d2, n = n ? Wc(n) : null, null !== n && (J = Vb(n), n !== J || 5 !== n.tag && 6 !== n.tag)) n = null;
                } else k2 = null, n = d2;
                if (k2 !== n) {
                  t = Bd;
                  F = "onMouseLeave";
                  x = "onMouseEnter";
                  w = "mouse";
                  if ("pointerout" === a || "pointerover" === a) t = Td, F = "onPointerLeave", x = "onPointerEnter", w = "pointer";
                  J = null == k2 ? h2 : ue(k2);
                  u = null == n ? h2 : ue(n);
                  h2 = new t(F, w + "leave", k2, c, e2);
                  h2.target = J;
                  h2.relatedTarget = u;
                  F = null;
                  Wc(e2) === d2 && (t = new t(x, w + "enter", n, c, e2), t.target = u, t.relatedTarget = J, F = t);
                  J = F;
                  if (k2 && n) b: {
                    t = k2;
                    x = n;
                    w = 0;
                    for (u = t; u; u = vf(u)) w++;
                    u = 0;
                    for (F = x; F; F = vf(F)) u++;
                    for (; 0 < w - u; ) t = vf(t), w--;
                    for (; 0 < u - w; ) x = vf(x), u--;
                    for (; w--; ) {
                      if (t === x || null !== x && t === x.alternate) break b;
                      t = vf(t);
                      x = vf(x);
                    }
                    t = null;
                  }
                  else t = null;
                  null !== k2 && wf(g2, h2, k2, t, false);
                  null !== n && null !== J && wf(g2, J, n, t, true);
                }
              }
            }
            a: {
              h2 = d2 ? ue(d2) : window;
              k2 = h2.nodeName && h2.nodeName.toLowerCase();
              if ("select" === k2 || "input" === k2 && "file" === h2.type) var na = ve;
              else if (me(h2)) if (we) na = Fe;
              else {
                na = De;
                var xa = Ce;
              }
              else (k2 = h2.nodeName) && "input" === k2.toLowerCase() && ("checkbox" === h2.type || "radio" === h2.type) && (na = Ee);
              if (na && (na = na(a, d2))) {
                ne(g2, na, c, e2);
                break a;
              }
              xa && xa(a, h2, d2);
              "focusout" === a && (xa = h2._wrapperState) && xa.controlled && "number" === h2.type && cb(h2, "number", h2.value);
            }
            xa = d2 ? ue(d2) : window;
            switch (a) {
              case "focusin":
                if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d2, Se = null;
                break;
              case "focusout":
                Se = Re = Qe = null;
                break;
              case "mousedown":
                Te = true;
                break;
              case "contextmenu":
              case "mouseup":
              case "dragend":
                Te = false;
                Ue(g2, c, e2);
                break;
              case "selectionchange":
                if (Pe) break;
              case "keydown":
              case "keyup":
                Ue(g2, c, e2);
            }
            var $a;
            if (ae) b: {
              switch (a) {
                case "compositionstart":
                  var ba = "onCompositionStart";
                  break b;
                case "compositionend":
                  ba = "onCompositionEnd";
                  break b;
                case "compositionupdate":
                  ba = "onCompositionUpdate";
                  break b;
              }
              ba = void 0;
            }
            else ie ? ge(a, c) && (ba = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (ba = "onCompositionStart");
            ba && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e2, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d2, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c, e2), g2.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c), null !== $a && (ba.data = $a))));
            if ($a = ce ? je(a, c) : ke(a, c)) d2 = oe(d2, "onBeforeInput"), 0 < d2.length && (e2 = new Ld("onBeforeInput", "beforeinput", null, c, e2), g2.push({ event: e2, listeners: d2 }), e2.data = $a);
          }
          se(g2, b);
        });
      }
      function tf(a, b, c) {
        return { instance: a, listener: b, currentTarget: c };
      }
      function oe(a, b) {
        for (var c = b + "Capture", d = []; null !== a; ) {
          var e = a, f = e.stateNode;
          5 === e.tag && null !== f && (e = f, f = Kb(a, c), null != f && d.unshift(tf(a, f, e)), f = Kb(a, b), null != f && d.push(tf(a, f, e)));
          a = a.return;
        }
        return d;
      }
      function vf(a) {
        if (null === a) return null;
        do
          a = a.return;
        while (a && 5 !== a.tag);
        return a ? a : null;
      }
      function wf(a, b, c, d, e) {
        for (var f = b._reactName, g = []; null !== c && c !== d; ) {
          var h = c, k = h.alternate, l = h.stateNode;
          if (null !== k && k === d) break;
          5 === h.tag && null !== l && (h = l, e ? (k = Kb(c, f), null != k && g.unshift(tf(c, k, h))) : e || (k = Kb(c, f), null != k && g.push(tf(c, k, h))));
          c = c.return;
        }
        0 !== g.length && a.push({ event: b, listeners: g });
      }
      var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
      function zf(a) {
        return ("string" === typeof a ? a : "" + a).replace(xf, "\n").replace(yf, "");
      }
      function Af(a, b, c) {
        b = zf(b);
        if (zf(a) !== b && c) throw Error(p(425));
      }
      function Bf() {
      }
      var Cf = null, Df = null;
      function Ef(a, b) {
        return "textarea" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
      }
      var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a) {
        return Hf.resolve(null).then(a).catch(If);
      } : Ff;
      function If(a) {
        setTimeout(function() {
          throw a;
        });
      }
      function Kf(a, b) {
        var c = b, d = 0;
        do {
          var e = c.nextSibling;
          a.removeChild(c);
          if (e && 8 === e.nodeType) if (c = e.data, "/$" === c) {
            if (0 === d) {
              a.removeChild(e);
              bd(b);
              return;
            }
            d--;
          } else "$" !== c && "$?" !== c && "$!" !== c || d++;
          c = e;
        } while (c);
        bd(b);
      }
      function Lf(a) {
        for (; null != a; a = a.nextSibling) {
          var b = a.nodeType;
          if (1 === b || 3 === b) break;
          if (8 === b) {
            b = a.data;
            if ("$" === b || "$!" === b || "$?" === b) break;
            if ("/$" === b) return null;
          }
        }
        return a;
      }
      function Mf(a) {
        a = a.previousSibling;
        for (var b = 0; a; ) {
          if (8 === a.nodeType) {
            var c = a.data;
            if ("$" === c || "$!" === c || "$?" === c) {
              if (0 === b) return a;
              b--;
            } else "/$" === c && b++;
          }
          a = a.previousSibling;
        }
        return null;
      }
      var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
      function Wc(a) {
        var b = a[Of];
        if (b) return b;
        for (var c = a.parentNode; c; ) {
          if (b = c[uf] || c[Of]) {
            c = b.alternate;
            if (null !== b.child || null !== c && null !== c.child) for (a = Mf(a); null !== a; ) {
              if (c = a[Of]) return c;
              a = Mf(a);
            }
            return b;
          }
          a = c;
          c = a.parentNode;
        }
        return null;
      }
      function Cb(a) {
        a = a[Of] || a[uf];
        return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
      }
      function ue(a) {
        if (5 === a.tag || 6 === a.tag) return a.stateNode;
        throw Error(p(33));
      }
      function Db(a) {
        return a[Pf] || null;
      }
      var Sf = [], Tf = -1;
      function Uf(a) {
        return { current: a };
      }
      function E(a) {
        0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
      }
      function G(a, b) {
        Tf++;
        Sf[Tf] = a.current;
        a.current = b;
      }
      var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
      function Yf(a, b) {
        var c = a.type.contextTypes;
        if (!c) return Vf;
        var d = a.stateNode;
        if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;
        var e = {}, f;
        for (f in c) e[f] = b[f];
        d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
        return e;
      }
      function Zf(a) {
        a = a.childContextTypes;
        return null !== a && void 0 !== a;
      }
      function $f() {
        E(Wf);
        E(H);
      }
      function ag(a, b, c) {
        if (H.current !== Vf) throw Error(p(168));
        G(H, b);
        G(Wf, c);
      }
      function bg(a, b, c) {
        var d = a.stateNode;
        b = b.childContextTypes;
        if ("function" !== typeof d.getChildContext) return c;
        d = d.getChildContext();
        for (var e in d) if (!(e in b)) throw Error(p(108, Ra(a) || "Unknown", e));
        return A({}, c, d);
      }
      function cg(a) {
        a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf;
        Xf = H.current;
        G(H, a);
        G(Wf, Wf.current);
        return true;
      }
      function dg(a, b, c) {
        var d = a.stateNode;
        if (!d) throw Error(p(169));
        c ? (a = bg(a, b, Xf), d.__reactInternalMemoizedMergedChildContext = a, E(Wf), E(H), G(H, a)) : E(Wf);
        G(Wf, c);
      }
      var eg = null, fg = false, gg = false;
      function hg(a) {
        null === eg ? eg = [a] : eg.push(a);
      }
      function ig(a) {
        fg = true;
        hg(a);
      }
      function jg() {
        if (!gg && null !== eg) {
          gg = true;
          var a = 0, b = C;
          try {
            var c = eg;
            for (C = 1; a < c.length; a++) {
              var d = c[a];
              do
                d = d(true);
              while (null !== d);
            }
            eg = null;
            fg = false;
          } catch (e) {
            throw null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e;
          } finally {
            C = b, gg = false;
          }
        }
        return null;
      }
      var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
      function tg(a, b) {
        kg[lg++] = ng;
        kg[lg++] = mg;
        mg = a;
        ng = b;
      }
      function ug(a, b, c) {
        og[pg++] = rg;
        og[pg++] = sg;
        og[pg++] = qg;
        qg = a;
        var d = rg;
        a = sg;
        var e = 32 - oc(d) - 1;
        d &= ~(1 << e);
        c += 1;
        var f = 32 - oc(b) + e;
        if (30 < f) {
          var g = e - e % 5;
          f = (d & (1 << g) - 1).toString(32);
          d >>= g;
          e -= g;
          rg = 1 << 32 - oc(b) + e | c << e | d;
          sg = f + a;
        } else rg = 1 << f | c << e | d, sg = a;
      }
      function vg(a) {
        null !== a.return && (tg(a, 1), ug(a, 1, 0));
      }
      function wg(a) {
        for (; a === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
        for (; a === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
      }
      var xg = null, yg = null, I = false, zg = null;
      function Ag(a, b) {
        var c = Bg(5, null, null, 0);
        c.elementType = "DELETED";
        c.stateNode = b;
        c.return = a;
        b = a.deletions;
        null === b ? (a.deletions = [c], a.flags |= 16) : b.push(c);
      }
      function Cg(a, b) {
        switch (a.tag) {
          case 5:
            var c = a.type;
            b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
            return null !== b ? (a.stateNode = b, xg = a, yg = Lf(b.firstChild), true) : false;
          case 6:
            return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, xg = a, yg = null, true) : false;
          case 13:
            return b = 8 !== b.nodeType ? null : b, null !== b ? (c = null !== qg ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b, treeContext: c, retryLane: 1073741824 }, c = Bg(18, null, null, 0), c.stateNode = b, c.return = a, a.child = c, xg = a, yg = null, true) : false;
          default:
            return false;
        }
      }
      function Dg(a) {
        return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
      }
      function Eg(a) {
        if (I) {
          var b = yg;
          if (b) {
            var c = b;
            if (!Cg(a, b)) {
              if (Dg(a)) throw Error(p(418));
              b = Lf(c.nextSibling);
              var d = xg;
              b && Cg(a, b) ? Ag(d, c) : (a.flags = a.flags & -4097 | 2, I = false, xg = a);
            }
          } else {
            if (Dg(a)) throw Error(p(418));
            a.flags = a.flags & -4097 | 2;
            I = false;
            xg = a;
          }
        }
      }
      function Fg(a) {
        for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag; ) a = a.return;
        xg = a;
      }
      function Gg(a) {
        if (a !== xg) return false;
        if (!I) return Fg(a), I = true, false;
        var b;
        (b = 3 !== a.tag) && !(b = 5 !== a.tag) && (b = a.type, b = "head" !== b && "body" !== b && !Ef(a.type, a.memoizedProps));
        if (b && (b = yg)) {
          if (Dg(a)) throw Hg(), Error(p(418));
          for (; b; ) Ag(a, b), b = Lf(b.nextSibling);
        }
        Fg(a);
        if (13 === a.tag) {
          a = a.memoizedState;
          a = null !== a ? a.dehydrated : null;
          if (!a) throw Error(p(317));
          a: {
            a = a.nextSibling;
            for (b = 0; a; ) {
              if (8 === a.nodeType) {
                var c = a.data;
                if ("/$" === c) {
                  if (0 === b) {
                    yg = Lf(a.nextSibling);
                    break a;
                  }
                  b--;
                } else "$" !== c && "$!" !== c && "$?" !== c || b++;
              }
              a = a.nextSibling;
            }
            yg = null;
          }
        } else yg = xg ? Lf(a.stateNode.nextSibling) : null;
        return true;
      }
      function Hg() {
        for (var a = yg; a; ) a = Lf(a.nextSibling);
      }
      function Ig() {
        yg = xg = null;
        I = false;
      }
      function Jg(a) {
        null === zg ? zg = [a] : zg.push(a);
      }
      var Kg = ua.ReactCurrentBatchConfig;
      function Lg(a, b, c) {
        a = c.ref;
        if (null !== a && "function" !== typeof a && "object" !== typeof a) {
          if (c._owner) {
            c = c._owner;
            if (c) {
              if (1 !== c.tag) throw Error(p(309));
              var d = c.stateNode;
            }
            if (!d) throw Error(p(147, a));
            var e = d, f = "" + a;
            if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === f) return b.ref;
            b = function(a2) {
              var b2 = e.refs;
              null === a2 ? delete b2[f] : b2[f] = a2;
            };
            b._stringRef = f;
            return b;
          }
          if ("string" !== typeof a) throw Error(p(284));
          if (!c._owner) throw Error(p(290, a));
        }
        return a;
      }
      function Mg(a, b) {
        a = Object.prototype.toString.call(b);
        throw Error(p(31, "[object Object]" === a ? "object with keys {" + Object.keys(b).join(", ") + "}" : a));
      }
      function Ng(a) {
        var b = a._init;
        return b(a._payload);
      }
      function Og(a) {
        function b(b2, c2) {
          if (a) {
            var d2 = b2.deletions;
            null === d2 ? (b2.deletions = [c2], b2.flags |= 16) : d2.push(c2);
          }
        }
        function c(c2, d2) {
          if (!a) return null;
          for (; null !== d2; ) b(c2, d2), d2 = d2.sibling;
          return null;
        }
        function d(a2, b2) {
          for (a2 = /* @__PURE__ */ new Map(); null !== b2; ) null !== b2.key ? a2.set(b2.key, b2) : a2.set(b2.index, b2), b2 = b2.sibling;
          return a2;
        }
        function e(a2, b2) {
          a2 = Pg(a2, b2);
          a2.index = 0;
          a2.sibling = null;
          return a2;
        }
        function f(b2, c2, d2) {
          b2.index = d2;
          if (!a) return b2.flags |= 1048576, c2;
          d2 = b2.alternate;
          if (null !== d2) return d2 = d2.index, d2 < c2 ? (b2.flags |= 2, c2) : d2;
          b2.flags |= 2;
          return c2;
        }
        function g(b2) {
          a && null === b2.alternate && (b2.flags |= 2);
          return b2;
        }
        function h(a2, b2, c2, d2) {
          if (null === b2 || 6 !== b2.tag) return b2 = Qg(c2, a2.mode, d2), b2.return = a2, b2;
          b2 = e(b2, c2);
          b2.return = a2;
          return b2;
        }
        function k(a2, b2, c2, d2) {
          var f2 = c2.type;
          if (f2 === ya) return m(a2, b2, c2.props.children, d2, c2.key);
          if (null !== b2 && (b2.elementType === f2 || "object" === typeof f2 && null !== f2 && f2.$$typeof === Ha && Ng(f2) === b2.type)) return d2 = e(b2, c2.props), d2.ref = Lg(a2, b2, c2), d2.return = a2, d2;
          d2 = Rg(c2.type, c2.key, c2.props, null, a2.mode, d2);
          d2.ref = Lg(a2, b2, c2);
          d2.return = a2;
          return d2;
        }
        function l(a2, b2, c2, d2) {
          if (null === b2 || 4 !== b2.tag || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation) return b2 = Sg(c2, a2.mode, d2), b2.return = a2, b2;
          b2 = e(b2, c2.children || []);
          b2.return = a2;
          return b2;
        }
        function m(a2, b2, c2, d2, f2) {
          if (null === b2 || 7 !== b2.tag) return b2 = Tg(c2, a2.mode, d2, f2), b2.return = a2, b2;
          b2 = e(b2, c2);
          b2.return = a2;
          return b2;
        }
        function q(a2, b2, c2) {
          if ("string" === typeof b2 && "" !== b2 || "number" === typeof b2) return b2 = Qg("" + b2, a2.mode, c2), b2.return = a2, b2;
          if ("object" === typeof b2 && null !== b2) {
            switch (b2.$$typeof) {
              case va:
                return c2 = Rg(b2.type, b2.key, b2.props, null, a2.mode, c2), c2.ref = Lg(a2, null, b2), c2.return = a2, c2;
              case wa:
                return b2 = Sg(b2, a2.mode, c2), b2.return = a2, b2;
              case Ha:
                var d2 = b2._init;
                return q(a2, d2(b2._payload), c2);
            }
            if (eb(b2) || Ka(b2)) return b2 = Tg(b2, a2.mode, c2, null), b2.return = a2, b2;
            Mg(a2, b2);
          }
          return null;
        }
        function r(a2, b2, c2, d2) {
          var e2 = null !== b2 ? b2.key : null;
          if ("string" === typeof c2 && "" !== c2 || "number" === typeof c2) return null !== e2 ? null : h(a2, b2, "" + c2, d2);
          if ("object" === typeof c2 && null !== c2) {
            switch (c2.$$typeof) {
              case va:
                return c2.key === e2 ? k(a2, b2, c2, d2) : null;
              case wa:
                return c2.key === e2 ? l(a2, b2, c2, d2) : null;
              case Ha:
                return e2 = c2._init, r(
                  a2,
                  b2,
                  e2(c2._payload),
                  d2
                );
            }
            if (eb(c2) || Ka(c2)) return null !== e2 ? null : m(a2, b2, c2, d2, null);
            Mg(a2, c2);
          }
          return null;
        }
        function y(a2, b2, c2, d2, e2) {
          if ("string" === typeof d2 && "" !== d2 || "number" === typeof d2) return a2 = a2.get(c2) || null, h(b2, a2, "" + d2, e2);
          if ("object" === typeof d2 && null !== d2) {
            switch (d2.$$typeof) {
              case va:
                return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, k(b2, a2, d2, e2);
              case wa:
                return a2 = a2.get(null === d2.key ? c2 : d2.key) || null, l(b2, a2, d2, e2);
              case Ha:
                var f2 = d2._init;
                return y(a2, b2, c2, f2(d2._payload), e2);
            }
            if (eb(d2) || Ka(d2)) return a2 = a2.get(c2) || null, m(b2, a2, d2, e2, null);
            Mg(b2, d2);
          }
          return null;
        }
        function n(e2, g2, h2, k2) {
          for (var l2 = null, m2 = null, u = g2, w = g2 = 0, x = null; null !== u && w < h2.length; w++) {
            u.index > w ? (x = u, u = null) : x = u.sibling;
            var n2 = r(e2, u, h2[w], k2);
            if (null === n2) {
              null === u && (u = x);
              break;
            }
            a && u && null === n2.alternate && b(e2, u);
            g2 = f(n2, g2, w);
            null === m2 ? l2 = n2 : m2.sibling = n2;
            m2 = n2;
            u = x;
          }
          if (w === h2.length) return c(e2, u), I && tg(e2, w), l2;
          if (null === u) {
            for (; w < h2.length; w++) u = q(e2, h2[w], k2), null !== u && (g2 = f(u, g2, w), null === m2 ? l2 = u : m2.sibling = u, m2 = u);
            I && tg(e2, w);
            return l2;
          }
          for (u = d(e2, u); w < h2.length; w++) x = y(u, e2, w, h2[w], k2), null !== x && (a && null !== x.alternate && u.delete(null === x.key ? w : x.key), g2 = f(x, g2, w), null === m2 ? l2 = x : m2.sibling = x, m2 = x);
          a && u.forEach(function(a2) {
            return b(e2, a2);
          });
          I && tg(e2, w);
          return l2;
        }
        function t(e2, g2, h2, k2) {
          var l2 = Ka(h2);
          if ("function" !== typeof l2) throw Error(p(150));
          h2 = l2.call(h2);
          if (null == h2) throw Error(p(151));
          for (var u = l2 = null, m2 = g2, w = g2 = 0, x = null, n2 = h2.next(); null !== m2 && !n2.done; w++, n2 = h2.next()) {
            m2.index > w ? (x = m2, m2 = null) : x = m2.sibling;
            var t2 = r(e2, m2, n2.value, k2);
            if (null === t2) {
              null === m2 && (m2 = x);
              break;
            }
            a && m2 && null === t2.alternate && b(e2, m2);
            g2 = f(t2, g2, w);
            null === u ? l2 = t2 : u.sibling = t2;
            u = t2;
            m2 = x;
          }
          if (n2.done) return c(
            e2,
            m2
          ), I && tg(e2, w), l2;
          if (null === m2) {
            for (; !n2.done; w++, n2 = h2.next()) n2 = q(e2, n2.value, k2), null !== n2 && (g2 = f(n2, g2, w), null === u ? l2 = n2 : u.sibling = n2, u = n2);
            I && tg(e2, w);
            return l2;
          }
          for (m2 = d(e2, m2); !n2.done; w++, n2 = h2.next()) n2 = y(m2, e2, w, n2.value, k2), null !== n2 && (a && null !== n2.alternate && m2.delete(null === n2.key ? w : n2.key), g2 = f(n2, g2, w), null === u ? l2 = n2 : u.sibling = n2, u = n2);
          a && m2.forEach(function(a2) {
            return b(e2, a2);
          });
          I && tg(e2, w);
          return l2;
        }
        function J(a2, d2, f2, h2) {
          "object" === typeof f2 && null !== f2 && f2.type === ya && null === f2.key && (f2 = f2.props.children);
          if ("object" === typeof f2 && null !== f2) {
            switch (f2.$$typeof) {
              case va:
                a: {
                  for (var k2 = f2.key, l2 = d2; null !== l2; ) {
                    if (l2.key === k2) {
                      k2 = f2.type;
                      if (k2 === ya) {
                        if (7 === l2.tag) {
                          c(a2, l2.sibling);
                          d2 = e(l2, f2.props.children);
                          d2.return = a2;
                          a2 = d2;
                          break a;
                        }
                      } else if (l2.elementType === k2 || "object" === typeof k2 && null !== k2 && k2.$$typeof === Ha && Ng(k2) === l2.type) {
                        c(a2, l2.sibling);
                        d2 = e(l2, f2.props);
                        d2.ref = Lg(a2, l2, f2);
                        d2.return = a2;
                        a2 = d2;
                        break a;
                      }
                      c(a2, l2);
                      break;
                    } else b(a2, l2);
                    l2 = l2.sibling;
                  }
                  f2.type === ya ? (d2 = Tg(f2.props.children, a2.mode, h2, f2.key), d2.return = a2, a2 = d2) : (h2 = Rg(f2.type, f2.key, f2.props, null, a2.mode, h2), h2.ref = Lg(a2, d2, f2), h2.return = a2, a2 = h2);
                }
                return g(a2);
              case wa:
                a: {
                  for (l2 = f2.key; null !== d2; ) {
                    if (d2.key === l2) if (4 === d2.tag && d2.stateNode.containerInfo === f2.containerInfo && d2.stateNode.implementation === f2.implementation) {
                      c(a2, d2.sibling);
                      d2 = e(d2, f2.children || []);
                      d2.return = a2;
                      a2 = d2;
                      break a;
                    } else {
                      c(a2, d2);
                      break;
                    }
                    else b(a2, d2);
                    d2 = d2.sibling;
                  }
                  d2 = Sg(f2, a2.mode, h2);
                  d2.return = a2;
                  a2 = d2;
                }
                return g(a2);
              case Ha:
                return l2 = f2._init, J(a2, d2, l2(f2._payload), h2);
            }
            if (eb(f2)) return n(a2, d2, f2, h2);
            if (Ka(f2)) return t(a2, d2, f2, h2);
            Mg(a2, f2);
          }
          return "string" === typeof f2 && "" !== f2 || "number" === typeof f2 ? (f2 = "" + f2, null !== d2 && 6 === d2.tag ? (c(a2, d2.sibling), d2 = e(d2, f2), d2.return = a2, a2 = d2) : (c(a2, d2), d2 = Qg(f2, a2.mode, h2), d2.return = a2, a2 = d2), g(a2)) : c(a2, d2);
        }
        return J;
      }
      var Ug = Og(true), Vg = Og(false), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
      function $g() {
        Zg = Yg = Xg = null;
      }
      function ah(a) {
        var b = Wg.current;
        E(Wg);
        a._currentValue = b;
      }
      function bh(a, b, c) {
        for (; null !== a; ) {
          var d = a.alternate;
          (a.childLanes & b) !== b ? (a.childLanes |= b, null !== d && (d.childLanes |= b)) : null !== d && (d.childLanes & b) !== b && (d.childLanes |= b);
          if (a === c) break;
          a = a.return;
        }
      }
      function ch(a, b) {
        Xg = a;
        Zg = Yg = null;
        a = a.dependencies;
        null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (dh = true), a.firstContext = null);
      }
      function eh(a) {
        var b = a._currentValue;
        if (Zg !== a) if (a = { context: a, memoizedValue: b, next: null }, null === Yg) {
          if (null === Xg) throw Error(p(308));
          Yg = a;
          Xg.dependencies = { lanes: 0, firstContext: a };
        } else Yg = Yg.next = a;
        return b;
      }
      var fh = null;
      function gh(a) {
        null === fh ? fh = [a] : fh.push(a);
      }
      function hh(a, b, c, d) {
        var e = b.interleaved;
        null === e ? (c.next = c, gh(b)) : (c.next = e.next, e.next = c);
        b.interleaved = c;
        return ih(a, d);
      }
      function ih(a, b) {
        a.lanes |= b;
        var c = a.alternate;
        null !== c && (c.lanes |= b);
        c = a;
        for (a = a.return; null !== a; ) a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;
        return 3 === c.tag ? c.stateNode : null;
      }
      var jh = false;
      function kh(a) {
        a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
      }
      function lh(a, b) {
        a = a.updateQueue;
        b.updateQueue === a && (b.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
      }
      function mh(a, b) {
        return { eventTime: a, lane: b, tag: 0, payload: null, callback: null, next: null };
      }
      function nh(a, b, c) {
        var d = a.updateQueue;
        if (null === d) return null;
        d = d.shared;
        if (0 !== (K & 2)) {
          var e = d.pending;
          null === e ? b.next = b : (b.next = e.next, e.next = b);
          d.pending = b;
          return ih(a, c);
        }
        e = d.interleaved;
        null === e ? (b.next = b, gh(d)) : (b.next = e.next, e.next = b);
        d.interleaved = b;
        return ih(a, c);
      }
      function oh(a, b, c) {
        b = b.updateQueue;
        if (null !== b && (b = b.shared, 0 !== (c & 4194240))) {
          var d = b.lanes;
          d &= a.pendingLanes;
          c |= d;
          b.lanes = c;
          Cc(a, c);
        }
      }
      function ph(a, b) {
        var c = a.updateQueue, d = a.alternate;
        if (null !== d && (d = d.updateQueue, c === d)) {
          var e = null, f = null;
          c = c.firstBaseUpdate;
          if (null !== c) {
            do {
              var g = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
              null === f ? e = f = g : f = f.next = g;
              c = c.next;
            } while (null !== c);
            null === f ? e = f = b : f = f.next = b;
          } else e = f = b;
          c = { baseState: d.baseState, firstBaseUpdate: e, lastBaseUpdate: f, shared: d.shared, effects: d.effects };
          a.updateQueue = c;
          return;
        }
        a = c.lastBaseUpdate;
        null === a ? c.firstBaseUpdate = b : a.next = b;
        c.lastBaseUpdate = b;
      }
      function qh(a, b, c, d) {
        var e = a.updateQueue;
        jh = false;
        var f = e.firstBaseUpdate, g = e.lastBaseUpdate, h = e.shared.pending;
        if (null !== h) {
          e.shared.pending = null;
          var k = h, l = k.next;
          k.next = null;
          null === g ? f = l : g.next = l;
          g = k;
          var m = a.alternate;
          null !== m && (m = m.updateQueue, h = m.lastBaseUpdate, h !== g && (null === h ? m.firstBaseUpdate = l : h.next = l, m.lastBaseUpdate = k));
        }
        if (null !== f) {
          var q = e.baseState;
          g = 0;
          m = l = k = null;
          h = f;
          do {
            var r = h.lane, y = h.eventTime;
            if ((d & r) === r) {
              null !== m && (m = m.next = {
                eventTime: y,
                lane: 0,
                tag: h.tag,
                payload: h.payload,
                callback: h.callback,
                next: null
              });
              a: {
                var n = a, t = h;
                r = b;
                y = c;
                switch (t.tag) {
                  case 1:
                    n = t.payload;
                    if ("function" === typeof n) {
                      q = n.call(y, q, r);
                      break a;
                    }
                    q = n;
                    break a;
                  case 3:
                    n.flags = n.flags & -65537 | 128;
                  case 0:
                    n = t.payload;
                    r = "function" === typeof n ? n.call(y, q, r) : n;
                    if (null === r || void 0 === r) break a;
                    q = A({}, q, r);
                    break a;
                  case 2:
                    jh = true;
                }
              }
              null !== h.callback && 0 !== h.lane && (a.flags |= 64, r = e.effects, null === r ? e.effects = [h] : r.push(h));
            } else y = { eventTime: y, lane: r, tag: h.tag, payload: h.payload, callback: h.callback, next: null }, null === m ? (l = m = y, k = q) : m = m.next = y, g |= r;
            h = h.next;
            if (null === h) if (h = e.shared.pending, null === h) break;
            else r = h, h = r.next, r.next = null, e.lastBaseUpdate = r, e.shared.pending = null;
          } while (1);
          null === m && (k = q);
          e.baseState = k;
          e.firstBaseUpdate = l;
          e.lastBaseUpdate = m;
          b = e.shared.interleaved;
          if (null !== b) {
            e = b;
            do
              g |= e.lane, e = e.next;
            while (e !== b);
          } else null === f && (e.shared.lanes = 0);
          rh |= g;
          a.lanes = g;
          a.memoizedState = q;
        }
      }
      function sh(a, b, c) {
        a = b.effects;
        b.effects = null;
        if (null !== a) for (b = 0; b < a.length; b++) {
          var d = a[b], e = d.callback;
          if (null !== e) {
            d.callback = null;
            d = c;
            if ("function" !== typeof e) throw Error(p(191, e));
            e.call(d);
          }
        }
      }
      var th = {}, uh = Uf(th), vh = Uf(th), wh = Uf(th);
      function xh(a) {
        if (a === th) throw Error(p(174));
        return a;
      }
      function yh(a, b) {
        G(wh, b);
        G(vh, a);
        G(uh, th);
        a = b.nodeType;
        switch (a) {
          case 9:
          case 11:
            b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
            break;
          default:
            a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = lb(b, a);
        }
        E(uh);
        G(uh, b);
      }
      function zh() {
        E(uh);
        E(vh);
        E(wh);
      }
      function Ah(a) {
        xh(wh.current);
        var b = xh(uh.current);
        var c = lb(b, a.type);
        b !== c && (G(vh, a), G(uh, c));
      }
      function Bh(a) {
        vh.current === a && (E(uh), E(vh));
      }
      var L = Uf(0);
      function Ch(a) {
        for (var b = a; null !== b; ) {
          if (13 === b.tag) {
            var c = b.memoizedState;
            if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data)) return b;
          } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
            if (0 !== (b.flags & 128)) return b;
          } else if (null !== b.child) {
            b.child.return = b;
            b = b.child;
            continue;
          }
          if (b === a) break;
          for (; null === b.sibling; ) {
            if (null === b.return || b.return === a) return null;
            b = b.return;
          }
          b.sibling.return = b.return;
          b = b.sibling;
        }
        return null;
      }
      var Dh = [];
      function Eh() {
        for (var a = 0; a < Dh.length; a++) Dh[a]._workInProgressVersionPrimary = null;
        Dh.length = 0;
      }
      var Fh = ua.ReactCurrentDispatcher, Gh = ua.ReactCurrentBatchConfig, Hh = 0, M = null, N = null, O = null, Ih = false, Jh = false, Kh = 0, Lh = 0;
      function P() {
        throw Error(p(321));
      }
      function Mh(a, b) {
        if (null === b) return false;
        for (var c = 0; c < b.length && c < a.length; c++) if (!He(a[c], b[c])) return false;
        return true;
      }
      function Nh(a, b, c, d, e, f) {
        Hh = f;
        M = b;
        b.memoizedState = null;
        b.updateQueue = null;
        b.lanes = 0;
        Fh.current = null === a || null === a.memoizedState ? Oh : Ph;
        a = c(d, e);
        if (Jh) {
          f = 0;
          do {
            Jh = false;
            Kh = 0;
            if (25 <= f) throw Error(p(301));
            f += 1;
            O = N = null;
            b.updateQueue = null;
            Fh.current = Qh;
            a = c(d, e);
          } while (Jh);
        }
        Fh.current = Rh;
        b = null !== N && null !== N.next;
        Hh = 0;
        O = N = M = null;
        Ih = false;
        if (b) throw Error(p(300));
        return a;
      }
      function Sh() {
        var a = 0 !== Kh;
        Kh = 0;
        return a;
      }
      function Th() {
        var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
        null === O ? M.memoizedState = O = a : O = O.next = a;
        return O;
      }
      function Uh() {
        if (null === N) {
          var a = M.alternate;
          a = null !== a ? a.memoizedState : null;
        } else a = N.next;
        var b = null === O ? M.memoizedState : O.next;
        if (null !== b) O = b, N = a;
        else {
          if (null === a) throw Error(p(310));
          N = a;
          a = { memoizedState: N.memoizedState, baseState: N.baseState, baseQueue: N.baseQueue, queue: N.queue, next: null };
          null === O ? M.memoizedState = O = a : O = O.next = a;
        }
        return O;
      }
      function Vh(a, b) {
        return "function" === typeof b ? b(a) : b;
      }
      function Wh(a) {
        var b = Uh(), c = b.queue;
        if (null === c) throw Error(p(311));
        c.lastRenderedReducer = a;
        var d = N, e = d.baseQueue, f = c.pending;
        if (null !== f) {
          if (null !== e) {
            var g = e.next;
            e.next = f.next;
            f.next = g;
          }
          d.baseQueue = e = f;
          c.pending = null;
        }
        if (null !== e) {
          f = e.next;
          d = d.baseState;
          var h = g = null, k = null, l = f;
          do {
            var m = l.lane;
            if ((Hh & m) === m) null !== k && (k = k.next = { lane: 0, action: l.action, hasEagerState: l.hasEagerState, eagerState: l.eagerState, next: null }), d = l.hasEagerState ? l.eagerState : a(d, l.action);
            else {
              var q = {
                lane: m,
                action: l.action,
                hasEagerState: l.hasEagerState,
                eagerState: l.eagerState,
                next: null
              };
              null === k ? (h = k = q, g = d) : k = k.next = q;
              M.lanes |= m;
              rh |= m;
            }
            l = l.next;
          } while (null !== l && l !== f);
          null === k ? g = d : k.next = h;
          He(d, b.memoizedState) || (dh = true);
          b.memoizedState = d;
          b.baseState = g;
          b.baseQueue = k;
          c.lastRenderedState = d;
        }
        a = c.interleaved;
        if (null !== a) {
          e = a;
          do
            f = e.lane, M.lanes |= f, rh |= f, e = e.next;
          while (e !== a);
        } else null === e && (c.lanes = 0);
        return [b.memoizedState, c.dispatch];
      }
      function Xh(a) {
        var b = Uh(), c = b.queue;
        if (null === c) throw Error(p(311));
        c.lastRenderedReducer = a;
        var d = c.dispatch, e = c.pending, f = b.memoizedState;
        if (null !== e) {
          c.pending = null;
          var g = e = e.next;
          do
            f = a(f, g.action), g = g.next;
          while (g !== e);
          He(f, b.memoizedState) || (dh = true);
          b.memoizedState = f;
          null === b.baseQueue && (b.baseState = f);
          c.lastRenderedState = f;
        }
        return [f, d];
      }
      function Yh() {
      }
      function Zh(a, b) {
        var c = M, d = Uh(), e = b(), f = !He(d.memoizedState, e);
        f && (d.memoizedState = e, dh = true);
        d = d.queue;
        $h(ai.bind(null, c, d, a), [a]);
        if (d.getSnapshot !== b || f || null !== O && O.memoizedState.tag & 1) {
          c.flags |= 2048;
          bi(9, ci.bind(null, c, d, e, b), void 0, null);
          if (null === Q) throw Error(p(349));
          0 !== (Hh & 30) || di(c, b, e);
        }
        return e;
      }
      function di(a, b, c) {
        a.flags |= 16384;
        a = { getSnapshot: b, value: c };
        b = M.updateQueue;
        null === b ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.stores = [a]) : (c = b.stores, null === c ? b.stores = [a] : c.push(a));
      }
      function ci(a, b, c, d) {
        b.value = c;
        b.getSnapshot = d;
        ei(b) && fi(a);
      }
      function ai(a, b, c) {
        return c(function() {
          ei(b) && fi(a);
        });
      }
      function ei(a) {
        var b = a.getSnapshot;
        a = a.value;
        try {
          var c = b();
          return !He(a, c);
        } catch (d) {
          return true;
        }
      }
      function fi(a) {
        var b = ih(a, 1);
        null !== b && gi(b, a, 1, -1);
      }
      function hi(a) {
        var b = Th();
        "function" === typeof a && (a = a());
        b.memoizedState = b.baseState = a;
        a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a };
        b.queue = a;
        a = a.dispatch = ii.bind(null, M, a);
        return [b.memoizedState, a];
      }
      function bi(a, b, c, d) {
        a = { tag: a, create: b, destroy: c, deps: d, next: null };
        b = M.updateQueue;
        null === b ? (b = { lastEffect: null, stores: null }, M.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
        return a;
      }
      function ji() {
        return Uh().memoizedState;
      }
      function ki(a, b, c, d) {
        var e = Th();
        M.flags |= a;
        e.memoizedState = bi(1 | b, c, void 0, void 0 === d ? null : d);
      }
      function li(a, b, c, d) {
        var e = Uh();
        d = void 0 === d ? null : d;
        var f = void 0;
        if (null !== N) {
          var g = N.memoizedState;
          f = g.destroy;
          if (null !== d && Mh(d, g.deps)) {
            e.memoizedState = bi(b, c, f, d);
            return;
          }
        }
        M.flags |= a;
        e.memoizedState = bi(1 | b, c, f, d);
      }
      function mi(a, b) {
        return ki(8390656, 8, a, b);
      }
      function $h(a, b) {
        return li(2048, 8, a, b);
      }
      function ni(a, b) {
        return li(4, 2, a, b);
      }
      function oi(a, b) {
        return li(4, 4, a, b);
      }
      function pi(a, b) {
        if ("function" === typeof b) return a = a(), b(a), function() {
          b(null);
        };
        if (null !== b && void 0 !== b) return a = a(), b.current = a, function() {
          b.current = null;
        };
      }
      function qi(a, b, c) {
        c = null !== c && void 0 !== c ? c.concat([a]) : null;
        return li(4, 4, pi.bind(null, b, a), c);
      }
      function ri() {
      }
      function si(a, b) {
        var c = Uh();
        b = void 0 === b ? null : b;
        var d = c.memoizedState;
        if (null !== d && null !== b && Mh(b, d[1])) return d[0];
        c.memoizedState = [a, b];
        return a;
      }
      function ti(a, b) {
        var c = Uh();
        b = void 0 === b ? null : b;
        var d = c.memoizedState;
        if (null !== d && null !== b && Mh(b, d[1])) return d[0];
        a = a();
        c.memoizedState = [a, b];
        return a;
      }
      function ui(a, b, c) {
        if (0 === (Hh & 21)) return a.baseState && (a.baseState = false, dh = true), a.memoizedState = c;
        He(c, b) || (c = yc(), M.lanes |= c, rh |= c, a.baseState = true);
        return b;
      }
      function vi(a, b) {
        var c = C;
        C = 0 !== c && 4 > c ? c : 4;
        a(true);
        var d = Gh.transition;
        Gh.transition = {};
        try {
          a(false), b();
        } finally {
          C = c, Gh.transition = d;
        }
      }
      function wi() {
        return Uh().memoizedState;
      }
      function xi(a, b, c) {
        var d = yi(a);
        c = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
        if (zi(a)) Ai(b, c);
        else if (c = hh(a, b, c, d), null !== c) {
          var e = R();
          gi(c, a, d, e);
          Bi(c, b, d);
        }
      }
      function ii(a, b, c) {
        var d = yi(a), e = { lane: d, action: c, hasEagerState: false, eagerState: null, next: null };
        if (zi(a)) Ai(b, e);
        else {
          var f = a.alternate;
          if (0 === a.lanes && (null === f || 0 === f.lanes) && (f = b.lastRenderedReducer, null !== f)) try {
            var g = b.lastRenderedState, h = f(g, c);
            e.hasEagerState = true;
            e.eagerState = h;
            if (He(h, g)) {
              var k = b.interleaved;
              null === k ? (e.next = e, gh(b)) : (e.next = k.next, k.next = e);
              b.interleaved = e;
              return;
            }
          } catch (l) {
          } finally {
          }
          c = hh(a, b, e, d);
          null !== c && (e = R(), gi(c, a, d, e), Bi(c, b, d));
        }
      }
      function zi(a) {
        var b = a.alternate;
        return a === M || null !== b && b === M;
      }
      function Ai(a, b) {
        Jh = Ih = true;
        var c = a.pending;
        null === c ? b.next = b : (b.next = c.next, c.next = b);
        a.pending = b;
      }
      function Bi(a, b, c) {
        if (0 !== (c & 4194240)) {
          var d = b.lanes;
          d &= a.pendingLanes;
          c |= d;
          b.lanes = c;
          Cc(a, c);
        }
      }
      var Rh = { readContext: eh, useCallback: P, useContext: P, useEffect: P, useImperativeHandle: P, useInsertionEffect: P, useLayoutEffect: P, useMemo: P, useReducer: P, useRef: P, useState: P, useDebugValue: P, useDeferredValue: P, useTransition: P, useMutableSource: P, useSyncExternalStore: P, useId: P, unstable_isNewReconciler: false }, Oh = { readContext: eh, useCallback: function(a, b) {
        Th().memoizedState = [a, void 0 === b ? null : b];
        return a;
      }, useContext: eh, useEffect: mi, useImperativeHandle: function(a, b, c) {
        c = null !== c && void 0 !== c ? c.concat([a]) : null;
        return ki(
          4194308,
          4,
          pi.bind(null, b, a),
          c
        );
      }, useLayoutEffect: function(a, b) {
        return ki(4194308, 4, a, b);
      }, useInsertionEffect: function(a, b) {
        return ki(4, 2, a, b);
      }, useMemo: function(a, b) {
        var c = Th();
        b = void 0 === b ? null : b;
        a = a();
        c.memoizedState = [a, b];
        return a;
      }, useReducer: function(a, b, c) {
        var d = Th();
        b = void 0 !== c ? c(b) : b;
        d.memoizedState = d.baseState = b;
        a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b };
        d.queue = a;
        a = a.dispatch = xi.bind(null, M, a);
        return [d.memoizedState, a];
      }, useRef: function(a) {
        var b = Th();
        a = { current: a };
        return b.memoizedState = a;
      }, useState: hi, useDebugValue: ri, useDeferredValue: function(a) {
        return Th().memoizedState = a;
      }, useTransition: function() {
        var a = hi(false), b = a[0];
        a = vi.bind(null, a[1]);
        Th().memoizedState = a;
        return [b, a];
      }, useMutableSource: function() {
      }, useSyncExternalStore: function(a, b, c) {
        var d = M, e = Th();
        if (I) {
          if (void 0 === c) throw Error(p(407));
          c = c();
        } else {
          c = b();
          if (null === Q) throw Error(p(349));
          0 !== (Hh & 30) || di(d, b, c);
        }
        e.memoizedState = c;
        var f = { value: c, getSnapshot: b };
        e.queue = f;
        mi(ai.bind(
          null,
          d,
          f,
          a
        ), [a]);
        d.flags |= 2048;
        bi(9, ci.bind(null, d, f, c, b), void 0, null);
        return c;
      }, useId: function() {
        var a = Th(), b = Q.identifierPrefix;
        if (I) {
          var c = sg;
          var d = rg;
          c = (d & ~(1 << 32 - oc(d) - 1)).toString(32) + c;
          b = ":" + b + "R" + c;
          c = Kh++;
          0 < c && (b += "H" + c.toString(32));
          b += ":";
        } else c = Lh++, b = ":" + b + "r" + c.toString(32) + ":";
        return a.memoizedState = b;
      }, unstable_isNewReconciler: false }, Ph = {
        readContext: eh,
        useCallback: si,
        useContext: eh,
        useEffect: $h,
        useImperativeHandle: qi,
        useInsertionEffect: ni,
        useLayoutEffect: oi,
        useMemo: ti,
        useReducer: Wh,
        useRef: ji,
        useState: function() {
          return Wh(Vh);
        },
        useDebugValue: ri,
        useDeferredValue: function(a) {
          var b = Uh();
          return ui(b, N.memoizedState, a);
        },
        useTransition: function() {
          var a = Wh(Vh)[0], b = Uh().memoizedState;
          return [a, b];
        },
        useMutableSource: Yh,
        useSyncExternalStore: Zh,
        useId: wi,
        unstable_isNewReconciler: false
      }, Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
        return Xh(Vh);
      }, useDebugValue: ri, useDeferredValue: function(a) {
        var b = Uh();
        return null === N ? b.memoizedState = a : ui(b, N.memoizedState, a);
      }, useTransition: function() {
        var a = Xh(Vh)[0], b = Uh().memoizedState;
        return [a, b];
      }, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: false };
      function Ci(a, b) {
        if (a && a.defaultProps) {
          b = A({}, b);
          a = a.defaultProps;
          for (var c in a) void 0 === b[c] && (b[c] = a[c]);
          return b;
        }
        return b;
      }
      function Di(a, b, c, d) {
        b = a.memoizedState;
        c = c(d, b);
        c = null === c || void 0 === c ? b : A({}, b, c);
        a.memoizedState = c;
        0 === a.lanes && (a.updateQueue.baseState = c);
      }
      var Ei = { isMounted: function(a) {
        return (a = a._reactInternals) ? Vb(a) === a : false;
      }, enqueueSetState: function(a, b, c) {
        a = a._reactInternals;
        var d = R(), e = yi(a), f = mh(d, e);
        f.payload = b;
        void 0 !== c && null !== c && (f.callback = c);
        b = nh(a, f, e);
        null !== b && (gi(b, a, e, d), oh(b, a, e));
      }, enqueueReplaceState: function(a, b, c) {
        a = a._reactInternals;
        var d = R(), e = yi(a), f = mh(d, e);
        f.tag = 1;
        f.payload = b;
        void 0 !== c && null !== c && (f.callback = c);
        b = nh(a, f, e);
        null !== b && (gi(b, a, e, d), oh(b, a, e));
      }, enqueueForceUpdate: function(a, b) {
        a = a._reactInternals;
        var c = R(), d = yi(a), e = mh(c, d);
        e.tag = 2;
        void 0 !== b && null !== b && (e.callback = b);
        b = nh(a, e, d);
        null !== b && (gi(b, a, d, c), oh(b, a, d));
      } };
      function Fi(a, b, c, d, e, f, g) {
        a = a.stateNode;
        return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Ie(c, d) || !Ie(e, f) : true;
      }
      function Gi(a, b, c) {
        var d = false, e = Vf;
        var f = b.contextType;
        "object" === typeof f && null !== f ? f = eh(f) : (e = Zf(b) ? Xf : H.current, d = b.contextTypes, f = (d = null !== d && void 0 !== d) ? Yf(a, e) : Vf);
        b = new b(c, f);
        a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
        b.updater = Ei;
        a.stateNode = b;
        b._reactInternals = a;
        d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);
        return b;
      }
      function Hi(a, b, c, d) {
        a = b.state;
        "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
        "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
        b.state !== a && Ei.enqueueReplaceState(b, b.state, null);
      }
      function Ii(a, b, c, d) {
        var e = a.stateNode;
        e.props = c;
        e.state = a.memoizedState;
        e.refs = {};
        kh(a);
        var f = b.contextType;
        "object" === typeof f && null !== f ? e.context = eh(f) : (f = Zf(b) ? Xf : H.current, e.context = Yf(a, f));
        e.state = a.memoizedState;
        f = b.getDerivedStateFromProps;
        "function" === typeof f && (Di(a, b, f, c), e.state = a.memoizedState);
        "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && Ei.enqueueReplaceState(e, e.state, null), qh(a, c, e, d), e.state = a.memoizedState);
        "function" === typeof e.componentDidMount && (a.flags |= 4194308);
      }
      function Ji(a, b) {
        try {
          var c = "", d = b;
          do
            c += Pa(d), d = d.return;
          while (d);
          var e = c;
        } catch (f) {
          e = "\nError generating stack: " + f.message + "\n" + f.stack;
        }
        return { value: a, source: b, stack: e, digest: null };
      }
      function Ki(a, b, c) {
        return { value: a, source: null, stack: null != c ? c : null, digest: null != b ? b : null };
      }
      function Li(a, b) {
        try {
          console.error(b.value);
        } catch (c) {
          setTimeout(function() {
            throw c;
          });
        }
      }
      var Mi = "function" === typeof WeakMap ? WeakMap : Map;
      function Ni(a, b, c) {
        c = mh(-1, c);
        c.tag = 3;
        c.payload = { element: null };
        var d = b.value;
        c.callback = function() {
          Oi || (Oi = true, Pi = d);
          Li(a, b);
        };
        return c;
      }
      function Qi(a, b, c) {
        c = mh(-1, c);
        c.tag = 3;
        var d = a.type.getDerivedStateFromError;
        if ("function" === typeof d) {
          var e = b.value;
          c.payload = function() {
            return d(e);
          };
          c.callback = function() {
            Li(a, b);
          };
        }
        var f = a.stateNode;
        null !== f && "function" === typeof f.componentDidCatch && (c.callback = function() {
          Li(a, b);
          "function" !== typeof d && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
          var c2 = b.stack;
          this.componentDidCatch(b.value, { componentStack: null !== c2 ? c2 : "" });
        });
        return c;
      }
      function Si(a, b, c) {
        var d = a.pingCache;
        if (null === d) {
          d = a.pingCache = new Mi();
          var e = /* @__PURE__ */ new Set();
          d.set(b, e);
        } else e = d.get(b), void 0 === e && (e = /* @__PURE__ */ new Set(), d.set(b, e));
        e.has(c) || (e.add(c), a = Ti.bind(null, a, b, c), b.then(a, a));
      }
      function Ui(a) {
        do {
          var b;
          if (b = 13 === a.tag) b = a.memoizedState, b = null !== b ? null !== b.dehydrated ? true : false : true;
          if (b) return a;
          a = a.return;
        } while (null !== a);
        return null;
      }
      function Vi(a, b, c, d, e) {
        if (0 === (a.mode & 1)) return a === b ? a.flags |= 65536 : (a.flags |= 128, c.flags |= 131072, c.flags &= -52805, 1 === c.tag && (null === c.alternate ? c.tag = 17 : (b = mh(-1, 1), b.tag = 2, nh(c, b, 1))), c.lanes |= 1), a;
        a.flags |= 65536;
        a.lanes = e;
        return a;
      }
      var Wi = ua.ReactCurrentOwner, dh = false;
      function Xi(a, b, c, d) {
        b.child = null === a ? Vg(b, null, c, d) : Ug(b, a.child, c, d);
      }
      function Yi(a, b, c, d, e) {
        c = c.render;
        var f = b.ref;
        ch(b, e);
        d = Nh(a, b, c, d, f, e);
        c = Sh();
        if (null !== a && !dh) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e);
        I && c && vg(b);
        b.flags |= 1;
        Xi(a, b, d, e);
        return b.child;
      }
      function $i(a, b, c, d, e) {
        if (null === a) {
          var f = c.type;
          if ("function" === typeof f && !aj(f) && void 0 === f.defaultProps && null === c.compare && void 0 === c.defaultProps) return b.tag = 15, b.type = f, bj(a, b, f, d, e);
          a = Rg(c.type, null, d, b, b.mode, e);
          a.ref = b.ref;
          a.return = b;
          return b.child = a;
        }
        f = a.child;
        if (0 === (a.lanes & e)) {
          var g = f.memoizedProps;
          c = c.compare;
          c = null !== c ? c : Ie;
          if (c(g, d) && a.ref === b.ref) return Zi(a, b, e);
        }
        b.flags |= 1;
        a = Pg(f, d);
        a.ref = b.ref;
        a.return = b;
        return b.child = a;
      }
      function bj(a, b, c, d, e) {
        if (null !== a) {
          var f = a.memoizedProps;
          if (Ie(f, d) && a.ref === b.ref) if (dh = false, b.pendingProps = d = f, 0 !== (a.lanes & e)) 0 !== (a.flags & 131072) && (dh = true);
          else return b.lanes = a.lanes, Zi(a, b, e);
        }
        return cj(a, b, c, d, e);
      }
      function dj(a, b, c) {
        var d = b.pendingProps, e = d.children, f = null !== a ? a.memoizedState : null;
        if ("hidden" === d.mode) if (0 === (b.mode & 1)) b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(ej, fj), fj |= c;
        else {
          if (0 === (c & 1073741824)) return a = null !== f ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b.updateQueue = null, G(ej, fj), fj |= a, null;
          b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
          d = null !== f ? f.baseLanes : c;
          G(ej, fj);
          fj |= d;
        }
        else null !== f ? (d = f.baseLanes | c, b.memoizedState = null) : d = c, G(ej, fj), fj |= d;
        Xi(a, b, e, c);
        return b.child;
      }
      function gj(a, b) {
        var c = b.ref;
        if (null === a && null !== c || null !== a && a.ref !== c) b.flags |= 512, b.flags |= 2097152;
      }
      function cj(a, b, c, d, e) {
        var f = Zf(c) ? Xf : H.current;
        f = Yf(b, f);
        ch(b, e);
        c = Nh(a, b, c, d, f, e);
        d = Sh();
        if (null !== a && !dh) return b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e);
        I && d && vg(b);
        b.flags |= 1;
        Xi(a, b, c, e);
        return b.child;
      }
      function hj(a, b, c, d, e) {
        if (Zf(c)) {
          var f = true;
          cg(b);
        } else f = false;
        ch(b, e);
        if (null === b.stateNode) ij(a, b), Gi(b, c, d), Ii(b, c, d, e), d = true;
        else if (null === a) {
          var g = b.stateNode, h = b.memoizedProps;
          g.props = h;
          var k = g.context, l = c.contextType;
          "object" === typeof l && null !== l ? l = eh(l) : (l = Zf(c) ? Xf : H.current, l = Yf(b, l));
          var m = c.getDerivedStateFromProps, q = "function" === typeof m || "function" === typeof g.getSnapshotBeforeUpdate;
          q || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d || k !== l) && Hi(b, g, d, l);
          jh = false;
          var r = b.memoizedState;
          g.state = r;
          qh(b, d, g, e);
          k = b.memoizedState;
          h !== d || r !== k || Wf.current || jh ? ("function" === typeof m && (Di(b, c, m, d), k = b.memoizedState), (h = jh || Fi(b, c, h, d, r, k, l)) ? (q || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4194308)) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l, d = h) : ("function" === typeof g.componentDidMount && (b.flags |= 4194308), d = false);
        } else {
          g = b.stateNode;
          lh(a, b);
          h = b.memoizedProps;
          l = b.type === b.elementType ? h : Ci(b.type, h);
          g.props = l;
          q = b.pendingProps;
          r = g.context;
          k = c.contextType;
          "object" === typeof k && null !== k ? k = eh(k) : (k = Zf(c) ? Xf : H.current, k = Yf(b, k));
          var y = c.getDerivedStateFromProps;
          (m = "function" === typeof y || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== q || r !== k) && Hi(b, g, d, k);
          jh = false;
          r = b.memoizedState;
          g.state = r;
          qh(b, d, g, e);
          var n = b.memoizedState;
          h !== q || r !== n || Wf.current || jh ? ("function" === typeof y && (Di(b, c, y, d), n = b.memoizedState), (l = jh || Fi(b, c, l, d, r, n, k) || false) ? (m || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d, n, k), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, n, k)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 1024)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), b.memoizedProps = d, b.memoizedState = n), g.props = d, g.state = n, g.context = k, d = l) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), d = false);
        }
        return jj(a, b, c, d, f, e);
      }
      function jj(a, b, c, d, e, f) {
        gj(a, b);
        var g = 0 !== (b.flags & 128);
        if (!d && !g) return e && dg(b, c, false), Zi(a, b, f);
        d = b.stateNode;
        Wi.current = b;
        var h = g && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
        b.flags |= 1;
        null !== a && g ? (b.child = Ug(b, a.child, null, f), b.child = Ug(b, null, h, f)) : Xi(a, b, h, f);
        b.memoizedState = d.state;
        e && dg(b, c, true);
        return b.child;
      }
      function kj(a) {
        var b = a.stateNode;
        b.pendingContext ? ag(a, b.pendingContext, b.pendingContext !== b.context) : b.context && ag(a, b.context, false);
        yh(a, b.containerInfo);
      }
      function lj(a, b, c, d, e) {
        Ig();
        Jg(e);
        b.flags |= 256;
        Xi(a, b, c, d);
        return b.child;
      }
      var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
      function nj(a) {
        return { baseLanes: a, cachePool: null, transitions: null };
      }
      function oj(a, b, c) {
        var d = b.pendingProps, e = L.current, f = false, g = 0 !== (b.flags & 128), h;
        (h = g) || (h = null !== a && null === a.memoizedState ? false : 0 !== (e & 2));
        if (h) f = true, b.flags &= -129;
        else if (null === a || null !== a.memoizedState) e |= 1;
        G(L, e & 1);
        if (null === a) {
          Eg(b);
          a = b.memoizedState;
          if (null !== a && (a = a.dehydrated, null !== a)) return 0 === (b.mode & 1) ? b.lanes = 1 : "$!" === a.data ? b.lanes = 8 : b.lanes = 1073741824, null;
          g = d.children;
          a = d.fallback;
          return f ? (d = b.mode, f = b.child, g = { mode: "hidden", children: g }, 0 === (d & 1) && null !== f ? (f.childLanes = 0, f.pendingProps = g) : f = pj(g, d, 0, null), a = Tg(a, d, c, null), f.return = b, a.return = b, f.sibling = a, b.child = f, b.child.memoizedState = nj(c), b.memoizedState = mj, a) : qj(b, g);
        }
        e = a.memoizedState;
        if (null !== e && (h = e.dehydrated, null !== h)) return rj(a, b, g, d, h, e, c);
        if (f) {
          f = d.fallback;
          g = b.mode;
          e = a.child;
          h = e.sibling;
          var k = { mode: "hidden", children: d.children };
          0 === (g & 1) && b.child !== e ? (d = b.child, d.childLanes = 0, d.pendingProps = k, b.deletions = null) : (d = Pg(e, k), d.subtreeFlags = e.subtreeFlags & 14680064);
          null !== h ? f = Pg(h, f) : (f = Tg(f, g, c, null), f.flags |= 2);
          f.return = b;
          d.return = b;
          d.sibling = f;
          b.child = d;
          d = f;
          f = b.child;
          g = a.child.memoizedState;
          g = null === g ? nj(c) : { baseLanes: g.baseLanes | c, cachePool: null, transitions: g.transitions };
          f.memoizedState = g;
          f.childLanes = a.childLanes & ~c;
          b.memoizedState = mj;
          return d;
        }
        f = a.child;
        a = f.sibling;
        d = Pg(f, { mode: "visible", children: d.children });
        0 === (b.mode & 1) && (d.lanes = c);
        d.return = b;
        d.sibling = null;
        null !== a && (c = b.deletions, null === c ? (b.deletions = [a], b.flags |= 16) : c.push(a));
        b.child = d;
        b.memoizedState = null;
        return d;
      }
      function qj(a, b) {
        b = pj({ mode: "visible", children: b }, a.mode, 0, null);
        b.return = a;
        return a.child = b;
      }
      function sj(a, b, c, d) {
        null !== d && Jg(d);
        Ug(b, a.child, null, c);
        a = qj(b, b.pendingProps.children);
        a.flags |= 2;
        b.memoizedState = null;
        return a;
      }
      function rj(a, b, c, d, e, f, g) {
        if (c) {
          if (b.flags & 256) return b.flags &= -257, d = Ki(Error(p(422))), sj(a, b, g, d);
          if (null !== b.memoizedState) return b.child = a.child, b.flags |= 128, null;
          f = d.fallback;
          e = b.mode;
          d = pj({ mode: "visible", children: d.children }, e, 0, null);
          f = Tg(f, e, g, null);
          f.flags |= 2;
          d.return = b;
          f.return = b;
          d.sibling = f;
          b.child = d;
          0 !== (b.mode & 1) && Ug(b, a.child, null, g);
          b.child.memoizedState = nj(g);
          b.memoizedState = mj;
          return f;
        }
        if (0 === (b.mode & 1)) return sj(a, b, g, null);
        if ("$!" === e.data) {
          d = e.nextSibling && e.nextSibling.dataset;
          if (d) var h = d.dgst;
          d = h;
          f = Error(p(419));
          d = Ki(f, d, void 0);
          return sj(a, b, g, d);
        }
        h = 0 !== (g & a.childLanes);
        if (dh || h) {
          d = Q;
          if (null !== d) {
            switch (g & -g) {
              case 4:
                e = 2;
                break;
              case 16:
                e = 8;
                break;
              case 64:
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
              case 67108864:
                e = 32;
                break;
              case 536870912:
                e = 268435456;
                break;
              default:
                e = 0;
            }
            e = 0 !== (e & (d.suspendedLanes | g)) ? 0 : e;
            0 !== e && e !== f.retryLane && (f.retryLane = e, ih(a, e), gi(d, a, e, -1));
          }
          tj();
          d = Ki(Error(p(421)));
          return sj(a, b, g, d);
        }
        if ("$?" === e.data) return b.flags |= 128, b.child = a.child, b = uj.bind(null, a), e._reactRetry = b, null;
        a = f.treeContext;
        yg = Lf(e.nextSibling);
        xg = b;
        I = true;
        zg = null;
        null !== a && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b);
        b = qj(b, d.children);
        b.flags |= 4096;
        return b;
      }
      function vj(a, b, c) {
        a.lanes |= b;
        var d = a.alternate;
        null !== d && (d.lanes |= b);
        bh(a.return, b, c);
      }
      function wj(a, b, c, d, e) {
        var f = a.memoizedState;
        null === f ? a.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c, tailMode: e } : (f.isBackwards = b, f.rendering = null, f.renderingStartTime = 0, f.last = d, f.tail = c, f.tailMode = e);
      }
      function xj(a, b, c) {
        var d = b.pendingProps, e = d.revealOrder, f = d.tail;
        Xi(a, b, d.children, c);
        d = L.current;
        if (0 !== (d & 2)) d = d & 1 | 2, b.flags |= 128;
        else {
          if (null !== a && 0 !== (a.flags & 128)) a: for (a = b.child; null !== a; ) {
            if (13 === a.tag) null !== a.memoizedState && vj(a, c, b);
            else if (19 === a.tag) vj(a, c, b);
            else if (null !== a.child) {
              a.child.return = a;
              a = a.child;
              continue;
            }
            if (a === b) break a;
            for (; null === a.sibling; ) {
              if (null === a.return || a.return === b) break a;
              a = a.return;
            }
            a.sibling.return = a.return;
            a = a.sibling;
          }
          d &= 1;
        }
        G(L, d);
        if (0 === (b.mode & 1)) b.memoizedState = null;
        else switch (e) {
          case "forwards":
            c = b.child;
            for (e = null; null !== c; ) a = c.alternate, null !== a && null === Ch(a) && (e = c), c = c.sibling;
            c = e;
            null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
            wj(b, false, e, c, f);
            break;
          case "backwards":
            c = null;
            e = b.child;
            for (b.child = null; null !== e; ) {
              a = e.alternate;
              if (null !== a && null === Ch(a)) {
                b.child = e;
                break;
              }
              a = e.sibling;
              e.sibling = c;
              c = e;
              e = a;
            }
            wj(b, true, c, null, f);
            break;
          case "together":
            wj(b, false, null, null, void 0);
            break;
          default:
            b.memoizedState = null;
        }
        return b.child;
      }
      function ij(a, b) {
        0 === (b.mode & 1) && null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
      }
      function Zi(a, b, c) {
        null !== a && (b.dependencies = a.dependencies);
        rh |= b.lanes;
        if (0 === (c & b.childLanes)) return null;
        if (null !== a && b.child !== a.child) throw Error(p(153));
        if (null !== b.child) {
          a = b.child;
          c = Pg(a, a.pendingProps);
          b.child = c;
          for (c.return = b; null !== a.sibling; ) a = a.sibling, c = c.sibling = Pg(a, a.pendingProps), c.return = b;
          c.sibling = null;
        }
        return b.child;
      }
      function yj(a, b, c) {
        switch (b.tag) {
          case 3:
            kj(b);
            Ig();
            break;
          case 5:
            Ah(b);
            break;
          case 1:
            Zf(b.type) && cg(b);
            break;
          case 4:
            yh(b, b.stateNode.containerInfo);
            break;
          case 10:
            var d = b.type._context, e = b.memoizedProps.value;
            G(Wg, d._currentValue);
            d._currentValue = e;
            break;
          case 13:
            d = b.memoizedState;
            if (null !== d) {
              if (null !== d.dehydrated) return G(L, L.current & 1), b.flags |= 128, null;
              if (0 !== (c & b.child.childLanes)) return oj(a, b, c);
              G(L, L.current & 1);
              a = Zi(a, b, c);
              return null !== a ? a.sibling : null;
            }
            G(L, L.current & 1);
            break;
          case 19:
            d = 0 !== (c & b.childLanes);
            if (0 !== (a.flags & 128)) {
              if (d) return xj(a, b, c);
              b.flags |= 128;
            }
            e = b.memoizedState;
            null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
            G(L, L.current);
            if (d) break;
            else return null;
          case 22:
          case 23:
            return b.lanes = 0, dj(a, b, c);
        }
        return Zi(a, b, c);
      }
      var zj, Aj, Bj, Cj;
      zj = function(a, b) {
        for (var c = b.child; null !== c; ) {
          if (5 === c.tag || 6 === c.tag) a.appendChild(c.stateNode);
          else if (4 !== c.tag && null !== c.child) {
            c.child.return = c;
            c = c.child;
            continue;
          }
          if (c === b) break;
          for (; null === c.sibling; ) {
            if (null === c.return || c.return === b) return;
            c = c.return;
          }
          c.sibling.return = c.return;
          c = c.sibling;
        }
      };
      Aj = function() {
      };
      Bj = function(a, b, c, d) {
        var e = a.memoizedProps;
        if (e !== d) {
          a = b.stateNode;
          xh(uh.current);
          var f = null;
          switch (c) {
            case "input":
              e = Ya(a, e);
              d = Ya(a, d);
              f = [];
              break;
            case "select":
              e = A({}, e, { value: void 0 });
              d = A({}, d, { value: void 0 });
              f = [];
              break;
            case "textarea":
              e = gb(a, e);
              d = gb(a, d);
              f = [];
              break;
            default:
              "function" !== typeof e.onClick && "function" === typeof d.onClick && (a.onclick = Bf);
          }
          ub(c, d);
          var g;
          c = null;
          for (l in e) if (!d.hasOwnProperty(l) && e.hasOwnProperty(l) && null != e[l]) if ("style" === l) {
            var h = e[l];
            for (g in h) h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
          } else "dangerouslySetInnerHTML" !== l && "children" !== l && "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && "autoFocus" !== l && (ea.hasOwnProperty(l) ? f || (f = []) : (f = f || []).push(l, null));
          for (l in d) {
            var k = d[l];
            h = null != e ? e[l] : void 0;
            if (d.hasOwnProperty(l) && k !== h && (null != k || null != h)) if ("style" === l) if (h) {
              for (g in h) !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
              for (g in k) k.hasOwnProperty(g) && h[g] !== k[g] && (c || (c = {}), c[g] = k[g]);
            } else c || (f || (f = []), f.push(
              l,
              c
            )), c = k;
            else "dangerouslySetInnerHTML" === l ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, null != k && h !== k && (f = f || []).push(l, k)) : "children" === l ? "string" !== typeof k && "number" !== typeof k || (f = f || []).push(l, "" + k) : "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && (ea.hasOwnProperty(l) ? (null != k && "onScroll" === l && D("scroll", a), f || h === k || (f = [])) : (f = f || []).push(l, k));
          }
          c && (f = f || []).push("style", c);
          var l = f;
          if (b.updateQueue = l) b.flags |= 4;
        }
      };
      Cj = function(a, b, c, d) {
        c !== d && (b.flags |= 4);
      };
      function Dj(a, b) {
        if (!I) switch (a.tailMode) {
          case "hidden":
            b = a.tail;
            for (var c = null; null !== b; ) null !== b.alternate && (c = b), b = b.sibling;
            null === c ? a.tail = null : c.sibling = null;
            break;
          case "collapsed":
            c = a.tail;
            for (var d = null; null !== c; ) null !== c.alternate && (d = c), c = c.sibling;
            null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
        }
      }
      function S(a) {
        var b = null !== a.alternate && a.alternate.child === a.child, c = 0, d = 0;
        if (b) for (var e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d |= e.subtreeFlags & 14680064, d |= e.flags & 14680064, e.return = a, e = e.sibling;
        else for (e = a.child; null !== e; ) c |= e.lanes | e.childLanes, d |= e.subtreeFlags, d |= e.flags, e.return = a, e = e.sibling;
        a.subtreeFlags |= d;
        a.childLanes = c;
        return b;
      }
      function Ej(a, b, c) {
        var d = b.pendingProps;
        wg(b);
        switch (b.tag) {
          case 2:
          case 16:
          case 15:
          case 0:
          case 11:
          case 7:
          case 8:
          case 12:
          case 9:
          case 14:
            return S(b), null;
          case 1:
            return Zf(b.type) && $f(), S(b), null;
          case 3:
            d = b.stateNode;
            zh();
            E(Wf);
            E(H);
            Eh();
            d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
            if (null === a || null === a.child) Gg(b) ? b.flags |= 4 : null === a || a.memoizedState.isDehydrated && 0 === (b.flags & 256) || (b.flags |= 1024, null !== zg && (Fj(zg), zg = null));
            Aj(a, b);
            S(b);
            return null;
          case 5:
            Bh(b);
            var e = xh(wh.current);
            c = b.type;
            if (null !== a && null != b.stateNode) Bj(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);
            else {
              if (!d) {
                if (null === b.stateNode) throw Error(p(166));
                S(b);
                return null;
              }
              a = xh(uh.current);
              if (Gg(b)) {
                d = b.stateNode;
                c = b.type;
                var f = b.memoizedProps;
                d[Of] = b;
                d[Pf] = f;
                a = 0 !== (b.mode & 1);
                switch (c) {
                  case "dialog":
                    D("cancel", d);
                    D("close", d);
                    break;
                  case "iframe":
                  case "object":
                  case "embed":
                    D("load", d);
                    break;
                  case "video":
                  case "audio":
                    for (e = 0; e < lf.length; e++) D(lf[e], d);
                    break;
                  case "source":
                    D("error", d);
                    break;
                  case "img":
                  case "image":
                  case "link":
                    D(
                      "error",
                      d
                    );
                    D("load", d);
                    break;
                  case "details":
                    D("toggle", d);
                    break;
                  case "input":
                    Za(d, f);
                    D("invalid", d);
                    break;
                  case "select":
                    d._wrapperState = { wasMultiple: !!f.multiple };
                    D("invalid", d);
                    break;
                  case "textarea":
                    hb(d, f), D("invalid", d);
                }
                ub(c, f);
                e = null;
                for (var g in f) if (f.hasOwnProperty(g)) {
                  var h = f[g];
                  "children" === g ? "string" === typeof h ? d.textContent !== h && (true !== f.suppressHydrationWarning && Af(d.textContent, h, a), e = ["children", h]) : "number" === typeof h && d.textContent !== "" + h && (true !== f.suppressHydrationWarning && Af(
                    d.textContent,
                    h,
                    a
                  ), e = ["children", "" + h]) : ea.hasOwnProperty(g) && null != h && "onScroll" === g && D("scroll", d);
                }
                switch (c) {
                  case "input":
                    Va(d);
                    db(d, f, true);
                    break;
                  case "textarea":
                    Va(d);
                    jb(d);
                    break;
                  case "select":
                  case "option":
                    break;
                  default:
                    "function" === typeof f.onClick && (d.onclick = Bf);
                }
                d = e;
                b.updateQueue = d;
                null !== d && (b.flags |= 4);
              } else {
                g = 9 === e.nodeType ? e : e.ownerDocument;
                "http://www.w3.org/1999/xhtml" === a && (a = kb(c));
                "http://www.w3.org/1999/xhtml" === a ? "script" === c ? (a = g.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g.createElement(c, { is: d.is }) : (a = g.createElement(c), "select" === c && (g = a, d.multiple ? g.multiple = true : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);
                a[Of] = b;
                a[Pf] = d;
                zj(a, b, false, false);
                b.stateNode = a;
                a: {
                  g = vb(c, d);
                  switch (c) {
                    case "dialog":
                      D("cancel", a);
                      D("close", a);
                      e = d;
                      break;
                    case "iframe":
                    case "object":
                    case "embed":
                      D("load", a);
                      e = d;
                      break;
                    case "video":
                    case "audio":
                      for (e = 0; e < lf.length; e++) D(lf[e], a);
                      e = d;
                      break;
                    case "source":
                      D("error", a);
                      e = d;
                      break;
                    case "img":
                    case "image":
                    case "link":
                      D(
                        "error",
                        a
                      );
                      D("load", a);
                      e = d;
                      break;
                    case "details":
                      D("toggle", a);
                      e = d;
                      break;
                    case "input":
                      Za(a, d);
                      e = Ya(a, d);
                      D("invalid", a);
                      break;
                    case "option":
                      e = d;
                      break;
                    case "select":
                      a._wrapperState = { wasMultiple: !!d.multiple };
                      e = A({}, d, { value: void 0 });
                      D("invalid", a);
                      break;
                    case "textarea":
                      hb(a, d);
                      e = gb(a, d);
                      D("invalid", a);
                      break;
                    default:
                      e = d;
                  }
                  ub(c, e);
                  h = e;
                  for (f in h) if (h.hasOwnProperty(f)) {
                    var k = h[f];
                    "style" === f ? sb(a, k) : "dangerouslySetInnerHTML" === f ? (k = k ? k.__html : void 0, null != k && nb(a, k)) : "children" === f ? "string" === typeof k ? ("textarea" !== c || "" !== k) && ob(a, k) : "number" === typeof k && ob(a, "" + k) : "suppressContentEditableWarning" !== f && "suppressHydrationWarning" !== f && "autoFocus" !== f && (ea.hasOwnProperty(f) ? null != k && "onScroll" === f && D("scroll", a) : null != k && ta(a, f, k, g));
                  }
                  switch (c) {
                    case "input":
                      Va(a);
                      db(a, d, false);
                      break;
                    case "textarea":
                      Va(a);
                      jb(a);
                      break;
                    case "option":
                      null != d.value && a.setAttribute("value", "" + Sa(d.value));
                      break;
                    case "select":
                      a.multiple = !!d.multiple;
                      f = d.value;
                      null != f ? fb(a, !!d.multiple, f, false) : null != d.defaultValue && fb(
                        a,
                        !!d.multiple,
                        d.defaultValue,
                        true
                      );
                      break;
                    default:
                      "function" === typeof e.onClick && (a.onclick = Bf);
                  }
                  switch (c) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      d = !!d.autoFocus;
                      break a;
                    case "img":
                      d = true;
                      break a;
                    default:
                      d = false;
                  }
                }
                d && (b.flags |= 4);
              }
              null !== b.ref && (b.flags |= 512, b.flags |= 2097152);
            }
            S(b);
            return null;
          case 6:
            if (a && null != b.stateNode) Cj(a, b, a.memoizedProps, d);
            else {
              if ("string" !== typeof d && null === b.stateNode) throw Error(p(166));
              c = xh(wh.current);
              xh(uh.current);
              if (Gg(b)) {
                d = b.stateNode;
                c = b.memoizedProps;
                d[Of] = b;
                if (f = d.nodeValue !== c) {
                  if (a = xg, null !== a) switch (a.tag) {
                    case 3:
                      Af(d.nodeValue, c, 0 !== (a.mode & 1));
                      break;
                    case 5:
                      true !== a.memoizedProps.suppressHydrationWarning && Af(d.nodeValue, c, 0 !== (a.mode & 1));
                  }
                }
                f && (b.flags |= 4);
              } else d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[Of] = b, b.stateNode = d;
            }
            S(b);
            return null;
          case 13:
            E(L);
            d = b.memoizedState;
            if (null === a || null !== a.memoizedState && null !== a.memoizedState.dehydrated) {
              if (I && null !== yg && 0 !== (b.mode & 1) && 0 === (b.flags & 128)) Hg(), Ig(), b.flags |= 98560, f = false;
              else if (f = Gg(b), null !== d && null !== d.dehydrated) {
                if (null === a) {
                  if (!f) throw Error(p(318));
                  f = b.memoizedState;
                  f = null !== f ? f.dehydrated : null;
                  if (!f) throw Error(p(317));
                  f[Of] = b;
                } else Ig(), 0 === (b.flags & 128) && (b.memoizedState = null), b.flags |= 4;
                S(b);
                f = false;
              } else null !== zg && (Fj(zg), zg = null), f = true;
              if (!f) return b.flags & 65536 ? b : null;
            }
            if (0 !== (b.flags & 128)) return b.lanes = c, b;
            d = null !== d;
            d !== (null !== a && null !== a.memoizedState) && d && (b.child.flags |= 8192, 0 !== (b.mode & 1) && (null === a || 0 !== (L.current & 1) ? 0 === T && (T = 3) : tj()));
            null !== b.updateQueue && (b.flags |= 4);
            S(b);
            return null;
          case 4:
            return zh(), Aj(a, b), null === a && sf(b.stateNode.containerInfo), S(b), null;
          case 10:
            return ah(b.type._context), S(b), null;
          case 17:
            return Zf(b.type) && $f(), S(b), null;
          case 19:
            E(L);
            f = b.memoizedState;
            if (null === f) return S(b), null;
            d = 0 !== (b.flags & 128);
            g = f.rendering;
            if (null === g) if (d) Dj(f, false);
            else {
              if (0 !== T || null !== a && 0 !== (a.flags & 128)) for (a = b.child; null !== a; ) {
                g = Ch(a);
                if (null !== g) {
                  b.flags |= 128;
                  Dj(f, false);
                  d = g.updateQueue;
                  null !== d && (b.updateQueue = d, b.flags |= 4);
                  b.subtreeFlags = 0;
                  d = c;
                  for (c = b.child; null !== c; ) f = c, a = d, f.flags &= 14680066, g = f.alternate, null === g ? (f.childLanes = 0, f.lanes = a, f.child = null, f.subtreeFlags = 0, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.subtreeFlags = 0, f.deletions = null, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a = g.dependencies, f.dependencies = null === a ? null : { lanes: a.lanes, firstContext: a.firstContext }), c = c.sibling;
                  G(L, L.current & 1 | 2);
                  return b.child;
                }
                a = a.sibling;
              }
              null !== f.tail && B() > Gj && (b.flags |= 128, d = true, Dj(f, false), b.lanes = 4194304);
            }
            else {
              if (!d) if (a = Ch(g), null !== a) {
                if (b.flags |= 128, d = true, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Dj(f, true), null === f.tail && "hidden" === f.tailMode && !g.alternate && !I) return S(b), null;
              } else 2 * B() - f.renderingStartTime > Gj && 1073741824 !== c && (b.flags |= 128, d = true, Dj(f, false), b.lanes = 4194304);
              f.isBackwards ? (g.sibling = b.child, b.child = g) : (c = f.last, null !== c ? c.sibling = g : b.child = g, f.last = g);
            }
            if (null !== f.tail) return b = f.tail, f.rendering = b, f.tail = b.sibling, f.renderingStartTime = B(), b.sibling = null, c = L.current, G(L, d ? c & 1 | 2 : c & 1), b;
            S(b);
            return null;
          case 22:
          case 23:
            return Hj(), d = null !== b.memoizedState, null !== a && null !== a.memoizedState !== d && (b.flags |= 8192), d && 0 !== (b.mode & 1) ? 0 !== (fj & 1073741824) && (S(b), b.subtreeFlags & 6 && (b.flags |= 8192)) : S(b), null;
          case 24:
            return null;
          case 25:
            return null;
        }
        throw Error(p(156, b.tag));
      }
      function Ij(a, b) {
        wg(b);
        switch (b.tag) {
          case 1:
            return Zf(b.type) && $f(), a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
          case 3:
            return zh(), E(Wf), E(H), Eh(), a = b.flags, 0 !== (a & 65536) && 0 === (a & 128) ? (b.flags = a & -65537 | 128, b) : null;
          case 5:
            return Bh(b), null;
          case 13:
            E(L);
            a = b.memoizedState;
            if (null !== a && null !== a.dehydrated) {
              if (null === b.alternate) throw Error(p(340));
              Ig();
            }
            a = b.flags;
            return a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
          case 19:
            return E(L), null;
          case 4:
            return zh(), null;
          case 10:
            return ah(b.type._context), null;
          case 22:
          case 23:
            return Hj(), null;
          case 24:
            return null;
          default:
            return null;
        }
      }
      var Jj = false, U = false, Kj = "function" === typeof WeakSet ? WeakSet : Set, V = null;
      function Lj(a, b) {
        var c = a.ref;
        if (null !== c) if ("function" === typeof c) try {
          c(null);
        } catch (d) {
          W(a, b, d);
        }
        else c.current = null;
      }
      function Mj(a, b, c) {
        try {
          c();
        } catch (d) {
          W(a, b, d);
        }
      }
      var Nj = false;
      function Oj(a, b) {
        Cf = dd;
        a = Me();
        if (Ne(a)) {
          if ("selectionStart" in a) var c = { start: a.selectionStart, end: a.selectionEnd };
          else a: {
            c = (c = a.ownerDocument) && c.defaultView || window;
            var d = c.getSelection && c.getSelection();
            if (d && 0 !== d.rangeCount) {
              c = d.anchorNode;
              var e = d.anchorOffset, f = d.focusNode;
              d = d.focusOffset;
              try {
                c.nodeType, f.nodeType;
              } catch (F) {
                c = null;
                break a;
              }
              var g = 0, h = -1, k = -1, l = 0, m = 0, q = a, r = null;
              b: for (; ; ) {
                for (var y; ; ) {
                  q !== c || 0 !== e && 3 !== q.nodeType || (h = g + e);
                  q !== f || 0 !== d && 3 !== q.nodeType || (k = g + d);
                  3 === q.nodeType && (g += q.nodeValue.length);
                  if (null === (y = q.firstChild)) break;
                  r = q;
                  q = y;
                }
                for (; ; ) {
                  if (q === a) break b;
                  r === c && ++l === e && (h = g);
                  r === f && ++m === d && (k = g);
                  if (null !== (y = q.nextSibling)) break;
                  q = r;
                  r = q.parentNode;
                }
                q = y;
              }
              c = -1 === h || -1 === k ? null : { start: h, end: k };
            } else c = null;
          }
          c = c || { start: 0, end: 0 };
        } else c = null;
        Df = { focusedElem: a, selectionRange: c };
        dd = false;
        for (V = b; null !== V; ) if (b = V, a = b.child, 0 !== (b.subtreeFlags & 1028) && null !== a) a.return = b, V = a;
        else for (; null !== V; ) {
          b = V;
          try {
            var n = b.alternate;
            if (0 !== (b.flags & 1024)) switch (b.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (null !== n) {
                  var t = n.memoizedProps, J = n.memoizedState, x = b.stateNode, w = x.getSnapshotBeforeUpdate(b.elementType === b.type ? t : Ci(b.type, t), J);
                  x.__reactInternalSnapshotBeforeUpdate = w;
                }
                break;
              case 3:
                var u = b.stateNode.containerInfo;
                1 === u.nodeType ? u.textContent = "" : 9 === u.nodeType && u.documentElement && u.removeChild(u.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p(163));
            }
          } catch (F) {
            W(b, b.return, F);
          }
          a = b.sibling;
          if (null !== a) {
            a.return = b.return;
            V = a;
            break;
          }
          V = b.return;
        }
        n = Nj;
        Nj = false;
        return n;
      }
      function Pj(a, b, c) {
        var d = b.updateQueue;
        d = null !== d ? d.lastEffect : null;
        if (null !== d) {
          var e = d = d.next;
          do {
            if ((e.tag & a) === a) {
              var f = e.destroy;
              e.destroy = void 0;
              void 0 !== f && Mj(b, c, f);
            }
            e = e.next;
          } while (e !== d);
        }
      }
      function Qj(a, b) {
        b = b.updateQueue;
        b = null !== b ? b.lastEffect : null;
        if (null !== b) {
          var c = b = b.next;
          do {
            if ((c.tag & a) === a) {
              var d = c.create;
              c.destroy = d();
            }
            c = c.next;
          } while (c !== b);
        }
      }
      function Rj(a) {
        var b = a.ref;
        if (null !== b) {
          var c = a.stateNode;
          switch (a.tag) {
            case 5:
              a = c;
              break;
            default:
              a = c;
          }
          "function" === typeof b ? b(a) : b.current = a;
        }
      }
      function Sj(a) {
        var b = a.alternate;
        null !== b && (a.alternate = null, Sj(b));
        a.child = null;
        a.deletions = null;
        a.sibling = null;
        5 === a.tag && (b = a.stateNode, null !== b && (delete b[Of], delete b[Pf], delete b[of], delete b[Qf], delete b[Rf]));
        a.stateNode = null;
        a.return = null;
        a.dependencies = null;
        a.memoizedProps = null;
        a.memoizedState = null;
        a.pendingProps = null;
        a.stateNode = null;
        a.updateQueue = null;
      }
      function Tj(a) {
        return 5 === a.tag || 3 === a.tag || 4 === a.tag;
      }
      function Uj(a) {
        a: for (; ; ) {
          for (; null === a.sibling; ) {
            if (null === a.return || Tj(a.return)) return null;
            a = a.return;
          }
          a.sibling.return = a.return;
          for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
            if (a.flags & 2) continue a;
            if (null === a.child || 4 === a.tag) continue a;
            else a.child.return = a, a = a.child;
          }
          if (!(a.flags & 2)) return a.stateNode;
        }
      }
      function Vj(a, b, c) {
        var d = a.tag;
        if (5 === d || 6 === d) a = a.stateNode, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = Bf));
        else if (4 !== d && (a = a.child, null !== a)) for (Vj(a, b, c), a = a.sibling; null !== a; ) Vj(a, b, c), a = a.sibling;
      }
      function Wj(a, b, c) {
        var d = a.tag;
        if (5 === d || 6 === d) a = a.stateNode, b ? c.insertBefore(a, b) : c.appendChild(a);
        else if (4 !== d && (a = a.child, null !== a)) for (Wj(a, b, c), a = a.sibling; null !== a; ) Wj(a, b, c), a = a.sibling;
      }
      var X = null, Xj = false;
      function Yj(a, b, c) {
        for (c = c.child; null !== c; ) Zj(a, b, c), c = c.sibling;
      }
      function Zj(a, b, c) {
        if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
          lc.onCommitFiberUnmount(kc, c);
        } catch (h) {
        }
        switch (c.tag) {
          case 5:
            U || Lj(c, b);
          case 6:
            var d = X, e = Xj;
            X = null;
            Yj(a, b, c);
            X = d;
            Xj = e;
            null !== X && (Xj ? (a = X, c = c.stateNode, 8 === a.nodeType ? a.parentNode.removeChild(c) : a.removeChild(c)) : X.removeChild(c.stateNode));
            break;
          case 18:
            null !== X && (Xj ? (a = X, c = c.stateNode, 8 === a.nodeType ? Kf(a.parentNode, c) : 1 === a.nodeType && Kf(a, c), bd(a)) : Kf(X, c.stateNode));
            break;
          case 4:
            d = X;
            e = Xj;
            X = c.stateNode.containerInfo;
            Xj = true;
            Yj(a, b, c);
            X = d;
            Xj = e;
            break;
          case 0:
          case 11:
          case 14:
          case 15:
            if (!U && (d = c.updateQueue, null !== d && (d = d.lastEffect, null !== d))) {
              e = d = d.next;
              do {
                var f = e, g = f.destroy;
                f = f.tag;
                void 0 !== g && (0 !== (f & 2) ? Mj(c, b, g) : 0 !== (f & 4) && Mj(c, b, g));
                e = e.next;
              } while (e !== d);
            }
            Yj(a, b, c);
            break;
          case 1:
            if (!U && (Lj(c, b), d = c.stateNode, "function" === typeof d.componentWillUnmount)) try {
              d.props = c.memoizedProps, d.state = c.memoizedState, d.componentWillUnmount();
            } catch (h) {
              W(c, b, h);
            }
            Yj(a, b, c);
            break;
          case 21:
            Yj(a, b, c);
            break;
          case 22:
            c.mode & 1 ? (U = (d = U) || null !== c.memoizedState, Yj(a, b, c), U = d) : Yj(a, b, c);
            break;
          default:
            Yj(a, b, c);
        }
      }
      function ak(a) {
        var b = a.updateQueue;
        if (null !== b) {
          a.updateQueue = null;
          var c = a.stateNode;
          null === c && (c = a.stateNode = new Kj());
          b.forEach(function(b2) {
            var d = bk.bind(null, a, b2);
            c.has(b2) || (c.add(b2), b2.then(d, d));
          });
        }
      }
      function ck(a, b) {
        var c = b.deletions;
        if (null !== c) for (var d = 0; d < c.length; d++) {
          var e = c[d];
          try {
            var f = a, g = b, h = g;
            a: for (; null !== h; ) {
              switch (h.tag) {
                case 5:
                  X = h.stateNode;
                  Xj = false;
                  break a;
                case 3:
                  X = h.stateNode.containerInfo;
                  Xj = true;
                  break a;
                case 4:
                  X = h.stateNode.containerInfo;
                  Xj = true;
                  break a;
              }
              h = h.return;
            }
            if (null === X) throw Error(p(160));
            Zj(f, g, e);
            X = null;
            Xj = false;
            var k = e.alternate;
            null !== k && (k.return = null);
            e.return = null;
          } catch (l) {
            W(e, b, l);
          }
        }
        if (b.subtreeFlags & 12854) for (b = b.child; null !== b; ) dk(b, a), b = b.sibling;
      }
      function dk(a, b) {
        var c = a.alternate, d = a.flags;
        switch (a.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            ck(b, a);
            ek(a);
            if (d & 4) {
              try {
                Pj(3, a, a.return), Qj(3, a);
              } catch (t) {
                W(a, a.return, t);
              }
              try {
                Pj(5, a, a.return);
              } catch (t) {
                W(a, a.return, t);
              }
            }
            break;
          case 1:
            ck(b, a);
            ek(a);
            d & 512 && null !== c && Lj(c, c.return);
            break;
          case 5:
            ck(b, a);
            ek(a);
            d & 512 && null !== c && Lj(c, c.return);
            if (a.flags & 32) {
              var e = a.stateNode;
              try {
                ob(e, "");
              } catch (t) {
                W(a, a.return, t);
              }
            }
            if (d & 4 && (e = a.stateNode, null != e)) {
              var f = a.memoizedProps, g = null !== c ? c.memoizedProps : f, h = a.type, k = a.updateQueue;
              a.updateQueue = null;
              if (null !== k) try {
                "input" === h && "radio" === f.type && null != f.name && ab(e, f);
                vb(h, g);
                var l = vb(h, f);
                for (g = 0; g < k.length; g += 2) {
                  var m = k[g], q = k[g + 1];
                  "style" === m ? sb(e, q) : "dangerouslySetInnerHTML" === m ? nb(e, q) : "children" === m ? ob(e, q) : ta(e, m, q, l);
                }
                switch (h) {
                  case "input":
                    bb(e, f);
                    break;
                  case "textarea":
                    ib(e, f);
                    break;
                  case "select":
                    var r = e._wrapperState.wasMultiple;
                    e._wrapperState.wasMultiple = !!f.multiple;
                    var y = f.value;
                    null != y ? fb(e, !!f.multiple, y, false) : r !== !!f.multiple && (null != f.defaultValue ? fb(
                      e,
                      !!f.multiple,
                      f.defaultValue,
                      true
                    ) : fb(e, !!f.multiple, f.multiple ? [] : "", false));
                }
                e[Pf] = f;
              } catch (t) {
                W(a, a.return, t);
              }
            }
            break;
          case 6:
            ck(b, a);
            ek(a);
            if (d & 4) {
              if (null === a.stateNode) throw Error(p(162));
              e = a.stateNode;
              f = a.memoizedProps;
              try {
                e.nodeValue = f;
              } catch (t) {
                W(a, a.return, t);
              }
            }
            break;
          case 3:
            ck(b, a);
            ek(a);
            if (d & 4 && null !== c && c.memoizedState.isDehydrated) try {
              bd(b.containerInfo);
            } catch (t) {
              W(a, a.return, t);
            }
            break;
          case 4:
            ck(b, a);
            ek(a);
            break;
          case 13:
            ck(b, a);
            ek(a);
            e = a.child;
            e.flags & 8192 && (f = null !== e.memoizedState, e.stateNode.isHidden = f, !f || null !== e.alternate && null !== e.alternate.memoizedState || (fk = B()));
            d & 4 && ak(a);
            break;
          case 22:
            m = null !== c && null !== c.memoizedState;
            a.mode & 1 ? (U = (l = U) || m, ck(b, a), U = l) : ck(b, a);
            ek(a);
            if (d & 8192) {
              l = null !== a.memoizedState;
              if ((a.stateNode.isHidden = l) && !m && 0 !== (a.mode & 1)) for (V = a, m = a.child; null !== m; ) {
                for (q = V = m; null !== V; ) {
                  r = V;
                  y = r.child;
                  switch (r.tag) {
                    case 0:
                    case 11:
                    case 14:
                    case 15:
                      Pj(4, r, r.return);
                      break;
                    case 1:
                      Lj(r, r.return);
                      var n = r.stateNode;
                      if ("function" === typeof n.componentWillUnmount) {
                        d = r;
                        c = r.return;
                        try {
                          b = d, n.props = b.memoizedProps, n.state = b.memoizedState, n.componentWillUnmount();
                        } catch (t) {
                          W(d, c, t);
                        }
                      }
                      break;
                    case 5:
                      Lj(r, r.return);
                      break;
                    case 22:
                      if (null !== r.memoizedState) {
                        gk(q);
                        continue;
                      }
                  }
                  null !== y ? (y.return = r, V = y) : gk(q);
                }
                m = m.sibling;
              }
              a: for (m = null, q = a; ; ) {
                if (5 === q.tag) {
                  if (null === m) {
                    m = q;
                    try {
                      e = q.stateNode, l ? (f = e.style, "function" === typeof f.setProperty ? f.setProperty("display", "none", "important") : f.display = "none") : (h = q.stateNode, k = q.memoizedProps.style, g = void 0 !== k && null !== k && k.hasOwnProperty("display") ? k.display : null, h.style.display = rb("display", g));
                    } catch (t) {
                      W(a, a.return, t);
                    }
                  }
                } else if (6 === q.tag) {
                  if (null === m) try {
                    q.stateNode.nodeValue = l ? "" : q.memoizedProps;
                  } catch (t) {
                    W(a, a.return, t);
                  }
                } else if ((22 !== q.tag && 23 !== q.tag || null === q.memoizedState || q === a) && null !== q.child) {
                  q.child.return = q;
                  q = q.child;
                  continue;
                }
                if (q === a) break a;
                for (; null === q.sibling; ) {
                  if (null === q.return || q.return === a) break a;
                  m === q && (m = null);
                  q = q.return;
                }
                m === q && (m = null);
                q.sibling.return = q.return;
                q = q.sibling;
              }
            }
            break;
          case 19:
            ck(b, a);
            ek(a);
            d & 4 && ak(a);
            break;
          case 21:
            break;
          default:
            ck(
              b,
              a
            ), ek(a);
        }
      }
      function ek(a) {
        var b = a.flags;
        if (b & 2) {
          try {
            a: {
              for (var c = a.return; null !== c; ) {
                if (Tj(c)) {
                  var d = c;
                  break a;
                }
                c = c.return;
              }
              throw Error(p(160));
            }
            switch (d.tag) {
              case 5:
                var e = d.stateNode;
                d.flags & 32 && (ob(e, ""), d.flags &= -33);
                var f = Uj(a);
                Wj(a, f, e);
                break;
              case 3:
              case 4:
                var g = d.stateNode.containerInfo, h = Uj(a);
                Vj(a, h, g);
                break;
              default:
                throw Error(p(161));
            }
          } catch (k) {
            W(a, a.return, k);
          }
          a.flags &= -3;
        }
        b & 4096 && (a.flags &= -4097);
      }
      function hk(a, b, c) {
        V = a;
        ik(a);
      }
      function ik(a, b, c) {
        for (var d = 0 !== (a.mode & 1); null !== V; ) {
          var e = V, f = e.child;
          if (22 === e.tag && d) {
            var g = null !== e.memoizedState || Jj;
            if (!g) {
              var h = e.alternate, k = null !== h && null !== h.memoizedState || U;
              h = Jj;
              var l = U;
              Jj = g;
              if ((U = k) && !l) for (V = e; null !== V; ) g = V, k = g.child, 22 === g.tag && null !== g.memoizedState ? jk(e) : null !== k ? (k.return = g, V = k) : jk(e);
              for (; null !== f; ) V = f, ik(f), f = f.sibling;
              V = e;
              Jj = h;
              U = l;
            }
            kk(a);
          } else 0 !== (e.subtreeFlags & 8772) && null !== f ? (f.return = e, V = f) : kk(a);
        }
      }
      function kk(a) {
        for (; null !== V; ) {
          var b = V;
          if (0 !== (b.flags & 8772)) {
            var c = b.alternate;
            try {
              if (0 !== (b.flags & 8772)) switch (b.tag) {
                case 0:
                case 11:
                case 15:
                  U || Qj(5, b);
                  break;
                case 1:
                  var d = b.stateNode;
                  if (b.flags & 4 && !U) if (null === c) d.componentDidMount();
                  else {
                    var e = b.elementType === b.type ? c.memoizedProps : Ci(b.type, c.memoizedProps);
                    d.componentDidUpdate(e, c.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
                  }
                  var f = b.updateQueue;
                  null !== f && sh(b, f, d);
                  break;
                case 3:
                  var g = b.updateQueue;
                  if (null !== g) {
                    c = null;
                    if (null !== b.child) switch (b.child.tag) {
                      case 5:
                        c = b.child.stateNode;
                        break;
                      case 1:
                        c = b.child.stateNode;
                    }
                    sh(b, g, c);
                  }
                  break;
                case 5:
                  var h = b.stateNode;
                  if (null === c && b.flags & 4) {
                    c = h;
                    var k = b.memoizedProps;
                    switch (b.type) {
                      case "button":
                      case "input":
                      case "select":
                      case "textarea":
                        k.autoFocus && c.focus();
                        break;
                      case "img":
                        k.src && (c.src = k.src);
                    }
                  }
                  break;
                case 6:
                  break;
                case 4:
                  break;
                case 12:
                  break;
                case 13:
                  if (null === b.memoizedState) {
                    var l = b.alternate;
                    if (null !== l) {
                      var m = l.memoizedState;
                      if (null !== m) {
                        var q = m.dehydrated;
                        null !== q && bd(q);
                      }
                    }
                  }
                  break;
                case 19:
                case 17:
                case 21:
                case 22:
                case 23:
                case 25:
                  break;
                default:
                  throw Error(p(163));
              }
              U || b.flags & 512 && Rj(b);
            } catch (r) {
              W(b, b.return, r);
            }
          }
          if (b === a) {
            V = null;
            break;
          }
          c = b.sibling;
          if (null !== c) {
            c.return = b.return;
            V = c;
            break;
          }
          V = b.return;
        }
      }
      function gk(a) {
        for (; null !== V; ) {
          var b = V;
          if (b === a) {
            V = null;
            break;
          }
          var c = b.sibling;
          if (null !== c) {
            c.return = b.return;
            V = c;
            break;
          }
          V = b.return;
        }
      }
      function jk(a) {
        for (; null !== V; ) {
          var b = V;
          try {
            switch (b.tag) {
              case 0:
              case 11:
              case 15:
                var c = b.return;
                try {
                  Qj(4, b);
                } catch (k) {
                  W(b, c, k);
                }
                break;
              case 1:
                var d = b.stateNode;
                if ("function" === typeof d.componentDidMount) {
                  var e = b.return;
                  try {
                    d.componentDidMount();
                  } catch (k) {
                    W(b, e, k);
                  }
                }
                var f = b.return;
                try {
                  Rj(b);
                } catch (k) {
                  W(b, f, k);
                }
                break;
              case 5:
                var g = b.return;
                try {
                  Rj(b);
                } catch (k) {
                  W(b, g, k);
                }
            }
          } catch (k) {
            W(b, b.return, k);
          }
          if (b === a) {
            V = null;
            break;
          }
          var h = b.sibling;
          if (null !== h) {
            h.return = b.return;
            V = h;
            break;
          }
          V = b.return;
        }
      }
      var lk = Math.ceil, mk = ua.ReactCurrentDispatcher, nk = ua.ReactCurrentOwner, ok = ua.ReactCurrentBatchConfig, K = 0, Q = null, Y = null, Z = 0, fj = 0, ej = Uf(0), T = 0, pk = null, rh = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = Infinity, uk = null, Oi = false, Pi = null, Ri = null, vk = false, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
      function R() {
        return 0 !== (K & 6) ? B() : -1 !== Ak ? Ak : Ak = B();
      }
      function yi(a) {
        if (0 === (a.mode & 1)) return 1;
        if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
        if (null !== Kg.transition) return 0 === Bk && (Bk = yc()), Bk;
        a = C;
        if (0 !== a) return a;
        a = window.event;
        a = void 0 === a ? 16 : jd(a.type);
        return a;
      }
      function gi(a, b, c, d) {
        if (50 < yk) throw yk = 0, zk = null, Error(p(185));
        Ac(a, c, d);
        if (0 === (K & 2) || a !== Q) a === Q && (0 === (K & 2) && (qk |= c), 4 === T && Ck(a, Z)), Dk(a, d), 1 === c && 0 === K && 0 === (b.mode & 1) && (Gj = B() + 500, fg && jg());
      }
      function Dk(a, b) {
        var c = a.callbackNode;
        wc(a, b);
        var d = uc(a, a === Q ? Z : 0);
        if (0 === d) null !== c && bc(c), a.callbackNode = null, a.callbackPriority = 0;
        else if (b = d & -d, a.callbackPriority !== b) {
          null != c && bc(c);
          if (1 === b) 0 === a.tag ? ig(Ek.bind(null, a)) : hg(Ek.bind(null, a)), Jf(function() {
            0 === (K & 6) && jg();
          }), c = null;
          else {
            switch (Dc(d)) {
              case 1:
                c = fc;
                break;
              case 4:
                c = gc;
                break;
              case 16:
                c = hc;
                break;
              case 536870912:
                c = jc;
                break;
              default:
                c = hc;
            }
            c = Fk(c, Gk.bind(null, a));
          }
          a.callbackPriority = b;
          a.callbackNode = c;
        }
      }
      function Gk(a, b) {
        Ak = -1;
        Bk = 0;
        if (0 !== (K & 6)) throw Error(p(327));
        var c = a.callbackNode;
        if (Hk() && a.callbackNode !== c) return null;
        var d = uc(a, a === Q ? Z : 0);
        if (0 === d) return null;
        if (0 !== (d & 30) || 0 !== (d & a.expiredLanes) || b) b = Ik(a, d);
        else {
          b = d;
          var e = K;
          K |= 2;
          var f = Jk();
          if (Q !== a || Z !== b) uk = null, Gj = B() + 500, Kk(a, b);
          do
            try {
              Lk();
              break;
            } catch (h) {
              Mk(a, h);
            }
          while (1);
          $g();
          mk.current = f;
          K = e;
          null !== Y ? b = 0 : (Q = null, Z = 0, b = T);
        }
        if (0 !== b) {
          2 === b && (e = xc(a), 0 !== e && (d = e, b = Nk(a, e)));
          if (1 === b) throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
          if (6 === b) Ck(a, d);
          else {
            e = a.current.alternate;
            if (0 === (d & 30) && !Ok(e) && (b = Ik(a, d), 2 === b && (f = xc(a), 0 !== f && (d = f, b = Nk(a, f))), 1 === b)) throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B()), c;
            a.finishedWork = e;
            a.finishedLanes = d;
            switch (b) {
              case 0:
              case 1:
                throw Error(p(345));
              case 2:
                Pk(a, tk, uk);
                break;
              case 3:
                Ck(a, d);
                if ((d & 130023424) === d && (b = fk + 500 - B(), 10 < b)) {
                  if (0 !== uc(a, 0)) break;
                  e = a.suspendedLanes;
                  if ((e & d) !== d) {
                    R();
                    a.pingedLanes |= a.suspendedLanes & e;
                    break;
                  }
                  a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), b);
                  break;
                }
                Pk(a, tk, uk);
                break;
              case 4:
                Ck(a, d);
                if ((d & 4194240) === d) break;
                b = a.eventTimes;
                for (e = -1; 0 < d; ) {
                  var g = 31 - oc(d);
                  f = 1 << g;
                  g = b[g];
                  g > e && (e = g);
                  d &= ~f;
                }
                d = e;
                d = B() - d;
                d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3e3 > d ? 3e3 : 4320 > d ? 4320 : 1960 * lk(d / 1960)) - d;
                if (10 < d) {
                  a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), d);
                  break;
                }
                Pk(a, tk, uk);
                break;
              case 5:
                Pk(a, tk, uk);
                break;
              default:
                throw Error(p(329));
            }
          }
        }
        Dk(a, B());
        return a.callbackNode === c ? Gk.bind(null, a) : null;
      }
      function Nk(a, b) {
        var c = sk;
        a.current.memoizedState.isDehydrated && (Kk(a, b).flags |= 256);
        a = Ik(a, b);
        2 !== a && (b = tk, tk = c, null !== b && Fj(b));
        return a;
      }
      function Fj(a) {
        null === tk ? tk = a : tk.push.apply(tk, a);
      }
      function Ok(a) {
        for (var b = a; ; ) {
          if (b.flags & 16384) {
            var c = b.updateQueue;
            if (null !== c && (c = c.stores, null !== c)) for (var d = 0; d < c.length; d++) {
              var e = c[d], f = e.getSnapshot;
              e = e.value;
              try {
                if (!He(f(), e)) return false;
              } catch (g) {
                return false;
              }
            }
          }
          c = b.child;
          if (b.subtreeFlags & 16384 && null !== c) c.return = b, b = c;
          else {
            if (b === a) break;
            for (; null === b.sibling; ) {
              if (null === b.return || b.return === a) return true;
              b = b.return;
            }
            b.sibling.return = b.return;
            b = b.sibling;
          }
        }
        return true;
      }
      function Ck(a, b) {
        b &= ~rk;
        b &= ~qk;
        a.suspendedLanes |= b;
        a.pingedLanes &= ~b;
        for (a = a.expirationTimes; 0 < b; ) {
          var c = 31 - oc(b), d = 1 << c;
          a[c] = -1;
          b &= ~d;
        }
      }
      function Ek(a) {
        if (0 !== (K & 6)) throw Error(p(327));
        Hk();
        var b = uc(a, 0);
        if (0 === (b & 1)) return Dk(a, B()), null;
        var c = Ik(a, b);
        if (0 !== a.tag && 2 === c) {
          var d = xc(a);
          0 !== d && (b = d, c = Nk(a, d));
        }
        if (1 === c) throw c = pk, Kk(a, 0), Ck(a, b), Dk(a, B()), c;
        if (6 === c) throw Error(p(345));
        a.finishedWork = a.current.alternate;
        a.finishedLanes = b;
        Pk(a, tk, uk);
        Dk(a, B());
        return null;
      }
      function Qk(a, b) {
        var c = K;
        K |= 1;
        try {
          return a(b);
        } finally {
          K = c, 0 === K && (Gj = B() + 500, fg && jg());
        }
      }
      function Rk(a) {
        null !== wk && 0 === wk.tag && 0 === (K & 6) && Hk();
        var b = K;
        K |= 1;
        var c = ok.transition, d = C;
        try {
          if (ok.transition = null, C = 1, a) return a();
        } finally {
          C = d, ok.transition = c, K = b, 0 === (K & 6) && jg();
        }
      }
      function Hj() {
        fj = ej.current;
        E(ej);
      }
      function Kk(a, b) {
        a.finishedWork = null;
        a.finishedLanes = 0;
        var c = a.timeoutHandle;
        -1 !== c && (a.timeoutHandle = -1, Gf(c));
        if (null !== Y) for (c = Y.return; null !== c; ) {
          var d = c;
          wg(d);
          switch (d.tag) {
            case 1:
              d = d.type.childContextTypes;
              null !== d && void 0 !== d && $f();
              break;
            case 3:
              zh();
              E(Wf);
              E(H);
              Eh();
              break;
            case 5:
              Bh(d);
              break;
            case 4:
              zh();
              break;
            case 13:
              E(L);
              break;
            case 19:
              E(L);
              break;
            case 10:
              ah(d.type._context);
              break;
            case 22:
            case 23:
              Hj();
          }
          c = c.return;
        }
        Q = a;
        Y = a = Pg(a.current, null);
        Z = fj = b;
        T = 0;
        pk = null;
        rk = qk = rh = 0;
        tk = sk = null;
        if (null !== fh) {
          for (b = 0; b < fh.length; b++) if (c = fh[b], d = c.interleaved, null !== d) {
            c.interleaved = null;
            var e = d.next, f = c.pending;
            if (null !== f) {
              var g = f.next;
              f.next = e;
              d.next = g;
            }
            c.pending = d;
          }
          fh = null;
        }
        return a;
      }
      function Mk(a, b) {
        do {
          var c = Y;
          try {
            $g();
            Fh.current = Rh;
            if (Ih) {
              for (var d = M.memoizedState; null !== d; ) {
                var e = d.queue;
                null !== e && (e.pending = null);
                d = d.next;
              }
              Ih = false;
            }
            Hh = 0;
            O = N = M = null;
            Jh = false;
            Kh = 0;
            nk.current = null;
            if (null === c || null === c.return) {
              T = 1;
              pk = b;
              Y = null;
              break;
            }
            a: {
              var f = a, g = c.return, h = c, k = b;
              b = Z;
              h.flags |= 32768;
              if (null !== k && "object" === typeof k && "function" === typeof k.then) {
                var l = k, m = h, q = m.tag;
                if (0 === (m.mode & 1) && (0 === q || 11 === q || 15 === q)) {
                  var r = m.alternate;
                  r ? (m.updateQueue = r.updateQueue, m.memoizedState = r.memoizedState, m.lanes = r.lanes) : (m.updateQueue = null, m.memoizedState = null);
                }
                var y = Ui(g);
                if (null !== y) {
                  y.flags &= -257;
                  Vi(y, g, h, f, b);
                  y.mode & 1 && Si(f, l, b);
                  b = y;
                  k = l;
                  var n = b.updateQueue;
                  if (null === n) {
                    var t = /* @__PURE__ */ new Set();
                    t.add(k);
                    b.updateQueue = t;
                  } else n.add(k);
                  break a;
                } else {
                  if (0 === (b & 1)) {
                    Si(f, l, b);
                    tj();
                    break a;
                  }
                  k = Error(p(426));
                }
              } else if (I && h.mode & 1) {
                var J = Ui(g);
                if (null !== J) {
                  0 === (J.flags & 65536) && (J.flags |= 256);
                  Vi(J, g, h, f, b);
                  Jg(Ji(k, h));
                  break a;
                }
              }
              f = k = Ji(k, h);
              4 !== T && (T = 2);
              null === sk ? sk = [f] : sk.push(f);
              f = g;
              do {
                switch (f.tag) {
                  case 3:
                    f.flags |= 65536;
                    b &= -b;
                    f.lanes |= b;
                    var x = Ni(f, k, b);
                    ph(f, x);
                    break a;
                  case 1:
                    h = k;
                    var w = f.type, u = f.stateNode;
                    if (0 === (f.flags & 128) && ("function" === typeof w.getDerivedStateFromError || null !== u && "function" === typeof u.componentDidCatch && (null === Ri || !Ri.has(u)))) {
                      f.flags |= 65536;
                      b &= -b;
                      f.lanes |= b;
                      var F = Qi(f, h, b);
                      ph(f, F);
                      break a;
                    }
                }
                f = f.return;
              } while (null !== f);
            }
            Sk(c);
          } catch (na) {
            b = na;
            Y === c && null !== c && (Y = c = c.return);
            continue;
          }
          break;
        } while (1);
      }
      function Jk() {
        var a = mk.current;
        mk.current = Rh;
        return null === a ? Rh : a;
      }
      function tj() {
        if (0 === T || 3 === T || 2 === T) T = 4;
        null === Q || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q, Z);
      }
      function Ik(a, b) {
        var c = K;
        K |= 2;
        var d = Jk();
        if (Q !== a || Z !== b) uk = null, Kk(a, b);
        do
          try {
            Tk();
            break;
          } catch (e) {
            Mk(a, e);
          }
        while (1);
        $g();
        K = c;
        mk.current = d;
        if (null !== Y) throw Error(p(261));
        Q = null;
        Z = 0;
        return T;
      }
      function Tk() {
        for (; null !== Y; ) Uk(Y);
      }
      function Lk() {
        for (; null !== Y && !cc(); ) Uk(Y);
      }
      function Uk(a) {
        var b = Vk(a.alternate, a, fj);
        a.memoizedProps = a.pendingProps;
        null === b ? Sk(a) : Y = b;
        nk.current = null;
      }
      function Sk(a) {
        var b = a;
        do {
          var c = b.alternate;
          a = b.return;
          if (0 === (b.flags & 32768)) {
            if (c = Ej(c, b, fj), null !== c) {
              Y = c;
              return;
            }
          } else {
            c = Ij(c, b);
            if (null !== c) {
              c.flags &= 32767;
              Y = c;
              return;
            }
            if (null !== a) a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
            else {
              T = 6;
              Y = null;
              return;
            }
          }
          b = b.sibling;
          if (null !== b) {
            Y = b;
            return;
          }
          Y = b = a;
        } while (null !== b);
        0 === T && (T = 5);
      }
      function Pk(a, b, c) {
        var d = C, e = ok.transition;
        try {
          ok.transition = null, C = 1, Wk(a, b, c, d);
        } finally {
          ok.transition = e, C = d;
        }
        return null;
      }
      function Wk(a, b, c, d) {
        do
          Hk();
        while (null !== wk);
        if (0 !== (K & 6)) throw Error(p(327));
        c = a.finishedWork;
        var e = a.finishedLanes;
        if (null === c) return null;
        a.finishedWork = null;
        a.finishedLanes = 0;
        if (c === a.current) throw Error(p(177));
        a.callbackNode = null;
        a.callbackPriority = 0;
        var f = c.lanes | c.childLanes;
        Bc(a, f);
        a === Q && (Y = Q = null, Z = 0);
        0 === (c.subtreeFlags & 2064) && 0 === (c.flags & 2064) || vk || (vk = true, Fk(hc, function() {
          Hk();
          return null;
        }));
        f = 0 !== (c.flags & 15990);
        if (0 !== (c.subtreeFlags & 15990) || f) {
          f = ok.transition;
          ok.transition = null;
          var g = C;
          C = 1;
          var h = K;
          K |= 4;
          nk.current = null;
          Oj(a, c);
          dk(c, a);
          Oe(Df);
          dd = !!Cf;
          Df = Cf = null;
          a.current = c;
          hk(c);
          dc();
          K = h;
          C = g;
          ok.transition = f;
        } else a.current = c;
        vk && (vk = false, wk = a, xk = e);
        f = a.pendingLanes;
        0 === f && (Ri = null);
        mc(c.stateNode);
        Dk(a, B());
        if (null !== b) for (d = a.onRecoverableError, c = 0; c < b.length; c++) e = b[c], d(e.value, { componentStack: e.stack, digest: e.digest });
        if (Oi) throw Oi = false, a = Pi, Pi = null, a;
        0 !== (xk & 1) && 0 !== a.tag && Hk();
        f = a.pendingLanes;
        0 !== (f & 1) ? a === zk ? yk++ : (yk = 0, zk = a) : yk = 0;
        jg();
        return null;
      }
      function Hk() {
        if (null !== wk) {
          var a = Dc(xk), b = ok.transition, c = C;
          try {
            ok.transition = null;
            C = 16 > a ? 16 : a;
            if (null === wk) var d = false;
            else {
              a = wk;
              wk = null;
              xk = 0;
              if (0 !== (K & 6)) throw Error(p(331));
              var e = K;
              K |= 4;
              for (V = a.current; null !== V; ) {
                var f = V, g = f.child;
                if (0 !== (V.flags & 16)) {
                  var h = f.deletions;
                  if (null !== h) {
                    for (var k = 0; k < h.length; k++) {
                      var l = h[k];
                      for (V = l; null !== V; ) {
                        var m = V;
                        switch (m.tag) {
                          case 0:
                          case 11:
                          case 15:
                            Pj(8, m, f);
                        }
                        var q = m.child;
                        if (null !== q) q.return = m, V = q;
                        else for (; null !== V; ) {
                          m = V;
                          var r = m.sibling, y = m.return;
                          Sj(m);
                          if (m === l) {
                            V = null;
                            break;
                          }
                          if (null !== r) {
                            r.return = y;
                            V = r;
                            break;
                          }
                          V = y;
                        }
                      }
                    }
                    var n = f.alternate;
                    if (null !== n) {
                      var t = n.child;
                      if (null !== t) {
                        n.child = null;
                        do {
                          var J = t.sibling;
                          t.sibling = null;
                          t = J;
                        } while (null !== t);
                      }
                    }
                    V = f;
                  }
                }
                if (0 !== (f.subtreeFlags & 2064) && null !== g) g.return = f, V = g;
                else b: for (; null !== V; ) {
                  f = V;
                  if (0 !== (f.flags & 2048)) switch (f.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Pj(9, f, f.return);
                  }
                  var x = f.sibling;
                  if (null !== x) {
                    x.return = f.return;
                    V = x;
                    break b;
                  }
                  V = f.return;
                }
              }
              var w = a.current;
              for (V = w; null !== V; ) {
                g = V;
                var u = g.child;
                if (0 !== (g.subtreeFlags & 2064) && null !== u) u.return = g, V = u;
                else b: for (g = w; null !== V; ) {
                  h = V;
                  if (0 !== (h.flags & 2048)) try {
                    switch (h.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Qj(9, h);
                    }
                  } catch (na) {
                    W(h, h.return, na);
                  }
                  if (h === g) {
                    V = null;
                    break b;
                  }
                  var F = h.sibling;
                  if (null !== F) {
                    F.return = h.return;
                    V = F;
                    break b;
                  }
                  V = h.return;
                }
              }
              K = e;
              jg();
              if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
                lc.onPostCommitFiberRoot(kc, a);
              } catch (na) {
              }
              d = true;
            }
            return d;
          } finally {
            C = c, ok.transition = b;
          }
        }
        return false;
      }
      function Xk(a, b, c) {
        b = Ji(c, b);
        b = Ni(a, b, 1);
        a = nh(a, b, 1);
        b = R();
        null !== a && (Ac(a, 1, b), Dk(a, b));
      }
      function W(a, b, c) {
        if (3 === a.tag) Xk(a, a, c);
        else for (; null !== b; ) {
          if (3 === b.tag) {
            Xk(b, a, c);
            break;
          } else if (1 === b.tag) {
            var d = b.stateNode;
            if ("function" === typeof b.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Ri || !Ri.has(d))) {
              a = Ji(c, a);
              a = Qi(b, a, 1);
              b = nh(b, a, 1);
              a = R();
              null !== b && (Ac(b, 1, a), Dk(b, a));
              break;
            }
          }
          b = b.return;
        }
      }
      function Ti(a, b, c) {
        var d = a.pingCache;
        null !== d && d.delete(b);
        b = R();
        a.pingedLanes |= a.suspendedLanes & c;
        Q === a && (Z & c) === c && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - fk ? Kk(a, 0) : rk |= c);
        Dk(a, b);
      }
      function Yk(a, b) {
        0 === b && (0 === (a.mode & 1) ? b = 1 : (b = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
        var c = R();
        a = ih(a, b);
        null !== a && (Ac(a, b, c), Dk(a, c));
      }
      function uj(a) {
        var b = a.memoizedState, c = 0;
        null !== b && (c = b.retryLane);
        Yk(a, c);
      }
      function bk(a, b) {
        var c = 0;
        switch (a.tag) {
          case 13:
            var d = a.stateNode;
            var e = a.memoizedState;
            null !== e && (c = e.retryLane);
            break;
          case 19:
            d = a.stateNode;
            break;
          default:
            throw Error(p(314));
        }
        null !== d && d.delete(b);
        Yk(a, c);
      }
      var Vk;
      Vk = function(a, b, c) {
        if (null !== a) if (a.memoizedProps !== b.pendingProps || Wf.current) dh = true;
        else {
          if (0 === (a.lanes & c) && 0 === (b.flags & 128)) return dh = false, yj(a, b, c);
          dh = 0 !== (a.flags & 131072) ? true : false;
        }
        else dh = false, I && 0 !== (b.flags & 1048576) && ug(b, ng, b.index);
        b.lanes = 0;
        switch (b.tag) {
          case 2:
            var d = b.type;
            ij(a, b);
            a = b.pendingProps;
            var e = Yf(b, H.current);
            ch(b, c);
            e = Nh(null, b, d, a, e, c);
            var f = Sh();
            b.flags |= 1;
            "object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, Zf(d) ? (f = true, cg(b)) : f = false, b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null, kh(b), e.updater = Ei, b.stateNode = e, e._reactInternals = b, Ii(b, d, a, c), b = jj(null, b, d, true, f, c)) : (b.tag = 0, I && f && vg(b), Xi(null, b, e, c), b = b.child);
            return b;
          case 16:
            d = b.elementType;
            a: {
              ij(a, b);
              a = b.pendingProps;
              e = d._init;
              d = e(d._payload);
              b.type = d;
              e = b.tag = Zk(d);
              a = Ci(d, a);
              switch (e) {
                case 0:
                  b = cj(null, b, d, a, c);
                  break a;
                case 1:
                  b = hj(null, b, d, a, c);
                  break a;
                case 11:
                  b = Yi(null, b, d, a, c);
                  break a;
                case 14:
                  b = $i(null, b, d, Ci(d.type, a), c);
                  break a;
              }
              throw Error(p(
                306,
                d,
                ""
              ));
            }
            return b;
          case 0:
            return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), cj(a, b, d, e, c);
          case 1:
            return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), hj(a, b, d, e, c);
          case 3:
            a: {
              kj(b);
              if (null === a) throw Error(p(387));
              d = b.pendingProps;
              f = b.memoizedState;
              e = f.element;
              lh(a, b);
              qh(b, d, null, c);
              var g = b.memoizedState;
              d = g.element;
              if (f.isDehydrated) if (f = { element: d, isDehydrated: false, cache: g.cache, pendingSuspenseBoundaries: g.pendingSuspenseBoundaries, transitions: g.transitions }, b.updateQueue.baseState = f, b.memoizedState = f, b.flags & 256) {
                e = Ji(Error(p(423)), b);
                b = lj(a, b, d, c, e);
                break a;
              } else if (d !== e) {
                e = Ji(Error(p(424)), b);
                b = lj(a, b, d, c, e);
                break a;
              } else for (yg = Lf(b.stateNode.containerInfo.firstChild), xg = b, I = true, zg = null, c = Vg(b, null, d, c), b.child = c; c; ) c.flags = c.flags & -3 | 4096, c = c.sibling;
              else {
                Ig();
                if (d === e) {
                  b = Zi(a, b, c);
                  break a;
                }
                Xi(a, b, d, c);
              }
              b = b.child;
            }
            return b;
          case 5:
            return Ah(b), null === a && Eg(b), d = b.type, e = b.pendingProps, f = null !== a ? a.memoizedProps : null, g = e.children, Ef(d, e) ? g = null : null !== f && Ef(d, f) && (b.flags |= 32), gj(a, b), Xi(a, b, g, c), b.child;
          case 6:
            return null === a && Eg(b), null;
          case 13:
            return oj(a, b, c);
          case 4:
            return yh(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Ug(b, null, d, c) : Xi(a, b, d, c), b.child;
          case 11:
            return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), Yi(a, b, d, e, c);
          case 7:
            return Xi(a, b, b.pendingProps, c), b.child;
          case 8:
            return Xi(a, b, b.pendingProps.children, c), b.child;
          case 12:
            return Xi(a, b, b.pendingProps.children, c), b.child;
          case 10:
            a: {
              d = b.type._context;
              e = b.pendingProps;
              f = b.memoizedProps;
              g = e.value;
              G(Wg, d._currentValue);
              d._currentValue = g;
              if (null !== f) if (He(f.value, g)) {
                if (f.children === e.children && !Wf.current) {
                  b = Zi(a, b, c);
                  break a;
                }
              } else for (f = b.child, null !== f && (f.return = b); null !== f; ) {
                var h = f.dependencies;
                if (null !== h) {
                  g = f.child;
                  for (var k = h.firstContext; null !== k; ) {
                    if (k.context === d) {
                      if (1 === f.tag) {
                        k = mh(-1, c & -c);
                        k.tag = 2;
                        var l = f.updateQueue;
                        if (null !== l) {
                          l = l.shared;
                          var m = l.pending;
                          null === m ? k.next = k : (k.next = m.next, m.next = k);
                          l.pending = k;
                        }
                      }
                      f.lanes |= c;
                      k = f.alternate;
                      null !== k && (k.lanes |= c);
                      bh(
                        f.return,
                        c,
                        b
                      );
                      h.lanes |= c;
                      break;
                    }
                    k = k.next;
                  }
                } else if (10 === f.tag) g = f.type === b.type ? null : f.child;
                else if (18 === f.tag) {
                  g = f.return;
                  if (null === g) throw Error(p(341));
                  g.lanes |= c;
                  h = g.alternate;
                  null !== h && (h.lanes |= c);
                  bh(g, c, b);
                  g = f.sibling;
                } else g = f.child;
                if (null !== g) g.return = f;
                else for (g = f; null !== g; ) {
                  if (g === b) {
                    g = null;
                    break;
                  }
                  f = g.sibling;
                  if (null !== f) {
                    f.return = g.return;
                    g = f;
                    break;
                  }
                  g = g.return;
                }
                f = g;
              }
              Xi(a, b, e.children, c);
              b = b.child;
            }
            return b;
          case 9:
            return e = b.type, d = b.pendingProps.children, ch(b, c), e = eh(e), d = d(e), b.flags |= 1, Xi(a, b, d, c), b.child;
          case 14:
            return d = b.type, e = Ci(d, b.pendingProps), e = Ci(d.type, e), $i(a, b, d, e, c);
          case 15:
            return bj(a, b, b.type, b.pendingProps, c);
          case 17:
            return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), ij(a, b), b.tag = 1, Zf(d) ? (a = true, cg(b)) : a = false, ch(b, c), Gi(b, d, e), Ii(b, d, e, c), jj(null, b, d, true, a, c);
          case 19:
            return xj(a, b, c);
          case 22:
            return dj(a, b, c);
        }
        throw Error(p(156, b.tag));
      };
      function Fk(a, b) {
        return ac(a, b);
      }
      function $k(a, b, c, d) {
        this.tag = a;
        this.key = c;
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
        this.index = 0;
        this.ref = null;
        this.pendingProps = b;
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
        this.mode = d;
        this.subtreeFlags = this.flags = 0;
        this.deletions = null;
        this.childLanes = this.lanes = 0;
        this.alternate = null;
      }
      function Bg(a, b, c, d) {
        return new $k(a, b, c, d);
      }
      function aj(a) {
        a = a.prototype;
        return !(!a || !a.isReactComponent);
      }
      function Zk(a) {
        if ("function" === typeof a) return aj(a) ? 1 : 0;
        if (void 0 !== a && null !== a) {
          a = a.$$typeof;
          if (a === Da) return 11;
          if (a === Ga) return 14;
        }
        return 2;
      }
      function Pg(a, b) {
        var c = a.alternate;
        null === c ? (c = Bg(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null);
        c.flags = a.flags & 14680064;
        c.childLanes = a.childLanes;
        c.lanes = a.lanes;
        c.child = a.child;
        c.memoizedProps = a.memoizedProps;
        c.memoizedState = a.memoizedState;
        c.updateQueue = a.updateQueue;
        b = a.dependencies;
        c.dependencies = null === b ? null : { lanes: b.lanes, firstContext: b.firstContext };
        c.sibling = a.sibling;
        c.index = a.index;
        c.ref = a.ref;
        return c;
      }
      function Rg(a, b, c, d, e, f) {
        var g = 2;
        d = a;
        if ("function" === typeof a) aj(a) && (g = 1);
        else if ("string" === typeof a) g = 5;
        else a: switch (a) {
          case ya:
            return Tg(c.children, e, f, b);
          case za:
            g = 8;
            e |= 8;
            break;
          case Aa:
            return a = Bg(12, c, b, e | 2), a.elementType = Aa, a.lanes = f, a;
          case Ea:
            return a = Bg(13, c, b, e), a.elementType = Ea, a.lanes = f, a;
          case Fa:
            return a = Bg(19, c, b, e), a.elementType = Fa, a.lanes = f, a;
          case Ia:
            return pj(c, e, f, b);
          default:
            if ("object" === typeof a && null !== a) switch (a.$$typeof) {
              case Ba:
                g = 10;
                break a;
              case Ca:
                g = 9;
                break a;
              case Da:
                g = 11;
                break a;
              case Ga:
                g = 14;
                break a;
              case Ha:
                g = 16;
                d = null;
                break a;
            }
            throw Error(p(130, null == a ? a : typeof a, ""));
        }
        b = Bg(g, c, b, e);
        b.elementType = a;
        b.type = d;
        b.lanes = f;
        return b;
      }
      function Tg(a, b, c, d) {
        a = Bg(7, a, d, b);
        a.lanes = c;
        return a;
      }
      function pj(a, b, c, d) {
        a = Bg(22, a, d, b);
        a.elementType = Ia;
        a.lanes = c;
        a.stateNode = { isHidden: false };
        return a;
      }
      function Qg(a, b, c) {
        a = Bg(6, a, null, b);
        a.lanes = c;
        return a;
      }
      function Sg(a, b, c) {
        b = Bg(4, null !== a.children ? a.children : [], a.key, b);
        b.lanes = c;
        b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
        return b;
      }
      function al(a, b, c, d, e) {
        this.tag = b;
        this.containerInfo = a;
        this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
        this.timeoutHandle = -1;
        this.callbackNode = this.pendingContext = this.context = null;
        this.callbackPriority = 0;
        this.eventTimes = zc(0);
        this.expirationTimes = zc(-1);
        this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
        this.entanglements = zc(0);
        this.identifierPrefix = d;
        this.onRecoverableError = e;
        this.mutableSourceEagerHydrationData = null;
      }
      function bl(a, b, c, d, e, f, g, h, k) {
        a = new al(a, b, c, h, k);
        1 === b ? (b = 1, true === f && (b |= 8)) : b = 0;
        f = Bg(3, null, null, b);
        a.current = f;
        f.stateNode = a;
        f.memoizedState = { element: d, isDehydrated: c, cache: null, transitions: null, pendingSuspenseBoundaries: null };
        kh(f);
        return a;
      }
      function cl(a, b, c) {
        var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
        return { $$typeof: wa, key: null == d ? null : "" + d, children: a, containerInfo: b, implementation: c };
      }
      function dl(a) {
        if (!a) return Vf;
        a = a._reactInternals;
        a: {
          if (Vb(a) !== a || 1 !== a.tag) throw Error(p(170));
          var b = a;
          do {
            switch (b.tag) {
              case 3:
                b = b.stateNode.context;
                break a;
              case 1:
                if (Zf(b.type)) {
                  b = b.stateNode.__reactInternalMemoizedMergedChildContext;
                  break a;
                }
            }
            b = b.return;
          } while (null !== b);
          throw Error(p(171));
        }
        if (1 === a.tag) {
          var c = a.type;
          if (Zf(c)) return bg(a, c, b);
        }
        return b;
      }
      function el(a, b, c, d, e, f, g, h, k) {
        a = bl(c, d, true, a, e, f, g, h, k);
        a.context = dl(null);
        c = a.current;
        d = R();
        e = yi(c);
        f = mh(d, e);
        f.callback = void 0 !== b && null !== b ? b : null;
        nh(c, f, e);
        a.current.lanes = e;
        Ac(a, e, d);
        Dk(a, d);
        return a;
      }
      function fl(a, b, c, d) {
        var e = b.current, f = R(), g = yi(e);
        c = dl(c);
        null === b.context ? b.context = c : b.pendingContext = c;
        b = mh(f, g);
        b.payload = { element: a };
        d = void 0 === d ? null : d;
        null !== d && (b.callback = d);
        a = nh(e, b, g);
        null !== a && (gi(a, e, g, f), oh(a, e, g));
        return g;
      }
      function gl(a) {
        a = a.current;
        if (!a.child) return null;
        switch (a.child.tag) {
          case 5:
            return a.child.stateNode;
          default:
            return a.child.stateNode;
        }
      }
      function hl(a, b) {
        a = a.memoizedState;
        if (null !== a && null !== a.dehydrated) {
          var c = a.retryLane;
          a.retryLane = 0 !== c && c < b ? c : b;
        }
      }
      function il(a, b) {
        hl(a, b);
        (a = a.alternate) && hl(a, b);
      }
      var kl = "function" === typeof reportError ? reportError : function(a) {
        console.error(a);
      };
      function ll(a) {
        this._internalRoot = a;
      }
      ml.prototype.render = ll.prototype.render = function(a) {
        var b = this._internalRoot;
        if (null === b) throw Error(p(409));
        fl(a, b, null, null);
      };
      ml.prototype.unmount = ll.prototype.unmount = function() {
        var a = this._internalRoot;
        if (null !== a) {
          this._internalRoot = null;
          var b = a.containerInfo;
          Rk(function() {
            fl(null, a, null, null);
          });
          b[uf] = null;
        }
      };
      function ml(a) {
        this._internalRoot = a;
      }
      ml.prototype.unstable_scheduleHydration = function(a) {
        if (a) {
          var b = Hc();
          a = { blockedOn: null, target: a, priority: b };
          for (var c = 0; c < Qc.length && 0 !== b && b < Qc[c].priority; c++) ;
          Qc.splice(c, 0, a);
          0 === c && Vc(a);
        }
      };
      function nl(a) {
        return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType);
      }
      function ol(a) {
        return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
      }
      function pl() {
      }
      function ql(a, b, c, d, e) {
        if (e) {
          if ("function" === typeof d) {
            var f = d;
            d = function() {
              var a2 = gl(g);
              f.call(a2);
            };
          }
          var g = el(b, d, a, 0, null, false, false, "", pl);
          a._reactRootContainer = g;
          a[uf] = g.current;
          sf(8 === a.nodeType ? a.parentNode : a);
          Rk();
          return g;
        }
        for (; e = a.lastChild; ) a.removeChild(e);
        if ("function" === typeof d) {
          var h = d;
          d = function() {
            var a2 = gl(k);
            h.call(a2);
          };
        }
        var k = bl(a, 0, false, null, null, false, false, "", pl);
        a._reactRootContainer = k;
        a[uf] = k.current;
        sf(8 === a.nodeType ? a.parentNode : a);
        Rk(function() {
          fl(b, k, c, d);
        });
        return k;
      }
      function rl(a, b, c, d, e) {
        var f = c._reactRootContainer;
        if (f) {
          var g = f;
          if ("function" === typeof e) {
            var h = e;
            e = function() {
              var a2 = gl(g);
              h.call(a2);
            };
          }
          fl(b, g, a, e);
        } else g = ql(c, b, a, e, d);
        return gl(g);
      }
      Ec = function(a) {
        switch (a.tag) {
          case 3:
            var b = a.stateNode;
            if (b.current.memoizedState.isDehydrated) {
              var c = tc(b.pendingLanes);
              0 !== c && (Cc(b, c | 1), Dk(b, B()), 0 === (K & 6) && (Gj = B() + 500, jg()));
            }
            break;
          case 13:
            Rk(function() {
              var b2 = ih(a, 1);
              if (null !== b2) {
                var c2 = R();
                gi(b2, a, 1, c2);
              }
            }), il(a, 1);
        }
      };
      Fc = function(a) {
        if (13 === a.tag) {
          var b = ih(a, 134217728);
          if (null !== b) {
            var c = R();
            gi(b, a, 134217728, c);
          }
          il(a, 134217728);
        }
      };
      Gc = function(a) {
        if (13 === a.tag) {
          var b = yi(a), c = ih(a, b);
          if (null !== c) {
            var d = R();
            gi(c, a, b, d);
          }
          il(a, b);
        }
      };
      Hc = function() {
        return C;
      };
      Ic = function(a, b) {
        var c = C;
        try {
          return C = a, b();
        } finally {
          C = c;
        }
      };
      yb = function(a, b, c) {
        switch (b) {
          case "input":
            bb(a, c);
            b = c.name;
            if ("radio" === c.type && null != b) {
              for (c = a; c.parentNode; ) c = c.parentNode;
              c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
              for (b = 0; b < c.length; b++) {
                var d = c[b];
                if (d !== a && d.form === a.form) {
                  var e = Db(d);
                  if (!e) throw Error(p(90));
                  Wa(d);
                  bb(d, e);
                }
              }
            }
            break;
          case "textarea":
            ib(a, c);
            break;
          case "select":
            b = c.value, null != b && fb(a, !!c.multiple, b, false);
        }
      };
      Gb = Qk;
      Hb = Rk;
      var sl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Qk] }, tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
      var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
        a = Zb(a);
        return null === a ? null : a.stateNode;
      }, findFiberByHostInstance: tl.findFiberByHostInstance, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
      if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
        var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!vl.isDisabled && vl.supportsFiber) try {
          kc = vl.inject(ul), lc = vl;
        } catch (a) {
        }
      }
      reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
      reactDom_production_min.createPortal = function(a, b) {
        var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
        if (!nl(b)) throw Error(p(200));
        return cl(a, b, null, c);
      };
      reactDom_production_min.createRoot = function(a, b) {
        if (!nl(a)) throw Error(p(299));
        var c = false, d = "", e = kl;
        null !== b && void 0 !== b && (true === b.unstable_strictMode && (c = true), void 0 !== b.identifierPrefix && (d = b.identifierPrefix), void 0 !== b.onRecoverableError && (e = b.onRecoverableError));
        b = bl(a, 1, false, null, null, c, false, d, e);
        a[uf] = b.current;
        sf(8 === a.nodeType ? a.parentNode : a);
        return new ll(b);
      };
      reactDom_production_min.findDOMNode = function(a) {
        if (null == a) return null;
        if (1 === a.nodeType) return a;
        var b = a._reactInternals;
        if (void 0 === b) {
          if ("function" === typeof a.render) throw Error(p(188));
          a = Object.keys(a).join(",");
          throw Error(p(268, a));
        }
        a = Zb(b);
        a = null === a ? null : a.stateNode;
        return a;
      };
      reactDom_production_min.flushSync = function(a) {
        return Rk(a);
      };
      reactDom_production_min.hydrate = function(a, b, c) {
        if (!ol(b)) throw Error(p(200));
        return rl(null, a, b, true, c);
      };
      reactDom_production_min.hydrateRoot = function(a, b, c) {
        if (!nl(a)) throw Error(p(405));
        var d = null != c && c.hydratedSources || null, e = false, f = "", g = kl;
        null !== c && void 0 !== c && (true === c.unstable_strictMode && (e = true), void 0 !== c.identifierPrefix && (f = c.identifierPrefix), void 0 !== c.onRecoverableError && (g = c.onRecoverableError));
        b = el(b, null, a, 1, null != c ? c : null, e, false, f, g);
        a[uf] = b.current;
        sf(a);
        if (d) for (a = 0; a < d.length; a++) c = d[a], e = c._getVersion, e = e(c._source), null == b.mutableSourceEagerHydrationData ? b.mutableSourceEagerHydrationData = [c, e] : b.mutableSourceEagerHydrationData.push(
          c,
          e
        );
        return new ml(b);
      };
      reactDom_production_min.render = function(a, b, c) {
        if (!ol(b)) throw Error(p(200));
        return rl(null, a, b, false, c);
      };
      reactDom_production_min.unmountComponentAtNode = function(a) {
        if (!ol(a)) throw Error(p(40));
        return a._reactRootContainer ? (Rk(function() {
          rl(null, null, a, false, function() {
            a._reactRootContainer = null;
            a[uf] = null;
          });
        }), true) : false;
      };
      reactDom_production_min.unstable_batchedUpdates = Qk;
      reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b, c, d) {
        if (!ol(c)) throw Error(p(200));
        if (null == a || void 0 === a._reactInternals) throw Error(p(38));
        return rl(a, b, c, false, d);
      };
      reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
      return reactDom_production_min;
    }
    var hasRequiredReactDom;
    function requireReactDom() {
      if (hasRequiredReactDom) return reactDom.exports;
      hasRequiredReactDom = 1;
      function checkDCE() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
          return;
        }
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
          console.error(err);
        }
      }
      {
        checkDCE();
        reactDom.exports = requireReactDom_production_min();
      }
      return reactDom.exports;
    }
    var hasRequiredClient;
    function requireClient() {
      if (hasRequiredClient) return client;
      hasRequiredClient = 1;
      var m = requireReactDom();
      {
        client.createRoot = m.createRoot;
        client.hydrateRoot = m.hydrateRoot;
      }
      return client;
    }
    var clientExports = requireClient();
    var classnames = { exports: {} };
    /*!
    	Copyright (c) 2018 Jed Watson.
    	Licensed under the MIT License (MIT), see
    	http://jedwatson.github.io/classnames
    */
    var hasRequiredClassnames;
    function requireClassnames() {
      if (hasRequiredClassnames) return classnames.exports;
      hasRequiredClassnames = 1;
      (function(module2) {
        (function() {
          var hasOwn = {}.hasOwnProperty;
          function classNames2() {
            var classes = "";
            for (var i = 0; i < arguments.length; i++) {
              var arg = arguments[i];
              if (arg) {
                classes = appendClass(classes, parseValue(arg));
              }
            }
            return classes;
          }
          function parseValue(arg) {
            if (typeof arg === "string" || typeof arg === "number") {
              return arg;
            }
            if (typeof arg !== "object") {
              return "";
            }
            if (Array.isArray(arg)) {
              return classNames2.apply(null, arg);
            }
            if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
              return arg.toString();
            }
            var classes = "";
            for (var key in arg) {
              if (hasOwn.call(arg, key) && arg[key]) {
                classes = appendClass(classes, key);
              }
            }
            return classes;
          }
          function appendClass(value2, newClass) {
            if (!newClass) {
              return value2;
            }
            if (value2) {
              return value2 + " " + newClass;
            }
            return value2 + newClass;
          }
          if (module2.exports) {
            classNames2.default = classNames2;
            module2.exports = classNames2;
          } else {
            window.classNames = classNames2;
          }
        })();
      })(classnames);
      return classnames.exports;
    }
    var classnamesExports = requireClassnames();
    const classNames = /* @__PURE__ */ getDefaultExportFromCjs(classnamesExports);
    const padding = `_padding_72bf970`;
    const styles$12 = { padding };
    const Pad = React.forwardRef(function Pad2({ children, inline, start, end, top: top2, bottom, amount, minWidth, width, maxWidth, minHeight, height, maxHeight, style: defaultStyle, className, ...props }, ref) {
      const style = {
        ...defaultStyle,
        minWidth,
        width,
        maxWidth,
        minHeight,
        height,
        maxHeight
      };
      if (amount) {
        style.padding = amount;
      }
      if (start) {
        style.paddingInlineStart = start;
      }
      if (end) {
        style.paddingInlineEnd = end;
      }
      if (top2) {
        style.paddingTop = top2;
      }
      if (bottom) {
        style.paddingBottom = bottom;
      }
      return React.createElement("div", { ref, className: classNames(className, styles$12.padding), style, "data-inline": String(inline), ...props }, children);
    });
    function useForkRef(...args) {
      return reactExports.useCallback((obj) => {
        args.forEach((ref) => {
          if (typeof ref === "function") {
            ref(obj);
          } else if (typeof ref === "object" && ref != null && ref.hasOwnProperty("current")) {
            ref.current = obj;
          }
        });
      }, args);
    }
    var TriggerConfig;
    (function(TriggerConfig2) {
      TriggerConfig2[TriggerConfig2["Both"] = 0] = "Both";
      TriggerConfig2[TriggerConfig2["Width"] = 1] = "Width";
      TriggerConfig2[TriggerConfig2["Height"] = 2] = "Height";
    })(TriggerConfig || (TriggerConfig = {}));
    class ResizeObserverRegistry {
      constructor() {
        __publicField(this, "_resizeObserver");
        __publicField(this, "_elementHandlers");
        __publicField(this, "_elementSizes");
        __publicField(this, "_elementTriggerConfig");
        this._elementHandlers = /* @__PURE__ */ new WeakMap();
        this._elementSizes = /* @__PURE__ */ new WeakMap();
        this._elementTriggerConfig = /* @__PURE__ */ new WeakMap();
        this._resizeObserver = new ResizeObserver((entries) => {
          requestAnimationFrame(() => {
            for (let entry of entries) {
              const size = this._elementSizes.get(entry.target);
              if (size != null) {
                const newHeight = entry.borderBoxSize[0].blockSize;
                const newWidth = entry.borderBoxSize[0].inlineSize;
                const triggerConfig = this._elementTriggerConfig.get(entry.target);
                const hasHeightChanged = newHeight !== size.height;
                const hasWidthChanged = newWidth !== size.width;
                const hasSizeChanged = hasHeightChanged || hasWidthChanged;
                size.width = newWidth;
                size.height = newHeight;
                if (hasSizeChanged) {
                  const shouldTriggerHeightChange = hasHeightChanged && (triggerConfig === TriggerConfig.Both || triggerConfig === TriggerConfig.Height);
                  const shouldTriggerWidthChange = hasWidthChanged && (triggerConfig === TriggerConfig.Both || triggerConfig === TriggerConfig.Width);
                  const shouldTrigger = shouldTriggerHeightChange || shouldTriggerWidthChange;
                  if (shouldTrigger) {
                    const handlers = this._elementHandlers.get(entry.target);
                    handlers == null ? void 0 : handlers.forEach((handler) => handler(newWidth, newHeight, entry));
                  }
                }
              }
            }
          });
        });
      }
      register(element, handler, triggerConfig = TriggerConfig.Both) {
        this._elementSizes.set(element, {
          width: 0,
          height: 0
        });
        this._elementTriggerConfig.set(element, triggerConfig);
        this._resizeObserver.observe(element);
        const handlers = this.getElementHandlers(element);
        handlers.push(handler);
        return () => {
          const handlerIndex = handlers.indexOf(handler);
          if (handlerIndex > -1) {
            handlers.splice(handlerIndex, 1);
          }
          if (handlers.length <= 0) {
            this._elementHandlers.delete(element);
            this._elementSizes.delete(element);
            this._elementTriggerConfig.delete(element);
            this._resizeObserver.unobserve(element);
          }
        };
      }
      getElementHandlers(element) {
        let handlers = this._elementHandlers.get(element);
        if (handlers == null) {
          handlers = [];
          this._elementHandlers.set(element, handlers);
        }
        return handlers;
      }
    }
    const resizeObserverRegistry = new ResizeObserverRegistry();
    function useResizeObserver(resizeHandler, triggerConfig = TriggerConfig.Both) {
      const [element, setElement] = reactExports.useState(null);
      const callbackRef = reactExports.useCallback((newElement) => {
        setElement(newElement);
      }, []);
      const resizeHandlerRef = reactExports.useRef(resizeHandler);
      resizeHandlerRef.current = resizeHandler;
      reactExports.useLayoutEffect(() => {
        if (element != null) {
          const unregister = resizeObserverRegistry.register(element, resizeHandlerRef.current, triggerConfig);
          const rect = element.getBoundingClientRect();
          const simulatedEntry = {
            target: element,
            contentRect: rect,
            borderBoxSize: [
              {
                inlineSize: rect.width,
                blockSize: rect.height
              }
            ],
            contentBoxSize: [
              {
                inlineSize: rect.width,
                blockSize: rect.height
              }
            ],
            devicePixelContentBoxSize: [
              {
                inlineSize: rect.width * window.devicePixelRatio,
                blockSize: rect.height * window.devicePixelRatio
              }
            ]
          };
          resizeHandlerRef.current(rect.width, rect.height, simulatedEntry);
          return unregister;
        }
      }, [triggerConfig, element]);
      return callbackRef;
    }
    function Divider({ direction = "horizontal" }) {
      const style = {};
      if (direction === "horizontal") {
        style.width = "100%";
        style.height = "0px";
        style.borderTop = "1px solid rgba(22,22,22,0.2)";
        style.borderBottom = "1px solid rgba(222,222,222,0.2)";
      } else {
        style.width = "0px";
        style.height = "100%";
        style.borderInlineStart = "1px solid rgba(22,22,22,0.2)";
        style.borderInlineEnd = "1px solid rgba(222,222,222,0.2)";
      }
      return React.createElement("div", { style });
    }
    const icon$1 = `_icon_b200233`;
    const styles$11 = { icon: icon$1 };
    let repository = window.location.origin;
    if (!window.location.origin.includes("tcn.com")) {
      repository = "https://op-dev.tcn.com";
    }
    function Icon({ size, variant = "default", name: name2, style = {}, color = "currentColor", verticalAlign = "text-top", flipOnRtl = false, className, ...props }) {
      style.width = size;
      style.height = size;
      style.minWidth = size;
      style.minHeight = size;
      style.verticalAlign = verticalAlign;
      style.background = color;
      style.maskImage = `url('${repository}/icons/${name2}.svg')`;
      return React.createElement("div", { "data-flip-on-rtl": flipOnRtl, className: classNames(styles$11.icon, className), style: { ...style }, "data-variant": variant, ...props });
    }
    const bodyText = `_body-text_13bfe84`;
    const styles$10 = { "body-text": bodyText };
    function BodyText({ variant = "medium", emphasis = "normal", contrast = "normal", color, children, className, style = {}, padStart, padEnd, padBottom, padTop, pad, selectable = false, breakWords = false }) {
      if (pad) {
        style.padding = pad;
      }
      if (padStart) {
        style.paddingInlineStart = padStart;
      }
      if (padEnd) {
        style.paddingInlineEnd = padEnd;
      }
      if (padTop) {
        style.paddingTop = padTop;
      }
      if (padBottom) {
        style.paddingBottom = padBottom;
      }
      if (color) {
        style.color = color;
      }
      return React.createElement("div", { "data-contrast": contrast, "data-emphasis": emphasis, "data-selectable": selectable, className: classNames(styles$10["body-text"], className), style, "data-variant": variant, "data-word-break": breakWords }, children);
    }
    const header = `_header_bc358ce`;
    const styles$$ = { header };
    function Header$1({ variant = "medium", emphasis = "normal", contrast = "normal", color, children, className, style = {}, padStart, padEnd, padBottom, padTop, pad, selectable = false }) {
      let As;
      if (variant === "large") {
        As = "h1";
      } else if (variant === "medium") {
        As = "h2";
      } else {
        As = "h3";
      }
      if (pad) {
        style.padding = pad;
      }
      if (padStart) {
        style.paddingInlineStart = padStart;
      }
      if (padEnd) {
        style.paddingInlineEnd = padEnd;
      }
      if (padTop) {
        style.paddingTop = padTop;
      }
      if (padBottom) {
        style.paddingBottom = padBottom;
      }
      if (color) {
        style.color = color;
      }
      return React.createElement(As, { "data-contrast": contrast, "data-emphasis": emphasis, "data-selectable": selectable, className: classNames(styles$$["header"], className), style, "data-variant": variant }, children);
    }
    const eventMap = {
      onClick: "click",
      onMouseDown: "mousedown",
      onMouseUp: "mouseup"
    };
    const touchMap = {
      onTouchStart: "touchstart",
      onTouchEnd: "touchend"
    };
    function isEventWithinElement(event, node, activated, refs) {
      if (!activated) {
        return true;
      }
      let isWithinElement;
      if (event.composedPath) {
        isWithinElement = [node, ...refs].find((ref) => {
          return event.composedPath().indexOf(ref) > -1;
        }) !== void 0;
      } else {
        isWithinElement = !document.documentElement.contains(event.target) || [node, ...refs].find((ref) => {
          return ref == null ? void 0 : ref.contains(event.target);
        }) !== void 0;
      }
      return isWithinElement;
    }
    const ClickAwayListener = React.forwardRef(function ClickAwayListener2({ children, mouseEvent, touchEvent, onClickAway, refs = [] }, ref) {
      const nodeRef = reactExports.useRef(null);
      const startedActionWithinElementRef = reactExports.useRef(true);
      const DOMMouseEvent = eventMap[mouseEvent || "onClick"];
      const DOMTouchEvent = touchMap[touchEvent || "onTouchEnd"];
      const newRef = useForkRef(ref, nodeRef, children.ref);
      const activatedRef = React.useRef(false);
      React.useEffect(() => {
        window.setTimeout(() => {
          activatedRef.current = true;
        }, 0);
        return () => {
          activatedRef.current = false;
        };
      }, []);
      const trackAction = reactExports.useCallback((event) => {
        startedActionWithinElementRef.current = isEventWithinElement(event, nodeRef.current, activatedRef.current, refs.map((r) => r.current));
      }, [refs]);
      const eventHandler = reactExports.useCallback((event) => {
        const startedFromWithinElement = startedActionWithinElementRef.current;
        const isWithinElement = isEventWithinElement(event, nodeRef.current, activatedRef.current, refs.map((r) => r.current));
        if (!isWithinElement && !startedFromWithinElement) {
          onClickAway(event);
        }
      }, [onClickAway, refs]);
      reactExports.useEffect(() => {
        document.addEventListener("mousedown", trackAction);
        document.addEventListener("touchstart", trackAction);
        document.addEventListener(DOMMouseEvent, eventHandler);
        document.addEventListener(DOMTouchEvent, eventHandler);
        return () => {
          document.removeEventListener("mousedown", trackAction);
          document.removeEventListener("touchstart", trackAction);
          document.removeEventListener(DOMMouseEvent, eventHandler);
          document.removeEventListener(DOMTouchEvent, eventHandler);
        };
      }, [DOMTouchEvent, DOMMouseEvent, eventHandler, trackAction]);
      return React.cloneElement(children, {
        ...children.props,
        ref: newRef
      });
    });
    const ScrollAwayListener = React.forwardRef(function ScrollAwayListener2({ children, onScrollAway }, ref) {
      const nodeRef = reactExports.useRef(null);
      const newRef = useForkRef(ref, nodeRef, children.ref);
      reactExports.useEffect(() => {
        const onScroll = (event) => {
          let insideDOM;
          if (event.composedPath) {
            insideDOM = event.composedPath().indexOf(nodeRef.current) > -1;
          } else {
            insideDOM = !document.documentElement.contains(event.target) || nodeRef.current.contains(event.target);
          }
          if (!insideDOM) {
            onScrollAway();
            document.removeEventListener("scroll", onScroll, true);
            event.preventDefault();
          }
        };
        document.addEventListener("scroll", onScroll, true);
        return () => {
          document.removeEventListener("scroll", onScroll, true);
        };
      }, [onScrollAway]);
      return React.cloneElement(children, {
        ...children.props,
        ref: newRef
      });
    });
    function defaultValue(value2, defaultValue2) {
      return value2 == null ? defaultValue2 : value2;
    }
    const leftResizeHandle = `_left-resize-handle_a23e04e`;
    const styles$_ = { "left-resize-handle": leftResizeHandle };
    function createVeil() {
      const veil = window.document.createElement("div");
      veil.style.position = "absolute";
      veil.style.inset = "-500px";
      veil.style.backgroundColor = "transparent";
      veil.style.pointerEvents = "auto";
      return veil;
    }
    function createHorizontalResizeHandler(targetRef, onWidthResize, onWidthResizeEnd, invert = false, disableDirection = false) {
      return function startHorizontalResize(event) {
        const box = targetRef.current;
        if (box == null) {
          return;
        }
        const veil = createVeil();
        box.appendChild(veil);
        const languageDirection = window.getComputedStyle(box).direction;
        const finalInvert = languageDirection === "rtl" && !disableDirection ? !invert : invert;
        const direction = finalInvert ? -1 : 1;
        const startX = event.clientX;
        const startRect = box.getBoundingClientRect();
        let width = startRect.width;
        const drag = (event2) => {
          const deltaX = direction * (event2.clientX - startX);
          const newWidth = startRect.width + deltaX;
          width = newWidth;
          box.style.width = `${newWidth}px`;
          onWidthResize && onWidthResize(newWidth);
          event2.stopPropagation();
          event2.preventDefault();
        };
        const mouseEnter = (event2) => {
          if (event2.buttons === 0) {
            endDrag();
          }
        };
        const endDrag = () => {
          box.removeChild(veil);
          document.body.removeEventListener("mousemove", drag);
          document.body.removeEventListener("mouseup", endDrag);
          document.body.removeEventListener("mouseenter", mouseEnter);
          event.stopPropagation();
          event.preventDefault();
          onWidthResizeEnd && onWidthResizeEnd(width);
        };
        document.body.addEventListener("mousemove", drag);
        document.body.addEventListener("mouseup", endDrag);
        document.body.addEventListener("mouseenter", mouseEnter);
        event.stopPropagation();
        event.preventDefault();
      };
    }
    function createVerticalResizeHandler(targetRef, onHeightResize, onHeightResizeEnd, invert = false) {
      const direction = invert ? -1 : 1;
      return function startVerticalResize(event) {
        const box = targetRef.current;
        if (box == null) {
          return;
        }
        const veil = createVeil();
        box.appendChild(veil);
        const startY = event.clientY;
        const startRect = box.getBoundingClientRect();
        let height = startRect.height;
        const drag = (event2) => {
          const deltaY = direction * (event2.clientY - startY);
          const newHeight = startRect.height + deltaY;
          height = newHeight;
          box.style.height = `${newHeight}px`;
          onHeightResize && onHeightResize(newHeight);
          event2.stopPropagation();
          event2.preventDefault();
        };
        const mouseEnter = (event2) => {
          if (event2.buttons === 0) {
            endDrag();
          }
        };
        const endDrag = () => {
          box.removeChild(veil);
          document.body.removeEventListener("mousemove", drag);
          document.body.removeEventListener("mouseup", endDrag);
          document.body.removeEventListener("mouseenter", mouseEnter);
          event.stopPropagation();
          event.preventDefault();
          onHeightResizeEnd && onHeightResizeEnd(height);
        };
        document.body.addEventListener("mousemove", drag);
        document.body.addEventListener("mouseup", endDrag);
        document.body.addEventListener("mouseenter", mouseEnter);
        event.stopPropagation();
        event.preventDefault();
      };
    }
    function LeftResizeHandle({ targetRef, handleProps, onWidthResize, onWidthResizeEnd }) {
      const resizeHandler = createHorizontalResizeHandler(targetRef, onWidthResize, onWidthResizeEnd, true, true);
      const offset = (handleProps == null ? void 0 : handleProps.offset) ? handleProps.offset : -8;
      const leftResizeHandleStyle = {
        ...handleProps == null ? void 0 : handleProps.style,
        "--resize-offset": `${offset}px`,
        width: (handleProps == null ? void 0 : handleProps.size) || "16px"
      };
      return React.createElement("div", { className: styles$_["left-resize-handle"], onMouseDown: resizeHandler, style: leftResizeHandleStyle });
    }
    const rightResizeHandle = `_right-resize-handle_3cef4e2`;
    const styles$Z = { "right-resize-handle": rightResizeHandle };
    function RightResizeHandle({ targetRef, handleProps, onWidthResize, onWidthResizeEnd }) {
      const resizeHandler = createHorizontalResizeHandler(targetRef, onWidthResize, onWidthResizeEnd, false, true);
      const offset = (handleProps == null ? void 0 : handleProps.offset) ? handleProps.offset : -8;
      const rightResizeHandleStyle = {
        ...handleProps == null ? void 0 : handleProps.style,
        "--resize-offset": `${offset}px`,
        width: (handleProps == null ? void 0 : handleProps.size) || "16px"
      };
      return React.createElement("div", { className: styles$Z["right-resize-handle"], onMouseDown: resizeHandler, style: rightResizeHandleStyle });
    }
    const bottomResizeHandle = `_bottom-resize-handle_ef7c02c`;
    const styles$Y = { "bottom-resize-handle": bottomResizeHandle };
    function BottomResizeHandle({ targetRef, handleProps, onHeightResize, onHeightResizeEnd }) {
      const resizeHandler = createVerticalResizeHandler(targetRef, onHeightResize, onHeightResizeEnd);
      const offset = (handleProps == null ? void 0 : handleProps.offset) ? handleProps.offset : -8;
      const bottomResizeHandleStyle = {
        ...handleProps == null ? void 0 : handleProps.style,
        bottom: `${offset}px`,
        height: (handleProps == null ? void 0 : handleProps.size) || "16px"
      };
      return React.createElement("div", { className: styles$Y["bottom-resize-handle"], onMouseDown: resizeHandler, style: bottomResizeHandleStyle });
    }
    const endResizeHandle = `_end-resize-handle_16fb47e`;
    const styles$X = { "end-resize-handle": endResizeHandle };
    function EndResizeHandle({ targetRef, handleProps, onWidthResize, onWidthResizeEnd }) {
      const resizeHandler = createHorizontalResizeHandler(targetRef, onWidthResize, onWidthResizeEnd);
      const offset = (handleProps == null ? void 0 : handleProps.offset) ? handleProps.offset : -8;
      const endResizeHandleStyle = {
        ...handleProps == null ? void 0 : handleProps.style,
        "--resize-offset": `${offset}px`,
        width: (handleProps == null ? void 0 : handleProps.size) || "16px"
      };
      return React.createElement("div", { className: styles$X["end-resize-handle"], onMouseDown: resizeHandler, style: endResizeHandleStyle });
    }
    const startResizeHandle = `_start-resize-handle_051d311`;
    const styles$W = { "start-resize-handle": startResizeHandle };
    function StartResizeHandle({ targetRef, handleProps, onWidthResize, onWidthResizeEnd }) {
      const resizeHandler = createHorizontalResizeHandler(targetRef, onWidthResize, onWidthResizeEnd, true);
      const offset = (handleProps == null ? void 0 : handleProps.offset) ? handleProps.offset : -8;
      const startResizeHandleStyle = {
        ...handleProps == null ? void 0 : handleProps.style,
        "--resize-offset": `${offset}px`,
        width: (handleProps == null ? void 0 : handleProps.size) || "16px"
      };
      return React.createElement("div", { className: styles$W["start-resize-handle"], onMouseDown: resizeHandler, style: startResizeHandleStyle });
    }
    const topResizeHandle = `_top-resize-handle_01731cd`;
    const styles$V = { "top-resize-handle": topResizeHandle };
    function TopResizeHandle({ targetRef, handleProps, onHeightResize, onHeightResizeEnd }) {
      const resizeHandler = createVerticalResizeHandler(targetRef, onHeightResize, onHeightResizeEnd, true);
      const offset = (handleProps == null ? void 0 : handleProps.offset) ? handleProps.offset : -8;
      const topResizeHandleStyle = {
        ...handleProps == null ? void 0 : handleProps.style,
        top: `${offset}px`,
        height: (handleProps == null ? void 0 : handleProps.size) || "16px"
      };
      return React.createElement("div", { className: styles$V["top-resize-handle"], onMouseDown: resizeHandler, style: topResizeHandleStyle });
    }
    const Box = React.forwardRef(function Box2({ style, className, as = "div", children, width = "100%", minWidth, maxWidth, height = "100%", minHeight, maxHeight, zIndex = 0, padding: padding2, paddingInline, paddingBlock, overflow, enableResizeOnTop = false, enableResizeOnEnd = false, enableResizeOnBottom = false, enableResizeOnStart = false, enableResizeOnLeft = false, enableResizeOnRight = false, onWidthResize, onHeightResize, onWidthResizeEnd, onHeightResizeEnd, handleProps, ...otherProps }, ref) {
      const As = as;
      const boxRef = reactExports.useRef(null);
      const forkedRef = useForkRef(ref, boxRef);
      const hasResizing = enableResizeOnBottom || enableResizeOnEnd || enableResizeOnStart || enableResizeOnTop || enableResizeOnLeft || enableResizeOnRight;
      const propStyles = {
        width,
        minWidth,
        maxWidth,
        height,
        minHeight,
        maxHeight,
        padding: padding2,
        paddingInline,
        paddingBlock,
        overflow,
        zIndex
      };
      return React.createElement(
        As,
        { "data-enabled-resize-on-start": String(enableResizeOnStart), "data-enabled-resize-on-end": String(enableResizeOnEnd), "data-enabled-resize-on-top": String(enableResizeOnTop), "data-enabled-resize-on-bottom": String(enableResizeOnBottom), "data_enabled-resize-on-left": String(enableResizeOnLeft), "data_enabled-resize-on-right": String(enableResizeOnRight), ref: forkedRef, style: {
          position: "relative",
          flexShrink: 0,
          flexGrow: 0,
          boxSizing: "border-box",
          // Firefox has a bug with backdrop filter and translateZ.
          // So we only want to turn this on if somebody wants to enable resizing.
          // Otherwise other ui components break when composed within a box.
          transform: hasResizing ? "translateZ(0)" : "none",
          ...propStyles,
          ...style
        }, className, ...otherProps },
        children,
        enableResizeOnTop && React.createElement(TopResizeHandle, { onHeightResize, onHeightResizeEnd, targetRef: boxRef, handleProps }),
        enableResizeOnBottom && React.createElement(BottomResizeHandle, { onHeightResize, onHeightResizeEnd, targetRef: boxRef, handleProps }),
        enableResizeOnStart && React.createElement(StartResizeHandle, { onWidthResize, onWidthResizeEnd, targetRef: boxRef, handleProps }),
        enableResizeOnEnd && React.createElement(EndResizeHandle, { onWidthResize, onWidthResizeEnd, targetRef: boxRef, handleProps }),
        enableResizeOnLeft && React.createElement(LeftResizeHandle, { onWidthResize, onWidthResizeEnd, targetRef: boxRef, handleProps }),
        enableResizeOnRight && React.createElement(RightResizeHandle, { onWidthResize, onWidthResizeEnd, targetRef: boxRef, handleProps })
      );
    });
    const flexBox = `_flex-box_2b136c5`;
    const styles$U = { "flex-box": flexBox };
    const FlexBox = React.forwardRef(function FillBox({ growWeight, shrinkWeight, children, minWidth, width, maxWidth, minHeight, height, maxHeight, style, className, zIndex, ...props }, ref) {
      const fillBoxRef = reactExports.useRef(null);
      const forkedRef = useForkRef(ref, fillBoxRef);
      return React.createElement("div", { ref: forkedRef, "data-height": height, "data-width": height, className: classNames(className, styles$U["flex-box"], "stack-flex-box"), style: {
        flexGrow: growWeight,
        flexShrink: shrinkWeight,
        minHeight,
        height,
        maxHeight,
        minWidth,
        width,
        maxWidth,
        zIndex,
        ...style
      }, ...props }, children);
    });
    function removeUndefinedProperties(obj) {
      const result = {};
      Object.keys(obj).forEach((k) => {
        if (typeof obj[k] !== "undefined") {
          result[k] = obj[k];
        }
      });
      return result;
    }
    const hStack = `_h-stack_387ef68`;
    const styles$T = { "h-stack": hStack };
    const HStack = React.forwardRef(function HStack2({ as = "div", children, style, className, horizontalAlignment = "start", verticalAlignment = "center", inline, allowFlow, width, minWidth, maxWidth, height, minHeight, maxHeight, padding: padding2, paddingBlock, paddingInline, paddingInlineStart, paddingInlineEnd, paddingTop, paddingBottom, margin, marginBlock, marginInline, marginInlineStart, marginInlineEnd, marginTop, marginBottom, zIndex, overflowX, overflowY, flex, gap, rowGap, columnGap, ...attr }, ref) {
      const As = as;
      const defaultStyles = {
        minWidth,
        width,
        maxWidth,
        minHeight,
        height,
        maxHeight,
        zIndex,
        overflowX,
        overflowY,
        padding: padding2,
        paddingBlock,
        paddingInline,
        paddingInlineStart,
        paddingInlineEnd,
        paddingTop,
        paddingBottom,
        margin,
        marginBlock,
        marginInline,
        marginInlineStart,
        marginInlineEnd,
        marginTop,
        marginBottom,
        gap,
        rowGap,
        columnGap
      };
      const finalStyles = {
        ...removeUndefinedProperties(defaultStyles),
        ...style
      };
      return React.createElement(As, { ref, className: classNames(className, styles$T["h-stack"], flex && "stack-flex-box"), style: finalStyles, "data-inline": Boolean(inline), "data-allow-flow": Boolean(allowFlow), "data-v-alignment": verticalAlignment, "data-h-alignment": horizontalAlignment, ...attr }, children);
    });
    const Spacer = React.forwardRef(function Spacer2({ width = "auto", height = "auto", fullHeight = false, fullWidth = false, fillSpaceWeight = 1, style, className }, ref) {
      const flex = width === "auto" && height === "auto" ? fillSpaceWeight : void 0;
      const finalWidth = fullWidth ? "100%" : width;
      const finalHeight = fullHeight ? "100%" : height;
      return React.createElement("div", { ref, style: {
        ...style,
        position: "relative",
        width: finalWidth,
        minWidth: finalWidth,
        height: finalHeight,
        minHeight: finalHeight,
        overflow: "hidden",
        pointerEvents: "none",
        zIndex: 1,
        flex
      }, className });
    });
    const vStack = `_v-stack_97b2e87`;
    const styles$S = { "v-stack": vStack };
    const VStack = React.forwardRef(function VStack2({ as = "div", children, style, className, horizontalAlignment = "center", verticalAlignment = "start", inline, allowFlow, width, minWidth, maxWidth, height, minHeight, maxHeight, padding: padding2, paddingBlock, paddingInline, paddingInlineStart, paddingInlineEnd, paddingTop, paddingBottom, margin, marginBlock, marginInline, marginInlineStart, marginInlineEnd, marginTop, marginBottom, zIndex, overflowY, overflowX, flex, gap, rowGap, columnGap, ...attr }, ref) {
      const As = as;
      const defaultStyles = {
        display: inline == null ? void 0 : inline ? "inline-flex" : "flex",
        minWidth,
        width,
        maxWidth,
        minHeight,
        height,
        maxHeight,
        zIndex,
        overflowX,
        overflowY,
        padding: padding2,
        paddingBlock,
        paddingInline,
        paddingInlineStart,
        paddingInlineEnd,
        paddingTop,
        paddingBottom,
        margin,
        marginBlock,
        marginInline,
        marginInlineStart,
        marginInlineEnd,
        marginTop,
        marginBottom,
        gap,
        rowGap,
        columnGap
      };
      const finalStyles = {
        ...removeUndefinedProperties(defaultStyles),
        ...style
      };
      return React.createElement(As, { ref, className: classNames(className, styles$S["v-stack"], flex && "stack-flex-box"), style: finalStyles, "data-inline": Boolean(inline), "data-allow-flow": Boolean(allowFlow), "data-v-alignment": verticalAlignment, "data-h-alignment": horizontalAlignment, ...attr }, children);
    });
    const zStack = `_z-stack_f623b5e`;
    const styles$R = { "z-stack": zStack };
    const ZStack = React.forwardRef(function ZStack2({ as = "div", children, style, horizontalAlignment = "center", verticalAlignment = "center", inline, width, minWidth, maxWidth, height, minHeight, maxHeight, padding: padding2, paddingBlock, paddingInline, paddingInlineStart, paddingInlineEnd, paddingTop, paddingBottom, margin, marginBlock, marginInline, marginInlineStart, marginInlineEnd, marginTop, marginBottom, zIndex, className, overflow, flex, ...attr }, ref) {
      const As = as;
      const defaultStyles = {
        minWidth,
        width,
        maxWidth,
        minHeight,
        height,
        maxHeight,
        zIndex,
        overflow,
        padding: padding2,
        paddingBlock,
        paddingInline,
        paddingInlineStart,
        paddingInlineEnd,
        paddingTop,
        paddingBottom,
        margin,
        marginBlock,
        marginInline,
        marginInlineStart,
        marginInlineEnd,
        marginTop,
        marginBottom
      };
      return React.createElement(As, { ref, style: {
        ...removeUndefinedProperties(defaultStyles),
        ...style
      }, className: classNames(className, styles$R["z-stack"], flex && "stack-flex-box"), "data-inline": Boolean(inline), "data-v-alignment": verticalAlignment, "data-h-alignment": horizontalAlignment, ...attr }, typeof children === "string" ? React.createElement("span", null, children) : children);
    });
    var Status;
    (function(Status2) {
      Status2["INITIAL"] = "initial";
      Status2["PENDING"] = "pending";
      Status2["ERROR"] = "error";
      Status2["SUCCESS"] = "success";
    })(Status || (Status = {}));
    class Signal {
      /**
       * Constructs a new `Signal`.
       * @param initialValue The initial value of the signal.
       */
      constructor(initialValue) {
        __publicField(this, "_version", 0);
        __publicField(this, "_value");
        __publicField(this, "subscriptions", []);
        this._value = initialValue;
      }
      get version() {
        return this._version;
      }
      get broadcast() {
        return this;
      }
      get() {
        return this._value;
      }
      set(value2) {
        this._value = value2;
        this._version++;
        this._notify(value2);
      }
      _notify(value2) {
        let potentialError = null;
        const invalidSubscriptions = [];
        this.subscriptions.forEach((subscriptionRef) => {
          const subscription = subscriptionRef.deref();
          if (subscription != null) {
            try {
              subscription.callback(value2);
            } catch (e) {
              if (potentialError == null) {
                potentialError = e;
              }
            }
          } else {
            invalidSubscriptions.push(subscriptionRef);
          }
        });
        invalidSubscriptions.forEach((s) => this._unsubscribe(s));
        if (potentialError != null) {
          throw potentialError;
        }
      }
      transform(cb) {
        const value2 = cb(this._value);
        this.set(value2);
      }
      subscribe(callback) {
        const subscription = {
          startTime: Date.now(),
          callback,
          unsubscribe: () => {
            this._unsubscribe(subscriptionRef);
          }
        };
        const subscriptionRef = new WeakRef(subscription);
        this.subscriptions.push(subscriptionRef);
        return subscription;
      }
      _unsubscribe(subscriber) {
        const index = this.subscriptions.indexOf(subscriber);
        if (index > -1) {
          this.subscriptions.splice(index, 1);
        }
      }
      dispose() {
        this.disposeCallbacks();
      }
      disposeCallbacks() {
        this.subscriptions.length = 0;
      }
    }
    const updateReducer = (num) => (num + 1) % 1e6;
    const useUpdate = () => {
      const [, update] = reactExports.useReducer(updateReducer, 0);
      return update;
    };
    function useSignalValue(broadcast) {
      const update = useUpdate();
      const versionRef = reactExports.useRef(broadcast.version);
      reactExports.useLayoutEffect(() => {
        const subscription = broadcast.subscribe(update);
        if (versionRef.current !== broadcast.version) {
          update();
        }
        return () => subscription.unsubscribe();
      }, [broadcast, update]);
      return broadcast.get();
    }
    function useSignalValueEffect(callback, broadcast) {
      const callbackRef = reactExports.useRef(callback);
      const version = reactExports.useRef(broadcast.version);
      reactExports.useLayoutEffect(() => {
        callbackRef.current = callback;
      }, [callback]);
      reactExports.useLayoutEffect(() => {
        const subscription = broadcast.subscribe((value2) => {
          callbackRef.current(value2);
        });
        if (version.current !== broadcast.version) {
          callbackRef.current(broadcast.get());
        }
        return () => {
          subscription.unsubscribe();
        };
      }, [broadcast]);
      reactExports.useLayoutEffect(() => {
        callbackRef.current(broadcast.get());
      }, [broadcast]);
    }
    const gridItem = `_grid-item_6058f1d`;
    const styles$Q = { "grid-item": gridItem };
    function GridElement({ child, item, presenter: masonryLayoutEngine }) {
      const ref = reactExports.useRef(null);
      const resizeRef = useResizeObserver((_, height) => {
        const currentHeight = item.height;
        const isHeightDifferent = currentHeight !== height;
        if (isHeightDifferent) {
          masonryLayoutEngine.setItemHeight(item.index, height);
        }
      }, TriggerConfig.Height);
      const forkedRef = useForkRef(ref, resizeRef, child.props.ref);
      const { style: originalStyle, className, ...props } = child.props;
      const style = {
        "--grid-item-width": `${item.width}px`,
        "--grid-item-x": `${item.left}px`,
        "--grid-item-y": `${item.top}px`
      };
      return React.cloneElement(child, {
        ...props,
        style: {
          ...originalStyle,
          ...style
        },
        className: classNames(className, styles$Q["grid-item"]),
        key: item.index,
        ref: forkedRef
      });
    }
    const virtualizedGrid = `_virtualized-grid_f56373f`;
    const virtualizedGridContent = `_virtualized-grid-content_ccec1b8`;
    const styles$P = { "virtualized-grid": virtualizedGrid, "virtualized-grid-content": virtualizedGridContent };
    const defaultRender = () => React.createElement("div", null);
    const VirtualizedGrid = React.forwardRef(function VirtualizedGrid2({ as = "div", alignment = "center", minWidth, width, maxWidth, minHeight, height, maxHeight, renderItem = defaultRender, style, className, onScroll, children, presenter: presenter2, ...props }, ref) {
      useSignalValue(presenter2.isDirtyBroadcast);
      const visibleItems = presenter2.visibleItems;
      const As = as;
      const gridStyles = {
        minWidth,
        width,
        maxWidth,
        minHeight,
        height,
        maxHeight
      };
      const resizeRef = useResizeObserver((_width, _height, entry) => {
        const { inlineSize: width2, blockSize: height2 } = entry.contentBoxSize[0];
        presenter2.setViewportSize(width2, height2);
      }, TriggerConfig.Both);
      const forkedRef = useForkRef(ref, resizeRef);
      const contentStyle = {
        height: `${presenter2.getHeight()}px`,
        width: `${presenter2.getWidth()}px`
      };
      function updateViewport(e) {
        const top2 = e.currentTarget.scrollTop;
        presenter2.setViewportOffset(top2);
        onScroll && onScroll(e);
      }
      window.grid = presenter2;
      reactExports.useLayoutEffect(() => {
        presenter2.refreshLayout();
      }, [presenter2]);
      return React.createElement(
        As,
        { ref: forkedRef, style: {
          ...style,
          ...gridStyles
        }, className: classNames(className, styles$P["virtualized-grid"]), onScroll: updateViewport, ...props },
        React.createElement("div", { className: styles$P["virtualized-grid-content"], "data-alignment": alignment, style: contentStyle }, visibleItems.map((item) => {
          const child = renderItem(item, item.index);
          return React.createElement(GridElement, { key: item.index, child, item, presenter: presenter2 });
        })),
        children
      );
    });
    function binarySearch(array, lookFor, compareFunc) {
      let lowerBound = 0;
      let upperBound = array.length - 1;
      while (lowerBound <= upperBound) {
        const checkIndex = Math.floor((upperBound + lowerBound) / 2);
        const result = compareFunc(array[checkIndex], lookFor);
        if (result > 0) {
          lowerBound = checkIndex + 1;
          if (lowerBound > upperBound) {
            return upperBound;
          }
        } else if (result < 0) {
          upperBound = checkIndex - 1;
          if (upperBound < lowerBound) {
            return lowerBound;
          }
        } else {
          return checkIndex;
        }
      }
      return -1;
    }
    class GridColumn {
      constructor(index = 0, offset = 0) {
        __publicField(this, "_items", []);
        __publicField(this, "_itemsWithinRange", []);
        __publicField(this, "_bottom", 0);
        __publicField(this, "_right", 0);
        __publicField(this, "index");
        __publicField(this, "offset");
        this.index = index;
        this.offset = offset;
      }
      get bottom() {
        return this._bottom;
      }
      get right() {
        return this._right;
      }
      clear() {
        this._items.length = 0;
        this._bottom = 0;
      }
      clearFromIndex(index) {
        const itemsIndex = binarySearch(this._items, index, this._indexCompare);
        if (itemsIndex > -1) {
          const fromIndex = this._items[itemsIndex].index;
          if (fromIndex < index) {
            this._items.splice(itemsIndex + 1);
          } else {
            this._items.splice(itemsIndex);
          }
        }
        if (this._items.length > 0) {
          const item = this._items[this._items.length - 1];
          this._bottom = item.bottom;
          this._right = item.right;
        } else {
          this._bottom = 0;
          this._right = 0;
        }
      }
      _indexCompare(item, position) {
        if (position < item.index) {
          return -1;
        }
        if (position > item.index + 1) {
          return 1;
        }
        return 0;
      }
      add(item) {
        this._items.push(item);
        this._bottom = item.bottom;
        this._right = Math.max(item.right, this._right);
      }
      getItemsWithinRange(top2, bottom) {
        this._itemsWithinRange.length = 0;
        if (this._items.length === 0) {
          return this._itemsWithinRange;
        }
        const firstIndex = binarySearch(this._items, top2, this._compare);
        const lastIndex = binarySearch(this._items, bottom, this._compare);
        for (let i = firstIndex; i <= lastIndex; i++) {
          this._itemsWithinRange.push(this._items[i]);
        }
        return this._itemsWithinRange;
      }
      _compare(item, position) {
        if (position < item.top) {
          return -1;
        }
        if (position > item.bottom) {
          return 1;
        }
        return 0;
      }
    }
    class ItemFactory {
      constructor() {
        __publicField(this, "availableInstances", []);
        __publicField(this, "usedInstances", []);
      }
      useInstance() {
        let instance;
        const availableInstances = this.availableInstances;
        if (availableInstances.length === 0) {
          instance = {
            index: 0,
            top: 0,
            right: 0,
            bottom: 0,
            left: 0,
            width: 0,
            height: 100,
            column: 0,
            value: null
          };
        } else {
          instance = availableInstances.pop();
          instance.index = 0;
          instance.top = 0;
          instance.right = 0;
          instance.bottom = 0;
          instance.left = 0;
          instance.width = 0;
          instance.height = 100;
          instance.column = 0;
          instance.value = null;
        }
        this.usedInstances.push(instance);
        return instance;
      }
      releaseInstance(instance) {
        const index = this.usedInstances.indexOf(instance);
        if (index > -1) {
          this.usedInstances.splice(index, 1);
        }
      }
      releaseAll() {
        const usedInstances = this.usedInstances;
        const length = usedInstances.length;
        for (let x = 0; x < length; x++) {
          this.availableInstances.push(this.usedInstances[x]);
        }
        this.usedInstances.length = 0;
      }
    }
    class VirtualizedGridPresenter {
      constructor(options = {}) {
        __publicField(this, "_values");
        __publicField(this, "_gap");
        __publicField(this, "_height");
        __publicField(this, "_minColumnWidth");
        __publicField(this, "_maxColumnWidth");
        __publicField(this, "_columnsWidth");
        __publicField(this, "_columnAmount");
        __publicField(this, "_itemFactory");
        __publicField(this, "_gridItems");
        __publicField(this, "_isDirty");
        __publicField(this, "_columns");
        __publicField(this, "_viewport");
        __publicField(this, "_visibleItems");
        __publicField(this, "_maxColumnAmount");
        __publicField(this, "_minColumnAmount");
        this._gap = 0;
        this._height = 0;
        this._columnsWidth = 0;
        this._columnAmount = 1;
        this._viewport = {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0,
          width: 0,
          height: 0
        };
        this._itemFactory = new ItemFactory();
        this._gridItems = [];
        this._isDirty = new Signal(false);
        this._columns = [];
        this._visibleItems = [];
        this._gap = defaultValue(options.gap, 0);
        this._maxColumnAmount = defaultValue(options.maxColumnAmount, Infinity);
        this._minColumnAmount = defaultValue(options.minColumnAmount, 1);
        this._maxColumnWidth = defaultValue(options.maxColumnWidth, Infinity);
        this._minColumnWidth = defaultValue(options.minColumnWidth, 100);
        this._values = defaultValue(options.values, []);
        this._updateGridItems(this._values);
      }
      get isDirtyBroadcast() {
        return this._isDirty;
      }
      get columns() {
        return this._columns;
      }
      get viewport() {
        return this._viewport;
      }
      get visibleItems() {
        return this._visibleItems;
      }
      setMinColumnWidth(value2) {
        value2 = Math.min(Math.max(value2, 1), this._maxColumnWidth);
        this._minColumnWidth = value2;
        this.refreshLayout();
      }
      setMaxColumnWidth(value2) {
        value2 = Math.max(this._minColumnWidth, value2);
        this._maxColumnWidth = value2;
        this.refreshLayout();
      }
      setMinColumnAmount(amount) {
        this._minColumnAmount = Math.max(amount, 1);
        this.refreshLayout();
      }
      setMaxColumnAmount(amount) {
        this._maxColumnAmount = Math.max(amount, this._minColumnAmount);
        this.refreshLayout();
      }
      setValues(values) {
        this._values = values;
        this._updateGridItems(values);
        this.refreshLayout();
      }
      setGap(value2) {
        this._gap = value2;
        this.refreshLayout();
      }
      refreshLayout() {
        this._updateColumnData();
        this.reflow();
      }
      _updateGridItems(values) {
        const length = values.length;
        const items = this._gridItems;
        if (length > items.length) {
          const amount = length - items.length;
          for (let i = 0; i < amount; i++) {
            const item = this._itemFactory.useInstance();
            item.height = 100;
            items.push(item);
          }
        } else {
          while (items.length > length) {
            const instance = items.pop();
            this._itemFactory.releaseInstance(instance);
          }
        }
        return items;
      }
      setItemHeight(index, height) {
        const items = this._gridItems;
        const isWithinBounds = index < items.length && index >= 0;
        if (isWithinBounds) {
          const item = items[index];
          const oldHeight = item.height;
          const hasChanged = oldHeight !== height;
          if (hasChanged) {
            item.height = height;
            this.reflow(index);
          }
        }
      }
      setViewportSize(width, height) {
        if (this._viewport.width === width && this._viewport.height === height) {
          return;
        }
        const minColumnWidth = Math.max(this._minColumnWidth, 100);
        const boundedHeight = Math.max(height, 100);
        const boundedWidth = Math.max(width, this._gap + minColumnWidth + this._gap);
        this._viewport.width = boundedWidth;
        this._viewport.height = boundedHeight;
        this._viewport.bottom = this._viewport.top + boundedHeight;
        this._viewport.right = boundedWidth;
        this._viewport.left = 0;
        this.refreshLayout();
      }
      setViewportOffset(offset) {
        this.viewport.top = offset;
        this._viewport.bottom = offset + this.viewport.height;
        this._updateVisibleItems();
        this._isDirty.set(true);
      }
      _updateVisibleItems() {
        this._visibleItems.length = 0;
        for (let i = 0; i < this._columns.length; i++) {
          const items = this._columns[i].getItemsWithinRange(this._viewport.top - this._viewport.height / 2, this._viewport.bottom + this._viewport.height / 2);
          for (let x = 0; x < items.length; x++) {
            this._visibleItems.push(items[x]);
          }
        }
      }
      _updateColumnData() {
        const estimatedColumnAmount = Math.floor((this._viewport.width - this._gap) / (this._minColumnWidth + this._gap));
        const lowerBoundAmount = Math.max(estimatedColumnAmount, this._minColumnAmount);
        this._columnAmount = Math.min(lowerBoundAmount, this._maxColumnAmount);
        if (this._columnAmount > this._gridItems.length) {
          this._columnAmount = this._gridItems.length;
        }
        const allGaps = this._columnAmount * this._gap + this._gap;
        const estimatedWidth = Math.floor((this._viewport.width - allGaps) / this._columnAmount);
        const lowerBoundedWidth = isNaN(estimatedWidth) ? this._minColumnWidth : Math.max(this._minColumnWidth, estimatedWidth);
        this._columnsWidth = Math.min(lowerBoundedWidth, this._maxColumnWidth);
        let offset = this._gap;
        this._columns.length = 0;
        for (let i = 0; i < this._columnAmount; i++) {
          const column = new GridColumn(i, offset);
          this._columns.push(column);
          offset += this._columnsWidth + this._gap;
        }
      }
      reflow(fromIndex = 0) {
        const hasNoDimension = this._viewport.width === 0 || this._viewport.height === 0;
        const isBeyondBounds = fromIndex >= this._gridItems.length;
        if (hasNoDimension || isBeyondBounds) {
          return;
        }
        const items = this._gridItems;
        this._clearColumnsFromIndex(fromIndex);
        for (let i = fromIndex; i < items.length; i++) {
          const item = items[i];
          const shortestColumn = this._getShortestColumn();
          const top2 = shortestColumn.bottom + this._gap;
          item.index = i;
          item.top = top2;
          item.left = shortestColumn.offset;
          item.right = item.left + this._columnsWidth;
          item.bottom = item.top + item.height;
          item.column = shortestColumn.index;
          item.width = this._columnsWidth;
          item.value = this._values[i];
          this._columns[item.column].add(item);
        }
        this._height = Math.max(0, ...this._columns.map((c) => c.bottom + this._gap));
        this._updateVisibleItems();
        this._isDirty.set(true);
      }
      _clearColumnsFromIndex(index) {
        for (let i = 0; i < this._columns.length; i++) {
          this._columns[i].clearFromIndex(index);
        }
      }
      _getShortestColumn() {
        const length = this._columns.length;
        let selectedColumn = this._columns[0];
        for (let x = 1; x < length; x++) {
          const column = this._columns[x];
          if (selectedColumn.bottom > column.bottom) {
            selectedColumn = column;
          }
        }
        if (selectedColumn == null) {
          throw Error("Cannot find column.");
        }
        return selectedColumn;
      }
      getColumnWidth() {
        return this._columnsWidth;
      }
      getHeight() {
        return this._height;
      }
      getWidth() {
        if (this._columns.length === 0) {
          return 0;
        }
        return this._columns[this._columns.length - 1].right + this._gap;
      }
    }
    React.forwardRef(function Grid({ children, alignment, gap, minColumnWidth, maxColumnWidth, minColumnAmount, maxColumnAmount, ...props }, ref) {
      const [presenter2] = reactExports.useState(() => new VirtualizedGridPresenter());
      const childrenArray = React.Children.toArray(children);
      reactExports.useLayoutEffect(() => {
        if (gap == null) {
          presenter2.setGap(0);
        } else {
          presenter2.setGap(gap);
        }
      }, [gap, presenter2]);
      reactExports.useLayoutEffect(() => {
        if (minColumnWidth == null) {
          presenter2.setMinColumnWidth(0);
        } else {
          presenter2.setMinColumnAmount(minColumnWidth);
        }
      }, [minColumnWidth, presenter2]);
      reactExports.useLayoutEffect(() => {
        if (maxColumnWidth == null) {
          presenter2.setMaxColumnWidth(Infinity);
        } else {
          presenter2.setMaxColumnWidth(maxColumnWidth);
        }
      }, [maxColumnWidth, presenter2]);
      reactExports.useLayoutEffect(() => {
        if (minColumnAmount == null) {
          presenter2.setMinColumnAmount(0);
        } else {
          presenter2.setMinColumnAmount(minColumnAmount);
        }
      }, [minColumnAmount, presenter2]);
      reactExports.useLayoutEffect(() => {
        if (maxColumnAmount == null) {
          presenter2.setMaxColumnAmount(Infinity);
        } else {
          presenter2.setMaxColumnAmount(maxColumnAmount);
        }
      }, [maxColumnAmount, presenter2]);
      reactExports.useLayoutEffect(() => {
        presenter2.setValues(childrenArray);
      }, [presenter2, childrenArray]);
      return React.createElement(VirtualizedGrid, { ref, alignment, presenter: presenter2, renderItem: (item) => {
        return childrenArray[item.index];
      }, ...props });
    });
    const VirtualizedList = React.forwardRef(function VirtualizedList2(props, ref) {
      return React.createElement(VirtualizedGrid, { ref, ...props });
    });
    class VirtualizedListPresenter extends VirtualizedGridPresenter {
      constructor({ minWidth, maxWidth, ...options } = {}) {
        super({
          ...options,
          minColumnAmount: 1,
          maxColumnAmount: 1,
          minColumnWidth: minWidth,
          maxColumnWidth: maxWidth
        });
      }
    }
    React.forwardRef(function List({ children, alignment, gap, minWidth, maxWidth, ...props }, ref) {
      const [presenter2] = reactExports.useState(() => new VirtualizedListPresenter());
      const childrenArray = React.Children.toArray(children);
      reactExports.useLayoutEffect(() => {
        if (gap == null) {
          presenter2.setGap(0);
        } else {
          presenter2.setGap(gap);
        }
      }, [gap, presenter2]);
      reactExports.useLayoutEffect(() => {
        if (minWidth == null) {
          presenter2.setMinColumnWidth(0);
        } else {
          presenter2.setMinColumnAmount(minWidth);
        }
      }, [minWidth, presenter2]);
      reactExports.useLayoutEffect(() => {
        if (maxWidth == null) {
          presenter2.setMaxColumnWidth(Infinity);
        } else {
          presenter2.setMaxColumnWidth(maxWidth);
        }
      }, [maxWidth, presenter2]);
      reactExports.useLayoutEffect(() => {
        presenter2.setValues(childrenArray);
      }, [presenter2, childrenArray]);
      return React.createElement(VirtualizedList, { ref, alignment, presenter: presenter2, renderItem: (item) => {
        const child = childrenArray[item.index];
        return child;
      }, ...props });
    });
    const StyleBox = React.forwardRef(function StyleBox2({ minWidth, width = "100%", maxWidth, minHeight, height = "100%", maxHeight, children, className, style, tabIndex, ...props }, ref) {
      return React.createElement("div", { tabIndex, ref, style: {
        minWidth,
        width,
        maxWidth,
        minHeight,
        height,
        maxHeight,
        ...props,
        ...style
      }, className }, children);
    });
    React.forwardRef(function Circle2(props, ref) {
      return React.createElement(StyleBox, { ref, borderRadius: "50%", ...props });
    });
    React.forwardRef(function Line(props, ref) {
      return React.createElement(StyleBox, { ref, background: "black", height: "10px", borderRadius: "4px", ...props });
    });
    var reactDomExports = requireReactDom();
    class PortalPresenter {
      constructor(win = window, zIndex = "auto") {
        __publicField(this, "_window");
        __publicField(this, "div");
        __publicField(this, "hasMounted", false);
        this._window = win;
        this.div = this._window.document.createElement("div");
        this.div.className = "portal";
        this.setZIndex(zIndex);
      }
      setZIndex(zIndex = "auto") {
        if (this.div != null) {
          this.div.style.zIndex = zIndex.toString();
        }
      }
      render(children) {
        if (this.div == null) {
          return null;
        }
        return reactDomExports.createPortal(children, this.div);
      }
    }
    class PortalPlatform {
      constructor(win = window, root2 = win.document.body) {
        __publicField(this, "_window");
        __publicField(this, "_root");
        __publicField(this, "_portals", []);
        __publicField(this, "platform");
        this._window = win;
        this._root = root2;
        this.platform = this._getPlatformRoot();
        this.platform.classList.add("platform-root");
      }
      _getPlatformRoot() {
        const existingPlatformRoot = this._window.document.body.querySelector(".platform-root");
        if (!existingPlatformRoot) {
          const root2 = this._window.document.createElement("div");
          const portalPlatform = this._window.document.createElement("div");
          portalPlatform.id = "portal-platform";
          portalPlatform.classList.add("portal-platform");
          root2.appendChild(portalPlatform);
          return root2;
        } else {
          return existingPlatformRoot;
        }
      }
      setZIndex(zIndex = "auto") {
        if (this.platform != null) {
          this.platform.style.zIndex = zIndex.toString();
        }
      }
      setRoot(root2) {
        var _a2, _b;
        if (root2 !== this._root) {
          (_b = (_a2 = this.platform) == null ? void 0 : _a2.parentNode) == null ? void 0 : _b.removeChild(this.platform);
          this._root = root2 == null ? document.body : root2;
          this.showPlatform();
        }
      }
      createPortal() {
        const portal = new PortalPresenter(this._window);
        this._portals.push(portal);
        return portal;
      }
      mountPortal(portal) {
        var _a2;
        portal.hasMounted = true;
        (_a2 = this.platform.firstElementChild) == null ? void 0 : _a2.appendChild(portal.div);
        this.showPlatform();
      }
      unmountPortal(portal) {
        this.removePortal(portal);
      }
      removePortal(portal) {
        var _a2;
        const index = this._portals.indexOf(portal);
        if (index > -1) {
          portal.hasMounted = false;
          this._portals.splice(index, 1);
          (_a2 = this.platform.firstElementChild) == null ? void 0 : _a2.removeChild(portal.div);
          this.hidePlatformIfNecessary();
        }
      }
      showPlatform() {
        if (this.platform != null && this.platform.parentElement == null) {
          this._root.appendChild(this.platform);
        }
      }
      hidePlatformIfNecessary() {
        if (this._portals.length === 0 && this.platform.parentElement != null) {
          this._root.removeChild(this.platform);
        }
      }
      dispose() {
        if (this.platform != null && this._root.contains(this.platform)) {
          this._root.removeChild(this.platform);
        }
      }
    }
    const defaultPlatform = new PortalPlatform();
    const PortalPlatformContext = React.createContext(defaultPlatform);
    PortalPlatformContext.Provider;
    function usePortalPlatform() {
      return reactExports.useContext(PortalPlatformContext);
    }
    const Portal = ({ children, zIndex }) => {
      const portalPlatform = usePortalPlatform();
      const [portal] = reactExports.useState(() => {
        return portalPlatform.createPortal();
      });
      reactExports.useLayoutEffect(() => {
        portal.setZIndex(zIndex);
      }, [portal, zIndex]);
      reactExports.useLayoutEffect(() => {
        portalPlatform.mountPortal(portal);
        return () => portalPlatform.unmountPortal(portal);
      }, [portal, portalPlatform]);
      return portal.render(children);
    };
    const popover$2 = `_popover_abf288d`;
    const popoverVeil = `_popover-veil_cf97091`;
    const styles$O = { popover: popover$2, "popover-veil": popoverVeil };
    function Popover({ anchorElement, verticalAnchor = "bottom", verticalOrigin = "top", verticalOffset = 0, horizontalAnchor = "start", horizontalOrigin = "start", horizontalOffset = 0, restoreFocus = false, veil = false, open, onClose, children }) {
      const anchorElementRef = reactExports.useRef(anchorElement);
      const [position, setPosition] = reactExports.useState({ top: 0, left: 0 });
      const activeElementRef = reactExports.useRef(null);
      const popoverRef = reactExports.useRef(null);
      const canOpen = open && anchorElement != null;
      function close() {
        onClose && onClose();
      }
      const updatePosition = () => {
        if (!anchorElement || !popoverRef.current)
          return;
        const anchorRect = anchorElement.getBoundingClientRect();
        const popoverRect = popoverRef.current.getBoundingClientRect();
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const computedStyle = getComputedStyle(anchorElement);
        const isRtl = computedStyle.direction === "rtl";
        let top2 = anchorRect.top;
        let left2 = anchorRect.left;
        switch (verticalAnchor) {
          case "top":
            top2 += verticalOffset;
            break;
          case "center":
            top2 += anchorRect.height / 2;
            break;
          case "bottom":
            top2 += anchorRect.height - verticalOffset;
            break;
        }
        switch (verticalOrigin) {
          case "top":
            break;
          case "center":
            top2 -= popoverRect.height / 2;
            break;
          case "bottom":
            top2 -= popoverRect.height;
            break;
        }
        if (horizontalAnchor === "start") {
          left2 += isRtl ? anchorRect.width + horizontalOffset : horizontalOffset;
        } else if (horizontalAnchor === "center") {
          left2 += anchorRect.width / 2;
        } else if (horizontalAnchor === "end") {
          left2 += isRtl ? -horizontalOffset : anchorRect.width + horizontalOffset;
        }
        let adjustedHorizontalOrigin = horizontalOrigin;
        if (isRtl) {
          if (horizontalOrigin === "start") {
            adjustedHorizontalOrigin = "end";
          } else if (horizontalOrigin === "end") {
            adjustedHorizontalOrigin = "start";
          }
        }
        if (adjustedHorizontalOrigin === "start") ;
        else if (adjustedHorizontalOrigin === "center") {
          left2 -= popoverRect.width / 2;
        } else if (adjustedHorizontalOrigin === "end") {
          left2 -= popoverRect.width;
        }
        if (left2 + popoverRect.width > viewportWidth) {
          left2 = viewportWidth - popoverRect.width;
        }
        if (left2 < 0) {
          left2 = 0;
        }
        if (top2 + popoverRect.height > viewportHeight) {
          top2 = viewportHeight - popoverRect.height;
        }
        if (top2 < 0) {
          top2 = 0;
        }
        if (top2 !== position.top || left2 !== position.left) {
          setPosition({ top: top2, left: left2 });
        }
      };
      reactExports.useLayoutEffect(() => {
        updatePosition();
        window.addEventListener("resize", updatePosition);
        return () => {
          window.removeEventListener("resize", updatePosition);
        };
      });
      reactExports.useLayoutEffect(() => {
        if (open) {
          activeElementRef.current = window.document.activeElement;
        } else {
          const restoreToElement = activeElementRef.current;
          requestAnimationFrame(() => {
            restoreFocus && (restoreToElement == null ? void 0 : restoreToElement.focus());
          });
        }
      }, [open, restoreFocus]);
      if (!canOpen) {
        return null;
      }
      anchorElementRef.current = anchorElement;
      return React.createElement(
        Portal,
        null,
        veil && React.createElement(
          "div",
          { className: styles$O["popover-veil"] },
          React.createElement(
            ScrollAwayListener,
            { onScrollAway: close },
            React.createElement(
              ClickAwayListener,
              { onClickAway: close, refs: [anchorElementRef] },
              React.createElement("div", { ref: popoverRef, className: styles$O.popover, style: {
                top: `${position.top}px`,
                left: `${position.left}px`
              } }, children)
            )
          )
        ),
        !veil && React.createElement(
          ClickAwayListener,
          { onClickAway: close },
          React.createElement(
            ScrollAwayListener,
            { onScrollAway: close },
            React.createElement("div", { ref: popoverRef, className: styles$O.popover, style: {
              top: `${position.top}px`,
              left: `${position.left}px`
            } }, children)
          )
        )
      );
    }
    const diagram = `_diagram_a292eaf`;
    const styles$N = { diagram };
    function Diagram$1({ presenter: presenter2, onPatternClick }) {
      const ref = reactExports.useRef(null);
      const focusPath = useSignalValue(presenter2.focusNodePathBroadcast);
      useSignalValueEffect((diagrams) => {
        const div = ref.current;
        if (div != null) {
          div.innerHTML = "";
          diagrams.forEach((diagram2) => {
            const wrapper = window.document.createElement("div");
            diagram2.addTo(wrapper);
            div.appendChild(wrapper);
          });
        }
      }, presenter2.diagramsBroadcast);
      function handleClick(event) {
        var _a2, _b;
        let target = event.target;
        while (target.parentElement != null) {
          if (target.id) {
            if (((_a2 = target.parentElement) == null ? void 0 : _a2.dataset["referencePath"]) != null) {
              onPatternClick && onPatternClick((_b = target.parentElement) == null ? void 0 : _b.dataset["referencePath"]);
            } else {
              onPatternClick && onPatternClick(target.id);
            }
            break;
          }
          target = target.parentElement;
        }
      }
      reactExports.useEffect(() => {
        var _a2;
        const div = ref.current;
        if (div != null && focusPath != null) {
          (_a2 = div.querySelector(`.terminal#${focusPath}`)) == null ? void 0 : _a2.scrollIntoView({
            behavior: "smooth",
            block: "center",
            inline: "center"
          });
        }
      }, [focusPath]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { onClick: handleClick, ref, className: styles$N.diagram });
    }
    function Ast({ text }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        StyleBox,
        {
          overflow: "auto",
          backgroundColor: "var(--surface-tertiary-color)",
          fontSize: "16px",
          fontFamily: "'Courier New', Courier, monospace",
          fontWeight: "bold",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { style: { padding: "12px" }, children: text })
        }
      );
    }
    const button$3 = `_button_059b768`;
    const buttonStringLabel = `_button-string-label_3a049f3`;
    const styles$M = { button: button$3, "button-string-label": buttonStringLabel };
    const Button = React.forwardRef(function Button2({ children, className, style, textColor: color, color: backgroundColor, variant = "secondary", onTouchStart, onContextMenu, ...props }, ref) {
      return React.createElement(HStack, { ref, as: "button", inline: true, verticalAlignment: "center", horizontalAlignment: "center", "data-variant": variant, "data-is-disabled": props.disabled || false, className: classNames(styles$M.button, className, "button"), style: { ...style, backgroundColor, color }, onTouchStart: (e) => {
        if (onTouchStart == null) {
          e.preventDefault();
          return;
        }
        onTouchStart(e);
      }, onContextMenu: (e) => {
        if (onContextMenu == null) {
          e.preventDefault();
          return;
        }
        onContextMenu(e);
      }, ...props }, typeof children === "string" ? React.createElement("span", { className: styles$M["button-string-label"] }, children) : children);
    });
    const iconButton$1 = `_icon-button_11360be`;
    const styles$L = { "icon-button": iconButton$1 };
    const IconButton = ({ iconName, title, style, variant = "tertiary", iconSize = "20px", flipOnRtl, width = iconSize, height = iconSize, className, ...props }) => {
      return React.createElement(
        Button,
        { title, variant, width, height, style, className: classNames(styles$L["icon-button"], className, "icon-button"), ...props },
        React.createElement(Icon, { flipOnRtl, name: iconName, size: iconSize })
      );
    };
    const checkboxWrapper = `_checkbox-wrapper_d9eee15`;
    const checkbox = `_checkbox_4042987`;
    const checkboxSvg = `_checkbox-svg_0251a0a`;
    const styles$K = { "checkbox-wrapper": checkboxWrapper, checkbox, "checkbox-svg": checkboxSvg };
    React.forwardRef(function Checkbox({ style, className, width, height, checked, inputRef, onChange, ...props }, ref) {
      return React.createElement(
        ZStack,
        { ref, className: classNames(styles$K["checkbox-wrapper"], "checkbox-wrapper"), "data-is-disabled": props.disabled, width: "15px", height: "15px" },
        React.createElement("input", { "data-checked": checked, "data-is-disabled": props.disabled || false, checked, type: "checkbox", ref: inputRef, onChange: (e) => {
          onChange && onChange(Boolean(e.currentTarget.checked), e);
        }, ...props, className: classNames(className, styles$K.checkbox, "checkbox"), style: { width, height, ...style } }),
        checked && React.createElement(
          "svg",
          { className: classNames(styles$K["checkbox-svg"], "checkbox-svg"), width: "12px", height: "12px", viewBox: "0 0 24 24", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg" },
          React.createElement("path", { d: "M20.5068 5.44714C20.8121 5.72703 20.8328 6.20146 20.5529 6.5068L9.55287 18.5068C9.41464 18.6576 9.22081 18.7454 9.01629 18.7498C8.81178 18.7543 8.61432 18.675 8.46967 18.5303L3.46967 13.5303C3.17678 13.2374 3.17678 12.7626 3.46967 12.4697C3.76256 12.1768 4.23744 12.1768 4.53033 12.4697L8.97644 16.9158L19.4471 5.49321C19.727 5.18787 20.2015 5.16724 20.5068 5.44714Z", stroke: "currentColor", strokeWidth: "2" })
        )
      );
    });
    const radio = `_radio_e801425`;
    const styles$J = { radio };
    React.forwardRef(function Radio({ name: name2, id, label, className, checked, backgroundColor: color, value: value2, onChange, ...props }, ref) {
      return React.createElement(
        React.Fragment,
        null,
        React.createElement("input", { ref, className: classNames(className, styles$J.radio, "radio"), type: "radio", id, name: name2, value: value2, style: { backgroundColor: color }, checked, "data-checked": checked, "data-is-disabled": props.disabled, onChange: (e) => {
          onChange && onChange(e.currentTarget.value, e);
        }, ...props }),
        label && React.createElement("label", { className: "radio-label", style: { pointerEvents: props.disabled ? "none" : "auto" }, htmlFor: id }, label)
      );
    });
    const switchWrapper = `_switch-wrapper_2017a44`;
    const _switch = `_switch_63d662e`;
    const styles$I = { "switch-wrapper": switchWrapper, "switch": _switch };
    React.forwardRef(function Switch({ checked, backgroundColor: onColor, style, className, inputRef, onChange, ...props }, ref) {
      const [isFocused, setIsFocused] = reactExports.useState(false);
      const internalInputRef = reactExports.useRef(null);
      const forkedInputRef = useForkRef(inputRef, internalInputRef);
      const customStyles = {};
      function blur(event) {
        props.onBlur && props.onBlur(event);
        setIsFocused(false);
      }
      function focus(event) {
        props.onFocus && props.onFocus(event);
        setIsFocused(true);
      }
      if (onColor != null) {
        customStyles["--accent-color"] = onColor;
      }
      return React.createElement(
        "div",
        { ref, "data-focused": isFocused, "data-ischecked": Boolean(checked), className: classNames(styles$I["switch-wrapper"], className) },
        React.createElement("input", { ref: forkedInputRef, type: "checkbox", className: styles$I.switch, onBlur: blur, onFocus: focus, style: { ...style, ...customStyles }, checked, "data-is-disabled": props.disabled || false, onChange: (e) => {
          onChange && onChange(Boolean(e.currentTarget.checked), e);
        }, ...props })
      );
    });
    const slider = `_slider_dd8d708`;
    const styles$H = { slider };
    const Slider$1 = React.forwardRef(function Slider2({ style, className, width, onChange, ...props }, ref) {
      return React.createElement("input", { type: "range", className: classNames(className, styles$H.slider), "data-is-disabled": props.disabled || false, ref, onChange: (e) => {
        onChange && onChange(e.currentTarget.value, e);
      }, ...props, style: { width, ...style } });
    });
    const input = `_input_a485f55`;
    const styles$G = { input };
    const Input$1 = React.forwardRef(function Input2({ type = "text", style, className, width, height, onChange, ...props }, ref) {
      return React.createElement("input", { className: classNames(styles$G.input, className, "input"), type, ref, "data-is-disabled": props.disabled || false, onChange: (e) => {
        onChange && onChange(e.currentTarget.value, e);
      }, ...props, style: { width, height, ...style } });
    });
    const textarea = `_textarea_145d0f7`;
    const styles$F = { textarea };
    React.forwardRef(function Textarea({ className, width, height, style, onChange, ...props }, ref) {
      return React.createElement("textarea", { style: { width, height, ...style }, className: classNames(className, styles$F.textarea, "textarea"), "data-is-disabled": props.disabled || false, ref, onChange: (e) => {
        onChange && onChange(e.currentTarget.value, e);
      }, ...props });
    });
    const selectWrapper = `_select-wrapper_85c0db7`;
    const select = `_select_26c5629`;
    const chevron$1 = `_chevron_3b2c9f3`;
    const styles$E = { "select-wrapper": selectWrapper, select, chevron: chevron$1 };
    const Select = React.forwardRef(function Select2({ children, width = "100%", maxWidth, minWidth, className, onChange, selectRef, selectClassName, selectProps, style, value: value2, defaultValue: defaultValue2, variant = "secondary", ...props }, ref) {
      const { style: selectStyle, ...finalSelectProps } = { ...selectProps };
      return React.createElement(
        "div",
        { "data-variant": variant, className: classNames(className, styles$E["select-wrapper"], "select-container"), ref, "data-disabled": props.disabled, style: { display: "inline-block", width, ...style }, ...props },
        React.createElement("select", { "data-variant": variant, "data-is-disabled": props.disabled || false, disabled: props.disabled, className: classNames(selectClassName, styles$E.select, "select"), defaultValue: defaultValue2, value: value2, ref: selectRef, onChange: (e) => {
          onChange && onChange(e.currentTarget.value, e);
        }, style: { width, maxWidth, minWidth, ...selectStyle }, ...finalSelectProps }, children),
        React.createElement(
          HStack,
          { className: styles$E.chevron },
          React.createElement(Spacer, null),
          React.createElement(Icon, { name: "chevron_down", size: "20px" }),
          React.createElement(Spacer, { width: "4px" })
        )
      );
    });
    const chip$1 = `_chip_e5816f3`;
    const styles$D = { chip: chip$1 };
    const Chip = React.forwardRef(function Button2({ children, style, className, variant = "secondary", variantSize = "medium", ...props }, ref) {
      return React.createElement(HStack, { ref, inline: true, verticalAlignment: "center", className: classNames(styles$D.chip, className, "chip"), "data-size": variantSize, "data-variant": variant, padding: "6px 8px", ...props }, children);
    });
    const chip = `_chip_2b9efdd`;
    const remove = `_remove_fd78511`;
    const itemContainer = `_item-container_a23a131`;
    const styles$C = { chip, remove, "item-container": itemContainer };
    function MultiselectInlineValue({ values, disabled, onRemove }) {
      const items = values.map((v, index) => {
        return React.createElement(
          Chip,
          { className: styles$C.chip, key: index, padding: "6px 8px 6px 12px" },
          React.createElement("span", null, v.label),
          React.createElement(Spacer, { width: "4px" }),
          !disabled && React.createElement(IconButton, { iconName: "cross", iconSize: "15px", onClick: () => {
            onRemove(v);
          }, style: { outline: "none" } })
        );
      });
      if (items.length === 0) {
        return null;
      }
      return React.createElement(React.Fragment, null, items);
    }
    function MultiselectValue({ values, disabled, onRemove }) {
      const items = values.map((v, index) => {
        return React.createElement(
          Chip,
          { className: styles$C.chip, key: index, padding: "6px 8px 6px 12px" },
          React.createElement("span", null, v.label),
          React.createElement(Spacer, { width: "4px" }),
          !disabled && React.createElement(IconButton, { className: styles$C.remove, iconName: "cross", iconSize: "15px", onClick: () => {
            onRemove(v);
          } })
        );
      });
      if (items.length === 0) {
        return null;
      }
      return React.createElement("div", { className: classNames(styles$C["item-container"], "multiselect-values-container"), "data-is-disabled": disabled }, items);
    }
    function htmlOptionsToInternalOptions(options) {
      return React.Children.map(options, (o) => {
        if (typeof o.props.children !== "string") {
          throw new Error("Expected children of an option to be a string.");
        }
        const label = o.props.children;
        const value2 = o.props.value;
        return { label, value: value2 };
      });
    }
    function makeAvailableOptions(options, values) {
      return React.Children.map(options, (child, index) => {
        if (React.isValidElement(child) && !values.includes(child.props.value)) {
          const { selected, ...newProps } = child.props;
          return React.cloneElement(child, { ...newProps, key: index });
        }
        return null;
      });
    }
    function makeValuesAsOptions(options, values) {
      const optionsValueMap = {};
      React.Children.forEach(options, (child) => {
        if (typeof child.props.children !== "string") {
          throw new Error("Expected children of an option to be a string.");
        }
        optionsValueMap[child.props.value] = {
          label: child.props.children,
          value: child.props.value
        };
      });
      return values.map((v) => optionsValueMap[v] == null ? { label: v, value: v } : optionsValueMap[v]);
    }
    const Multiselect = React.forwardRef(function Multiselect2({ value: values = [], disabled = false, children, className, onChange, inline = false, ...props }, ref) {
      const selectRef = reactExports.useRef(null);
      const lastValue = values[values.length - 1] || null;
      const valuesContainerRef = reactExports.useRef(null);
      const childrenArray = React.Children.toArray(children);
      const labelToValueMap = {};
      const valueToLabelMap = {};
      childrenArray.forEach((c) => {
        if (typeof c.props.children !== "string") {
          throw new Error("Expected children of an option to be a string.");
        }
        labelToValueMap[c.props.children] = c.props.value;
        valueToLabelMap[c.props.value] = c.props.children;
      });
      const valuesAsOptions = makeValuesAsOptions(children, values);
      const availableOptions = makeAvailableOptions(children, values);
      availableOptions.unshift(React.createElement("option", { key: "-- Select to Add --", value: "-- Select to Add --" }, availableOptions.length >= 1 ? "-- Select to Add --" : "No More Options"));
      reactExports.useLayoutEffect(() => {
        var _a2;
        const valuesElement = valuesContainerRef.current;
        const shouldFocus = lastValue != null && valuesElement != null;
        if (shouldFocus) {
          (_a2 = valuesElement.querySelector(`[data-value='${lastValue}']`)) == null ? void 0 : _a2.focus();
          requestAnimationFrame(() => {
            selectRef.current && selectRef.current.focus();
          });
        }
      }, [lastValue]);
      function addValue(value2) {
        if (!values.includes(value2)) {
          onChange && onChange([...values, value2]);
        }
      }
      function removeValue(option2) {
        const index = values.indexOf(option2.value);
        if (index > -1) {
          const newValues = values.filter((v) => v !== option2.value);
          onChange && onChange(newValues);
        }
      }
      if (inline) {
        return React.createElement(
          React.Fragment,
          null,
          React.createElement(Select, { ref, disabled, onChange: addValue, width: "auto", ...props }, availableOptions),
          React.createElement(Spacer, { width: "8px" }),
          React.createElement(MultiselectInlineValue, { values: valuesAsOptions, onRemove: removeValue, disabled })
        );
      }
      return React.createElement(
        VStack,
        null,
        React.createElement(Select, { ref, disabled, onChange: addValue, ...props }, availableOptions),
        React.createElement(Spacer, { height: "2px", width: "100%" }),
        React.createElement(MultiselectValue, { values: valuesAsOptions, onRemove: removeValue, disabled })
      );
    });
    const suggestion = `_suggestion_d0f20dd`;
    const styles$B = { suggestion };
    function Suggestion({ isSelected, option: option2, onClick }) {
      const buttonRef = reactExports.useRef(null);
      reactExports.useLayoutEffect(() => {
        const button2 = buttonRef.current;
        if (isSelected && button2 != null) {
          button2.scrollIntoView({ block: "center" });
        }
      }, [isSelected]);
      return React.createElement(
        "button",
        { ref: buttonRef, className: classNames(styles$B.suggestion, "auto-complete-input-suggestion"), "data-is-selected": isSelected, onClick: () => {
          onClick && onClick(option2);
        } },
        React.createElement(BodyText, null, option2.label)
      );
    }
    const FocusRedirect = React.forwardRef(function FocusRedirect2({ onRedirect }, ref) {
      return React.createElement("div", { ref, tabIndex: 0, onFocus: onRedirect, style: {
        padding: 0,
        margin: 0,
        width: 0,
        height: 0,
        opacity: 0,
        position: "relative"
      } });
    });
    const suggestions = `_suggestions_081f70f`;
    const value = `_value_bbce639`;
    const noResults = `_no-results_f489d9e`;
    const styles$A = { suggestions, value, "no-results": noResults };
    function Suggestions({ value: value2 = "", anchorElement, options: suggestions2 = [], onOptionSelect, noSuggestionMessage = "-- No Matches --", onClose, onKeyUp, onKeyDown, trimCustomInput = false, ...props }) {
      const [selectedIndex, setSelectedIndex] = reactExports.useState(-1);
      const [internalValue, setInernalValue] = reactExports.useState(value2);
      const internalInputRef = reactExports.useRef(null);
      const [matchedOptions, setMatchedOptions] = reactExports.useState(() => getMatchedOptions(value2));
      const [suggestionsWidth, setSuggestionsWidth] = reactExports.useState();
      const [suggestionsHeight, setSuggestionsHeight] = reactExports.useState();
      function captureKeyUp(event) {
        const input2 = event.currentTarget;
        const newMatches = getMatchedOptions(input2.value);
        setMatchedOptions(newMatches);
        onKeyUp && onKeyUp(event);
      }
      function captureKeyDown(event) {
        const key = event.key;
        const input2 = event.currentTarget;
        switch (key) {
          case "ArrowDown": {
            const newIndex = selectedIndex + 1;
            if (newIndex === matchedOptions.length) {
              setSelectedIndex(0);
            } else {
              setSelectedIndex(newIndex);
            }
            event.preventDefault();
            break;
          }
          case "Tab": {
            let step = 1;
            if (event.shiftKey) {
              step = -1;
            }
            const newIndex = selectedIndex + step;
            if (newIndex === matchedOptions.length) {
              setSelectedIndex(0);
            } else if (newIndex <= -1) {
              setSelectedIndex(matchedOptions.length - 1);
            } else {
              setSelectedIndex(newIndex);
            }
            event.preventDefault();
            break;
          }
          case "ArrowUp": {
            const newIndex = selectedIndex - 1;
            if (newIndex === -1) {
              setSelectedIndex(matchedOptions.length - 1);
            } else {
              setSelectedIndex(newIndex);
            }
            event.preventDefault();
            break;
          }
          case "Enter": {
            if (matchedOptions[selectedIndex] == null) {
              const value3 = trimCustomInput ? input2.value.trim() : input2.value;
              if (value3 === "") {
                return;
              }
              onOptionSelect && onOptionSelect({ label: value3, value: value3 });
              break;
            }
            onOptionSelect && onOptionSelect(matchedOptions[selectedIndex]);
            break;
          }
          case "Escape": {
            onClose && onClose(input2.value, input2.selectionStart, input2.selectionEnd);
            break;
          }
        }
        onKeyDown && onKeyDown(event);
      }
      function getMatchedOptions(value3) {
        return suggestions2.filter((s) => s.label.toLocaleLowerCase().includes(value3.toLocaleLowerCase()));
      }
      function focusInput() {
        const input2 = internalInputRef.current;
        if (input2 != null) {
          input2.focus();
        }
      }
      function handleUseClose() {
        const input2 = internalInputRef.current;
        if (input2 != null) {
          onClose && onClose(input2.value, input2.selectionStart, input2.selectionEnd);
        }
      }
      reactExports.useLayoutEffect(() => {
        const input2 = internalInputRef.current;
        if (input2 != null) {
          input2.focus();
        }
      }, []);
      reactExports.useLayoutEffect(() => {
        if (anchorElement != null) {
          const rect = anchorElement.getBoundingClientRect();
          setSuggestionsWidth(`${rect.width}px`);
          setSuggestionsHeight(`${rect.height}px`);
          if (internalInputRef.current != null) {
            internalInputRef.current.value = anchorElement.value;
            internalInputRef.current.selectionStart = anchorElement.selectionStart;
            internalInputRef.current.selectionEnd = anchorElement.selectionEnd;
          }
        }
      }, [anchorElement]);
      reactExports.useLayoutEffect(() => {
        setSelectedIndex(-1);
      }, [internalValue]);
      return React.createElement(
        Popover,
        { open: true, anchorElement, onClose: handleUseClose, verticalAnchor: "top", verticalOrigin: "top", verticalOffset: -4 },
        React.createElement(
          VStack,
          { minHeight: `calc(${suggestionsHeight}, 8px)`, maxHeight: "300px", width: suggestionsWidth, height: "auto", overflowY: "auto", className: classNames(styles$A.suggestions, "auto-complete-input-suggestions") },
          React.createElement("input", { ref: internalInputRef, key: -1, value: internalValue, onKeyUp: captureKeyUp, onKeyDown: captureKeyDown, onChange: (event) => {
            setInernalValue(event.target.value);
          }, className: classNames(styles$A.value, "auto-complete-input-suggestions-input"), ...props }),
          matchedOptions.map((m, index) => {
            return React.createElement(Suggestion, { key: index, option: m, isSelected: index === selectedIndex, onClick: onOptionSelect });
          }),
          matchedOptions.length === 0 && React.createElement(
            ZStack,
            { className: styles$A["no-results"] },
            React.createElement(BodyText, null, noSuggestionMessage)
          ),
          React.createElement(FocusRedirect, { key: matchedOptions.length, onRedirect: focusInput })
        )
      );
    }
    const AutoCompleteInput = React.forwardRef(function AutoCompleteInput2({ onOptionSelect: onSuggestionSelect, children = [], onKeyDown, onKeyUp, value: value2, noOptionMatchedMessage, trimCustomInput = false, className, onMouseDown, onMouseUp, ...props }, ref) {
      const isAlreadyFocusedRef = reactExports.useRef(false);
      const valueRef = reactExports.useRef(value2);
      const internalOptions = htmlOptionsToInternalOptions(children);
      const isClosingRef = reactExports.useRef(false);
      const [anchorElement, setAnchorElement] = reactExports.useState(null);
      const internalInputRef = reactExports.useRef(null);
      const [isSuggestionsOpen, setIsSuggestionsOpen] = reactExports.useState(false);
      const forkedRef = useForkRef(ref, internalInputRef);
      function openSuggestions() {
        setIsSuggestionsOpen(true);
      }
      function closeSuggestions() {
        setIsSuggestionsOpen(false);
      }
      function handleClose(value3, selectionStart, selectionEnd) {
        isClosingRef.current = true;
        const input2 = internalInputRef.current;
        requestAnimationFrame(() => {
          if (input2 != null) {
            input2.value = value3;
            input2.focus();
            input2.setSelectionRange(selectionStart, selectionEnd);
          }
        });
        props.onChange && props.onChange(value3);
        closeSuggestions();
      }
      function handleSelection(value3) {
        isClosingRef.current = true;
        const input2 = internalInputRef.current;
        if (input2 != null) {
          input2.focus();
        }
        closeSuggestions();
        onSuggestionSelect && onSuggestionSelect(value3);
      }
      function handleKeyDown(event) {
        valueRef.current = event.currentTarget.value;
        const key = event.key;
        if (isClosingRef.current) {
          isClosingRef.current = false;
          onKeyDown && onKeyDown(event);
          return;
        }
        if (key === "Enter") {
          if (isSuggestionsOpen) {
            closeSuggestions();
          } else {
            openSuggestions();
          }
        }
        onKeyDown && onKeyDown(event);
      }
      function handleKeyUp(event) {
        const key = event.key;
        if (key === "Enter") {
          return;
        }
        if (valueRef.current !== event.currentTarget.value) {
          openSuggestions();
        }
        onKeyUp && onKeyUp(event);
      }
      function handlMouseDown(event) {
        setAnchorElement(event.currentTarget);
        isAlreadyFocusedRef.current = document.activeElement === event.currentTarget;
        onMouseDown && onMouseDown(event);
      }
      function handleMouseUp(event) {
        if (isClosingRef.current) {
          isClosingRef.current = false;
          closeSuggestions();
        }
        openSuggestions();
        onMouseUp && onMouseUp(event);
      }
      return React.createElement(
        React.Fragment,
        null,
        React.createElement(Input$1, { ref: forkedRef, className: classNames(className, "auto-complete-input"), ...props, value: value2, onKeyDown: handleKeyDown, onKeyUp: handleKeyUp, onMouseDown: handlMouseDown, onMouseUp: handleMouseUp }),
        isSuggestionsOpen && React.createElement(Suggestions, { anchorElement, options: internalOptions, onClose: handleClose, value: value2, trimCustomInput, onOptionSelect: handleSelection, noSuggestionMessage: noOptionMatchedMessage })
      );
    });
    React.forwardRef(function FreeformMultiselect({ value: values = [], children, disabled = false, className, onChange, inline = false, inputRef, trimCustomInput = false, inputProps, ...props }, ref) {
      const [intervalValue, setInternalValue] = reactExports.useState("");
      const availableOptions = makeAvailableOptions(children, values);
      const valuesAsOptions = makeValuesAsOptions(children, values);
      function removeValue(option2) {
        const index = values.indexOf(option2.value);
        if (index > -1) {
          const newValues = values.filter((v) => v !== option2.value);
          onChange && onChange(newValues);
        }
      }
      function addValue(newValue) {
        const index = values.indexOf(newValue.value);
        if (index === -1) {
          onChange && onChange([...values, newValue.value]);
        }
        setInternalValue("");
      }
      if (inline) {
        return React.createElement(
          React.Fragment,
          null,
          React.createElement(AutoCompleteInput, { ref: inputRef, value: intervalValue, onChange: setInternalValue, onOptionSelect: addValue, trimCustomInput, disabled, noOptionMatchedMessage: "Press Enter To Add", placeholder: "Type to Add", ...inputProps }, availableOptions),
          React.createElement(Spacer, { width: "8px" }),
          React.createElement(MultiselectInlineValue, { values: valuesAsOptions, onRemove: removeValue, disabled })
        );
      }
      return React.createElement(
        VStack,
        { ref, ...props },
        React.createElement(AutoCompleteInput, { ref: inputRef, value: intervalValue, onChange: setInternalValue, onOptionSelect: addValue, trimCustomInput, disabled, noOptionMatchedMessage: "Press Enter To Add", placeholder: "Type to Search or Add", ...inputProps }, availableOptions),
        React.createElement(Spacer, { height: "4px" }),
        React.createElement(MultiselectValue, { values: valuesAsOptions, onRemove: removeValue, disabled })
      );
    });
    const datePickerDate = `_date-picker-date_7210f85`;
    const datePickerToday$1 = `_date-picker-today_1950dee`;
    const styles$z = { "date-picker-date": datePickerDate, "date-picker-today": datePickerToday$1 };
    function DatePickerDate({ presenter: presenter2, date: calendarDate }) {
      const { visibleMonth, disabledDates, min: minDate, max: maxDate } = useSignalValue(presenter2.stateBroadcast);
      const selectedDate = useSignalValue(presenter2.valueBroadcast);
      let normalizedMinDate = new Date(minDate);
      let normalizedMaxDate = new Date(maxDate);
      if (minDate != null) {
        normalizedMinDate.setHours(0, 0, 0, 0);
      }
      if (maxDate != null) {
        normalizedMaxDate.setHours(23, 59, 59, 999);
      }
      const date = /* @__PURE__ */ new Date();
      const minTime = minDate == null ? -Infinity : normalizedMinDate.getTime();
      const maxTime = maxDate == null ? Infinity : normalizedMaxDate.getTime();
      const time = new Date(calendarDate.year, calendarDate.month, calendarDate.date).getTime();
      const isWithinMonth = visibleMonth === calendarDate.month;
      const isSelected = (selectedDate == null ? void 0 : selectedDate.getMonth()) === calendarDate.month && selectedDate.getFullYear() === calendarDate.year && selectedDate.getDate() === calendarDate.date;
      const isDisabled = disabledDates.some((d) => d.getMonth() === calendarDate.month && d.getFullYear() === calendarDate.year && d.getDate() === calendarDate.date);
      const isWithinRange = time >= minTime && time < maxTime;
      const isToday = date.getMonth() === calendarDate.month && date.getFullYear() === calendarDate.year && date.getDate() === calendarDate.date;
      function select2() {
        const date2 = new Date(calendarDate.year, calendarDate.month, calendarDate.date);
        if (isSelected) {
          presenter2.clear();
          return;
        }
        presenter2.selectDate(date2);
      }
      return React.createElement(
        "button",
        { disabled: !isWithinMonth || isDisabled || !isWithinRange, className: styles$z["date-picker-date"], onClick: select2, "data-is-within-month": String(isWithinMonth), "data-is-selected": String(isSelected), "data-is-disabled": String(isDisabled), "data-is-within-range": String(isWithinRange), "data-is-today": String(isToday) },
        React.createElement(
          ZStack,
          null,
          React.createElement(BodyText, null, String(calendarDate.date)),
          isToday && React.createElement("div", { className: styles$z["date-picker-today"], "data-is-selected": String(isSelected) })
        )
      );
    }
    const datePickerDayText = `_date-picker-day-text_f7b1f22`;
    const datePickerDay = `_date-picker-day_e1128cd`;
    const styles$y = { "date-picker-day-text": datePickerDayText, "date-picker-day": datePickerDay };
    function DatePickerDay({ dayOfTheWeek, countryCode }) {
      const date = /* @__PURE__ */ new Date();
      date.setDate(date.getDate() - date.getDay() + dayOfTheWeek);
      const weekdayName = new Intl.DateTimeFormat(countryCode, { weekday: "short" }).format(date).toLocaleUpperCase();
      return React.createElement(
        "div",
        { className: styles$y["date-picker-day"] },
        React.createElement(
          ZStack,
          null,
          React.createElement(BodyText, { className: styles$y["date-picker-day-text"] }, weekdayName[0])
        )
      );
    }
    function DatePickerBody({ presenter: presenter2, countryCode }) {
      const { visibleDates } = useSignalValue(presenter2.stateBroadcast);
      const rows = [];
      for (let i = 0; i < visibleDates.length; i += 7) {
        rows.push(visibleDates.slice(i, i + 7));
      }
      return React.createElement(
        VStack,
        { height: "auto", width: "auto" },
        React.createElement(HStack, { height: "auto", width: "auto" }, new Array(7).fill(0).map((_, index) => {
          return React.createElement(
            FlexBox,
            { key: index, height: "auto" },
            React.createElement(DatePickerDay, { countryCode, dayOfTheWeek: index })
          );
        })),
        React.createElement(Divider, null),
        React.createElement(Divider, null),
        React.createElement(Spacer, { height: "2px" }),
        rows.map((dates, index) => {
          return React.createElement(
            React.Fragment,
            { key: index },
            React.createElement(HStack, { key: index, height: "auto", width: "auto" }, dates.map((date, index2) => {
              return React.createElement(
                FlexBox,
                { key: index2, height: "auto" },
                React.createElement(DatePickerDate, { date, presenter: presenter2 })
              );
            })),
            React.createElement(Spacer, { height: "1px" })
          );
        })
      );
    }
    function getMonthsOfYear(countryCode) {
      const formatter = new Intl.DateTimeFormat(countryCode, { month: "long" });
      const months = [];
      const referenceDate = /* @__PURE__ */ new Date("01/01/2024");
      for (let i = 0; i < 12; i++) {
        const date = new Date(referenceDate);
        date.setUTCMonth(i);
        let month = formatter.format(date);
        month = capitalizeFirstCharacter(month, countryCode);
        months.push(month);
      }
      return months;
    }
    function capitalizeFirstCharacter(input2, locale) {
      var _a2;
      const segmenter = new Intl.Segmenter(locale, { granularity: "grapheme" });
      const segments = segmenter.segment(input2);
      const firstSegment = ((_a2 = segments[Symbol.iterator]().next().value) == null ? void 0 : _a2.segment) || "";
      return firstSegment.toLocaleUpperCase(locale) + input2.slice(firstSegment.length);
    }
    function makeMonthsOptions$1(countryCode) {
      const months = getMonthsOfYear(countryCode);
      return months.map((m, index) => {
        return React.createElement("option", { key: index, value: index }, m);
      });
    }
    function DatePickerHeader({ presenter: presenter2, countryCode }) {
      const state = useSignalValue(presenter2.stateBroadcast);
      const minYear = state.min.getFullYear();
      const maxDate = new Date(state.max);
      maxDate.setMilliseconds(maxDate.getMilliseconds() - 1);
      const maxYear = maxDate.getFullYear();
      const years = reactExports.useMemo(() => {
        const years2 = [];
        for (let i = minYear; i <= maxYear; i++) {
          years2.push(i);
        }
        return years2;
      }, [minYear, maxYear]);
      function selectMonth(value2) {
        presenter2.setVisibleMonth(Number(value2));
      }
      function selectYear(value2) {
        presenter2.setVisibleYear(Number(value2));
      }
      function previous() {
        return presenter2.setVisibleMonth(presenter2.stateBroadcast.get().visibleMonth - 1);
      }
      function next() {
        return presenter2.setVisibleMonth(presenter2.stateBroadcast.get().visibleMonth + 1);
      }
      const monthsOptions = reactExports.useMemo(() => {
        return makeMonthsOptions$1(countryCode);
      }, [countryCode]);
      return React.createElement(
        HStack,
        { height: "35px", width: "100%" },
        React.createElement(IconButton, { disabled: !state.canNavigateToPreviousMonth, flipOnRtl: true, variant: "tertiary", iconSize: "20px", onClick: previous, iconName: "chevron_left" }),
        React.createElement(Spacer, null),
        React.createElement(
          HStack,
          { horizontalAlignment: "center", width: "auto" },
          React.createElement(Select, { variant: "tertiary", width: "auto", maxWidth: "150px", value: String(state.visibleMonth), onChange: selectMonth }, monthsOptions),
          React.createElement(Select, { variant: "tertiary", width: "auto", value: String(state.visibleYear), onChange: selectYear }, years.map((value2, index) => {
            return React.createElement("option", { key: index, value: value2 }, value2);
          }))
        ),
        React.createElement(Spacer, null),
        React.createElement(IconButton, { disabled: !state.canNavigateToNextMonth, flipOnRtl: true, variant: "tertiary", iconSize: "20px", onClick: next, iconName: "chevron_right" })
      );
    }
    class CalendarDatesGenerator {
      constructor(year, month) {
        __publicField(this, "_extraDates", []);
        __publicField(this, "dates");
        this.dates = [];
        this._fillDates();
        this.updateDates(year, month);
      }
      _fillDates() {
        const dates = this.dates;
        dates.length = 0;
        for (let date = 0; date < 42; date++) {
          dates.push({
            year: 0,
            month: 0,
            date: 0,
            hours: 0,
            minutes: 0,
            seconds: 0
          });
        }
      }
      _addExtraDates() {
        if (this.dates.length === 35) {
          this.dates.push(...this._extraDates);
        }
      }
      updateDates(year, month) {
        this._addExtraDates();
        const dates = this.dates;
        const startDate = new Date(year, month);
        while (startDate.getDay() !== 0) {
          startDate.setDate(startDate.getDate() - 1);
        }
        for (let i = 0; i < 42; i++) {
          const date = dates[i];
          date.year = startDate.getFullYear();
          date.month = startDate.getMonth();
          date.date = startDate.getDate();
          date.hours = 0;
          date.minutes = 0;
          date.seconds = 0;
          startDate.setDate(startDate.getDate() + 1);
        }
      }
    }
    const defaultMinVisibleTimeInMilliseconds = 0;
    const defaultMaxVisibleTimeInMilliseconds = 24 * 1e3 * 60 * 60;
    class DatePickerPresenter {
      constructor(value2, visibleYear, visibleMonth, showTime, timeIntervalInMinutes = 15) {
        __publicField(this, "_value");
        __publicField(this, "_error");
        __publicField(this, "_state");
        __publicField(this, "_calendarDatesGenerator");
        __publicField(this, "_dateUtility");
        __publicField(this, "_defaultMinDate");
        __publicField(this, "_defaultMaxDate");
        const today = /* @__PURE__ */ new Date();
        const year = value2 == null ? today.getFullYear() : value2.getFullYear();
        const month = value2 == null ? today.getMonth() : value2.getMonth();
        this._dateUtility = /* @__PURE__ */ new Date();
        this._calendarDatesGenerator = new CalendarDatesGenerator(year, month);
        this._dateUtility.setFullYear(year);
        this._dateUtility.setMonth(month);
        this._defaultMinDate = new Date(today);
        this._defaultMaxDate = new Date(today);
        this._defaultMinDate.setFullYear(this._defaultMinDate.getFullYear() - 50);
        this._defaultMaxDate.setFullYear(this._defaultMaxDate.getFullYear() + 50);
        this._defaultMinDate.setHours(0, 0, 0, 0);
        this._defaultMaxDate.setHours(0, 0, 0, 0);
        this._value = new Signal(value2);
        this._error = new Signal(null);
        const state = {
          error: null,
          visibleYear,
          visibleMonth,
          visibleDates: this._calendarDatesGenerator.dates,
          canNavigateToNextMonth: this._canNavigateToMonth(visibleMonth + 1, visibleYear, this._defaultMinDate, this._defaultMaxDate),
          canNavigateToPreviousMonth: this._canNavigateToMonth(visibleMonth - 1, visibleYear, this._defaultMinDate, this._defaultMaxDate),
          showTime,
          timeIntervalInMinutes,
          minVisibleTimeInMilliseconds: defaultMinVisibleTimeInMilliseconds,
          maxVisibleTimeInMilliseconds: defaultMaxVisibleTimeInMilliseconds,
          min: new Date(this._defaultMinDate),
          max: new Date(this._defaultMaxDate),
          disabledDates: []
        };
        this._state = new Signal(state);
      }
      get stateBroadcast() {
        return this._state.broadcast;
      }
      get valueBroadcast() {
        return this._value.broadcast;
      }
      get errorBroadcast() {
        return this._error.broadcast;
      }
      initialize() {
        this._validate(this._value.get(), this._error.get(), this._state.get());
      }
      selectDate(date) {
        var _a2;
        if ((date == null ? void 0 : date.getTime()) === ((_a2 = this._value.get()) == null ? void 0 : _a2.getTime())) {
          return;
        }
        this._value.transform((value2) => {
          if (date == null || value2 == null) {
            value2 = date;
          } else {
            const clonedDate = new Date(date);
            clonedDate.setHours(value2.getHours(), value2.getMinutes(), value2.getSeconds());
            value2 = clonedDate;
          }
          value2 && this._keepTimeWithinBounds(value2);
          this._validate(value2, this._error.get(), this._state.get());
          return value2;
        });
      }
      _keepTimeWithinBounds(date) {
        const state = this._state.get();
        const offsetDate = new Date(date);
        offsetDate.setHours(0, 0, 0, 0);
        const offset = date.getTime() - offsetDate.getTime();
        if (offset < state.minVisibleTimeInMilliseconds) {
          date.setHours(0, 0, 0, 0);
          date.setTime(date.getTime() + state.minVisibleTimeInMilliseconds);
        }
        if (offset > state.maxVisibleTimeInMilliseconds) {
          date.setHours(0, 0, 0, 0);
          date.setTime(date.getTime() + state.maxVisibleTimeInMilliseconds);
        }
        if (date.getTime() < state.min.getTime()) {
          date.setTime(state.min.getTime());
        }
        if (date.getTime() > state.max.getTime()) {
          date.setTime(state.max.getTime());
        }
      }
      _validate(date, error, state) {
        let validationError = null;
        if (date != null) {
          const time = date.getTime();
          const minTime = state.min == null ? -Infinity : state.min.getTime();
          const maxTime = state.max == null ? Infinity : state.max.getTime();
          if (time < minTime) {
            validationError = "Selected date is outside acceptable range.";
          } else if (time >= maxTime) {
            validationError = "Selected date is outside acceptable range.";
          }
          const isOnDisabledDate = state.disabledDates.some((d) => d.getDate() === date.getDate() && d.getMonth() === date.getMonth() && d.getFullYear() === date.getFullYear());
          if (isOnDisabledDate) {
            validationError = "Selected date is disabled.";
          }
        }
        if (validationError !== error) {
          this._state.transform((s) => {
            s.error = validationError;
            return s;
          });
        }
      }
      setShowTime(showTime) {
        this._state.transform((s) => {
          s.showTime = showTime;
          return s;
        });
      }
      setVisibleYear(year) {
        const state = this._state.get();
        this._dateUtility.setFullYear(year);
        this._dateUtility.setDate(1);
        this._dateUtility.setMonth(state.visibleMonth);
        year = this._dateUtility.getFullYear();
        let month = this._dateUtility.getMonth();
        const newDateTime = this._dateUtility.getTime();
        const minDateTime = state.min.getTime();
        const maxDateTime = state.max.getTime();
        if (newDateTime < minDateTime) {
          year = state.min.getFullYear();
          month = state.min.getMonth();
        }
        if (newDateTime >= maxDateTime) {
          const date = new Date(state.max);
          date.setMilliseconds(date.getMilliseconds() - 1);
          year = date.getFullYear();
          month = date.getMonth();
        }
        this._state.transform((s) => {
          s.visibleYear = year;
          s.visibleMonth = month;
          this._calendarDatesGenerator.updateDates(year, month);
          this._updateNavigationAvailability(s);
          return s;
        });
      }
      _updateNavigationAvailability(s) {
        s.canNavigateToNextMonth = this._canNavigateToMonth(s.visibleMonth + 1, s.visibleYear, s.min, s.max);
        s.canNavigateToPreviousMonth = this._canNavigateToMonth(s.visibleMonth - 1, s.visibleYear, s.min, s.max);
      }
      setVisibleMonth(month) {
        const state = this._state.get();
        this._dateUtility.setFullYear(state.visibleYear);
        this._dateUtility.setDate(1);
        this._dateUtility.setMonth(month);
        month = this._dateUtility.getMonth();
        let year = this._dateUtility.getFullYear();
        const newDateTime = this._dateUtility.getTime();
        const minDateTime = state.min.getTime();
        const maxDateTime = state.max.getTime();
        if (newDateTime < minDateTime) {
          year = state.min.getFullYear();
          month = state.min.getMonth();
        }
        if (newDateTime >= maxDateTime) {
          const date = new Date(state.max);
          date.setMilliseconds(date.getMilliseconds() - 1);
          year = date.getFullYear();
          month = date.getMonth();
        }
        this._state.transform((s) => {
          s.visibleMonth = month;
          s.visibleYear = year;
          this._updateNavigationAvailability(s);
          this._calendarDatesGenerator.updateDates(year, month);
          return s;
        });
      }
      _canNavigateToMonth(month, year, minDate, maxDate) {
        this._dateUtility.setFullYear(year);
        this._dateUtility.setMonth(month);
        this._dateUtility.setDate(1);
        this._dateUtility.setHours(0, 0, 0, 0);
        const startTime = this._dateUtility.getTime();
        this._dateUtility.setFullYear(year);
        this._dateUtility.setMonth(month + 1);
        this._dateUtility.setDate(1);
        const endTime = this._dateUtility.getTime();
        const minDateTime = minDate.getTime();
        const maxDateTime = maxDate.getTime();
        const start = Math.max(minDateTime, startTime);
        const end = Math.min(maxDateTime, endTime);
        return start < end;
      }
      setMinDate(value2) {
        this._state.transform((s) => {
          if (value2 == null) {
            s.min = new Date(this._defaultMinDate);
          } else {
            s.min = new Date(value2);
          }
          this._updateNavigationAvailability(s);
          this._validate(this._value.get(), this._error.get(), s);
          return s;
        });
      }
      setMaxDate(value2) {
        this._state.transform((s) => {
          if (value2 == null) {
            s.max = new Date(this._defaultMaxDate);
          } else {
            s.max = new Date(value2);
          }
          this._updateNavigationAvailability(s);
          this._validate(this._value.get(), this._error.get(), s);
          return s;
        });
      }
      setMinVisibleTime(timeInMilliseconds) {
        this._state.transform((s) => {
          s.minVisibleTimeInMilliseconds = Math.max(timeInMilliseconds, defaultMinVisibleTimeInMilliseconds);
          return s;
        });
      }
      setMaxVisibleTime(timeInMilliseconds) {
        this._state.transform((s) => {
          s.maxVisibleTimeInMilliseconds = Math.min(timeInMilliseconds, defaultMaxVisibleTimeInMilliseconds);
          return s;
        });
      }
      setDisabledDates(dates) {
        this._state.transform((s) => {
          s.disabledDates = dates;
          this._validate(this._value.get(), this._error.get(), s);
          return s;
        });
      }
      clear() {
        this.selectDate(null);
      }
      setHours(hours) {
        if (this._value.get() == null) {
          return;
        }
        this._value.transform((value2) => {
          value2 == null ? void 0 : value2.setHours(hours);
          return value2;
        });
      }
      setMinutes(minutes) {
        if (this._value.get() == null) {
          return;
        }
        this._value.transform((value2) => {
          value2 == null ? void 0 : value2.setMinutes(minutes);
          return value2;
        });
      }
      setSeconds(seconds) {
        if (this._value.get() == null) {
          return;
        }
        this._value.transform((value2) => {
          value2 == null ? void 0 : value2.setSeconds(seconds);
          return value2;
        });
      }
    }
    const timeBox = `_time-box_b58dd27`;
    const timeBoxTitle = `_time-box-title_51ba1dd`;
    const selectedTime = `_selected-time_7779813`;
    const styles$x = { "time-box": timeBox, "time-box-title": timeBoxTitle, "selected-time": selectedTime };
    function DatePickerTimeSelector({ origin, intervalInMinutes, max: max2, min: min2, minVisibleTimeInMilliseconds, maxVisibleTimeInMilliseconds, onSelect, disabled, height }) {
      const stepInMilliseconds = intervalInMinutes * 1e3 * 60;
      const amountOfSteps = 24 * 1e3 * 60 * 60 / stepInMilliseconds;
      const normalizedDate = new Date(origin || /* @__PURE__ */ new Date());
      const options = [];
      const minTime = min2.getTime();
      const maxTime = max2.getTime();
      normalizedDate.setHours(0, 0, 0, 0);
      let offset = normalizedDate.getTime();
      let offsetFromZero = 0;
      for (let x = 0; x < amountOfSteps; x++) {
        const date = new Date(offset);
        let hour = date.getHours() % 12;
        const minute = date.getMinutes();
        const meridiem = date.getHours() >= 12 ? "PM" : "AM";
        hour = hour === 0 ? 12 : hour;
        const isSelected = origin != null && date.getHours() === origin.getHours() && date.getMinutes() === origin.getMinutes() && date.getSeconds() === origin.getSeconds();
        const time = date.getTime();
        const isOutOfRange = time < minTime || time > maxTime;
        const button2 = React.createElement(Button, { key: x, variant: "tertiary", className: isSelected && styles$x["selected-time"], disabled: origin == null || disabled || isOutOfRange, onClick: () => {
          onSelect(date.getHours(), date.getMinutes(), date.getSeconds());
        } }, `${hour.toString().padStart(2, "0")}:${minute.toString().padStart(2, "0")} ${meridiem}`);
        if (offsetFromZero >= minVisibleTimeInMilliseconds && offsetFromZero <= maxVisibleTimeInMilliseconds) {
          options.push(button2);
        }
        offset += stepInMilliseconds;
        offsetFromZero += stepInMilliseconds;
      }
      return React.createElement(
        VStack,
        { width: "auto", height, "data-is-disabled": disabled || origin == null, className: styles$x["time-box"] },
        React.createElement(
          ZStack,
          { height: "35px", width: "auto" },
          React.createElement(
            BodyText,
            { className: styles$x["time-box-title"] },
            React.createElement(Icon, { name: "time", size: "1.5em" })
          )
        ),
        React.createElement(Divider, null),
        React.createElement(VStack, { width: "auto", overflowY: "auto", flex: true, style: { paddingInline: "4px" } }, options)
      );
    }
    const datePicker = `_date-picker_bf392c9`;
    const datePickerBox = `_date-picker-box_126baae`;
    const styles$w = { "date-picker": datePicker, "date-picker-box": datePickerBox };
    React.forwardRef(function DatePicker({ value: value2, disabled, onChange, onError, showTime = false, min: minDate = null, max: maxDate = null, minVisibleTimeInMilliseconds, maxVisibleTimeInMilliseconds, disabledDates, countryCode = "en-US", renderActions }, ref) {
      const [calendarHeight, setCalendarHeight] = reactExports.useState(0);
      const calendarRef = useResizeObserver((_, height) => {
        setCalendarHeight(height);
      });
      const [presenter2] = reactExports.useState(() => {
        const today = /* @__PURE__ */ new Date();
        const year = value2 == null ? today.getFullYear() : value2.getFullYear();
        const month = value2 == null ? today.getMonth() : value2.getMonth();
        return new DatePickerPresenter(value2, year, month, showTime);
      });
      const state = useSignalValue(presenter2.stateBroadcast);
      const innerValue = useSignalValue(presenter2.valueBroadcast);
      const error = state.error;
      useSignalValueEffect((innerError) => {
        error !== innerError && onError && onError(innerError);
      }, presenter2.errorBroadcast);
      useSignalValueEffect((value3) => {
        onChange && onChange(value3);
      }, presenter2.valueBroadcast);
      reactExports.useLayoutEffect(() => {
        presenter2.initialize();
      }, [presenter2]);
      reactExports.useLayoutEffect(() => {
        presenter2.setShowTime(showTime);
      }, [presenter2, showTime]);
      reactExports.useLayoutEffect(() => {
        presenter2.setMinDate(minDate);
      }, [presenter2, minDate]);
      reactExports.useLayoutEffect(() => {
        presenter2.setMaxDate(maxDate);
      }, [presenter2, maxDate]);
      reactExports.useLayoutEffect(() => {
        if (disabledDates == null) {
          presenter2.setDisabledDates([]);
        } else {
          presenter2.setDisabledDates(disabledDates);
        }
      }, [presenter2, disabledDates]);
      reactExports.useLayoutEffect(() => {
        if (typeof minVisibleTimeInMilliseconds === "number") {
          presenter2.setMinVisibleTime(minVisibleTimeInMilliseconds);
        }
      }, [presenter2, minVisibleTimeInMilliseconds]);
      reactExports.useLayoutEffect(() => {
        if (typeof maxVisibleTimeInMilliseconds === "number") {
          presenter2.setMaxVisibleTime(maxVisibleTimeInMilliseconds);
        }
      }, [presenter2, maxVisibleTimeInMilliseconds]);
      reactExports.useLayoutEffect(() => {
        presenter2.selectDate(value2);
      }, [presenter2, value2]);
      return React.createElement(
        HStack,
        { ref, width: "auto", height: "auto", className: styles$w["date-picker"], tabIndex: 0 },
        React.createElement(
          VStack,
          { ref: calendarRef, inline: true, height: "auto", width: "auto", className: styles$w["date-picker-box"], "data-is-disabled": disabled },
          React.createElement(
            Pad,
            { start: "8px", end: "8px" },
            React.createElement(
              VStack,
              { height: "auto" },
              React.createElement(DatePickerHeader, { countryCode, presenter: presenter2 }),
              React.createElement(Divider, null),
              React.createElement(DatePickerBody, { countryCode, presenter: presenter2 })
            )
          ),
          renderActions && React.createElement(Pad, { start: "8px", end: "8px" }, renderActions(presenter2)),
          React.createElement(Spacer, { height: "8px" })
        ),
        showTime && React.createElement(
          React.Fragment,
          null,
          React.createElement(Spacer, { width: "8px" }),
          React.createElement(DatePickerTimeSelector, { height: `${calendarHeight}px`, origin: innerValue, max: state.max, min: state.min, minVisibleTimeInMilliseconds: state.minVisibleTimeInMilliseconds, maxVisibleTimeInMilliseconds: state.maxVisibleTimeInMilliseconds, intervalInMinutes: state.timeIntervalInMinutes, disabled, onSelect: (hour, minutes, seconds) => {
            presenter2.setHours(hour);
            presenter2.setMinutes(minutes);
            presenter2.setSeconds(seconds);
          } })
        )
      );
    });
    const button$2 = `_button_b2f9ca3`;
    const popover$1 = `_popover_ca8345c`;
    const styles$v = { button: button$2, popover: popover$1 };
    const dateRangePickerDate = `_date-range-picker-date_d040a64`;
    const dateRangePickerHighlightDate = `_date-range-picker-highlight-date_70dcb3e`;
    const dateRangePickerToday = `_date-range-picker-today_2533041`;
    const datePickerToday = `_date-picker-today_5cef6d5`;
    const styles$u = { "date-range-picker-date": dateRangePickerDate, "date-range-picker-highlight-date": dateRangePickerHighlightDate, "date-range-picker-today": dateRangePickerToday, "date-picker-today": datePickerToday };
    function DateRangePickerDate({ presenter: presenter2, date: calendarDate }) {
      const { value: selectedDate, potentialEndDate: pEndDate, visibleMonth, disabledDates, min: minDate, max: maxDate } = useSignalValue(presenter2.stateBroadcast);
      const startDate = selectedDate[0];
      const endDate = selectedDate[1] != null ? new Date(selectedDate[1]) : null;
      endDate && endDate.setDate(endDate.getDate() - 1);
      const potentialEndDate = pEndDate != null ? new Date(pEndDate) : null;
      potentialEndDate && potentialEndDate.setDate(potentialEndDate.getDate() - 1);
      const date = /* @__PURE__ */ new Date();
      const minTime = minDate == null ? -Infinity : minDate.getTime();
      const maxTime = maxDate == null ? Infinity : maxDate.getTime();
      const dateDate = new Date(calendarDate.year, calendarDate.month, calendarDate.date);
      const time = dateDate.getTime();
      const isWithinMonth = visibleMonth === calendarDate.month;
      const noPotential = potentialEndDate == null && endDate == null;
      const isSelectedStart = startDate != null && startDate.getMonth() === calendarDate.month && startDate.getFullYear() === calendarDate.year && startDate.getDate() === calendarDate.date;
      const isSelectedEnd = endDate != null && endDate.getMonth() === calendarDate.month && endDate.getFullYear() === calendarDate.year && endDate.getDate() === calendarDate.date;
      const isPotentialSelectionEnd = potentialEndDate != null && potentialEndDate.getMonth() === calendarDate.month && potentialEndDate.getFullYear() === calendarDate.year && potentialEndDate.getDate() === calendarDate.date;
      const isWithinSelection = startDate != null && endDate != null && time >= startDate.getTime() && time < endDate.getTime();
      const isWithinPotentialSelection = potentialEndDate != null && startDate != null && time >= startDate.getTime() && time < potentialEndDate.getTime();
      const isSelected = isWithinSelection || isWithinPotentialSelection;
      const isDisabled = disabledDates.some((d) => d.getMonth() === calendarDate.month && d.getFullYear() === calendarDate.year && d.getDate() === calendarDate.date);
      const isWithinRange = time >= minTime && time < maxTime;
      const isToday = date.getMonth() === calendarDate.month && date.getFullYear() === calendarDate.year && date.getDate() === calendarDate.date;
      function select2() {
        const date2 = new Date(calendarDate.year, calendarDate.month, calendarDate.date);
        presenter2.select(date2);
        if (presenter2.stateBroadcast.get().value[1] == null) {
          presenter2.selectPotential(date2);
        }
      }
      function selectPotentialDate() {
        const date2 = new Date(calendarDate.year, calendarDate.month, calendarDate.date);
        presenter2.selectPotential(date2);
      }
      const innerStyle = isSelectedStart || isSelectedEnd || isPotentialSelectionEnd;
      return React.createElement(
        "button",
        { disabled: !isWithinMonth || isDisabled || !isWithinRange, className: styles$u["date-range-picker-date"], onClick: select2, onMouseEnter: selectPotentialDate, "data-is-within-month": String(isWithinMonth), "data-is-selected": String(isSelected), "data-is-selected-end": String(isSelectedEnd || isPotentialSelectionEnd), "data-is-selected-start": String(isSelectedStart), "data-is-disabled": String(isDisabled), "data-is-within-range": String(isWithinRange), "data-is-today": String(isToday), "data-has-no-potential": noPotential },
        React.createElement(
          Pad,
          { amount: "1px" },
          React.createElement(
            ZStack,
            { className: classNames(innerStyle ? styles$u["date-range-picker-highlight-date"] : void 0), "data-is-selected-start": String(isSelectedStart), "data-is-selected-end": String(isSelectedEnd || isPotentialSelectionEnd) },
            React.createElement(BodyText, null, String(calendarDate.date)),
            isToday && React.createElement("div", { className: styles$u["date-range-picker-today"], "data-is-selected": String(isSelected), "data-is-selected-start": String(isSelectedStart), "data-is-selected-end": String(isSelectedEnd || isPotentialSelectionEnd) })
          )
        )
      );
    }
    const dateRangePickerDayText = `_date-range-picker-day-text_80aca6b`;
    const dateRangePickerDay = `_date-range-picker-day_8b4fc99`;
    const styles$t = { "date-range-picker-day-text": dateRangePickerDayText, "date-range-picker-day": dateRangePickerDay };
    function DateRangePickerDay({ dayOfTheWeek, countryCode }) {
      const date = /* @__PURE__ */ new Date();
      date.setDate(date.getDate() - date.getDay() + dayOfTheWeek);
      const weekdayName = new Intl.DateTimeFormat(countryCode, { weekday: "short" }).format(date).toLocaleUpperCase();
      return React.createElement(
        "div",
        { className: styles$t["date-range-picker-day"] },
        React.createElement(
          ZStack,
          null,
          React.createElement(BodyText, { className: styles$t["date-range-picker-day-text"] }, weekdayName[0])
        )
      );
    }
    function DateRangePickerBody({ presenter: presenter2, countryCode }) {
      const { visibleDates } = useSignalValue(presenter2.stateBroadcast);
      const rows = [];
      for (let i = 0; i < visibleDates.length; i += 7) {
        rows.push(visibleDates.slice(i, i + 7));
      }
      function clearPotentialEnd() {
        presenter2.clearPotential();
      }
      return React.createElement(
        VStack,
        { height: "auto", width: "auto", onMouseLeave: clearPotentialEnd },
        React.createElement(HStack, { height: "auto", width: "auto" }, new Array(7).fill(0).map((_, index) => {
          return React.createElement(
            FlexBox,
            { key: index, height: "auto" },
            React.createElement(DateRangePickerDay, { countryCode, dayOfTheWeek: index })
          );
        })),
        React.createElement(Divider, null),
        React.createElement(Divider, null),
        React.createElement(Spacer, { height: "1px" }),
        rows.map((dates, index) => {
          return React.createElement(
            React.Fragment,
            { key: index },
            React.createElement(HStack, { height: "auto", width: "auto" }, dates.map((date, index2) => {
              return React.createElement(DateRangePickerDate, { key: index2, date, presenter: presenter2 });
            })),
            React.createElement(Spacer, { height: "1px" })
          );
        })
      );
    }
    function makeMonthsOptions(countryCode) {
      const months = getMonthsOfYear(countryCode);
      return months.map((m, index) => {
        return React.createElement("option", { key: index, value: index }, m);
      });
    }
    function DateRangePickerHeader({ presenter: presenter2, countryCode }) {
      const state = useSignalValue(presenter2.stateBroadcast);
      const minYear = state.min.getFullYear();
      const maxDate = new Date(state.max);
      maxDate.setMilliseconds(maxDate.getMilliseconds() - 1);
      const maxYear = maxDate.getFullYear();
      const years = reactExports.useMemo(() => {
        const years2 = [];
        for (let i = minYear; i <= maxYear; i++) {
          years2.push(i);
        }
        return years2;
      }, [minYear, maxYear]);
      function selectMonth(value2) {
        presenter2.setVisibleMonth(Number(value2));
      }
      function selectYear(value2) {
        presenter2.setVisibleYear(Number(value2));
      }
      function previous() {
        return presenter2.setVisibleMonth(presenter2.stateBroadcast.get().visibleMonth - 1);
      }
      function next() {
        return presenter2.setVisibleMonth(presenter2.stateBroadcast.get().visibleMonth + 1);
      }
      const monthsOptions = reactExports.useMemo(() => {
        return makeMonthsOptions(countryCode);
      }, [countryCode]);
      return React.createElement(
        Pad,
        { height: "auto", amount: "4px" },
        React.createElement(
          HStack,
          { height: "auto", width: "100%" },
          React.createElement(IconButton, { disabled: !state.canNavigateToPreviousMonth, flipOnRtl: true, variant: "tertiary", iconSize: "20px", onClick: previous, iconName: "chevron_left" }),
          React.createElement(Spacer, null),
          React.createElement(
            HStack,
            { horizontalAlignment: "center", width: "auto" },
            React.createElement(Select, { variant: "tertiary", width: "auto", maxWidth: "150px", value: String(state.visibleMonth), onChange: selectMonth }, monthsOptions),
            React.createElement(Select, { variant: "tertiary", width: "auto", value: String(state.visibleYear), onChange: selectYear }, years.map((value2, index) => {
              return React.createElement("option", { key: index, value: value2 }, value2);
            }))
          ),
          React.createElement(Spacer, null),
          React.createElement(IconButton, { disabled: !state.canNavigateToNextMonth, flipOnRtl: true, variant: "tertiary", iconSize: "20px", onClick: next, iconName: "chevron_right" })
        )
      );
    }
    class DateRangePickerPresenter {
      constructor(value2, visibleYear, visibleMonth, showTime) {
        __publicField(this, "_state");
        __publicField(this, "_calendarDatesGenerator");
        __publicField(this, "_dateUtility");
        __publicField(this, "_defaultMinDate");
        __publicField(this, "_defaultMaxDate");
        const today = /* @__PURE__ */ new Date();
        const year = value2[0] == null ? today.getFullYear() : value2[0].getFullYear();
        const month = value2[0] == null ? today.getMonth() : value2[0].getMonth();
        this._dateUtility = /* @__PURE__ */ new Date();
        this._calendarDatesGenerator = new CalendarDatesGenerator(year, month);
        this._dateUtility.setFullYear(year);
        this._dateUtility.setMonth(month);
        this._defaultMinDate = new Date(today);
        this._defaultMaxDate = new Date(today);
        this._defaultMinDate.setFullYear(this._defaultMinDate.getFullYear() - 50);
        this._defaultMaxDate.setFullYear(this._defaultMaxDate.getFullYear() + 50);
        this._defaultMinDate.setHours(0, 0, 0, 0);
        this._defaultMaxDate.setHours(0, 0, 0, 0);
        const state = {
          value: this._normalizeValue(value2),
          potentialEndDate: null,
          error: null,
          visibleYear,
          visibleMonth,
          visibleDates: this._calendarDatesGenerator.dates,
          canNavigateToNextMonth: this._canNavigateToMonth(visibleMonth + 1, visibleYear, this._defaultMinDate, this._defaultMaxDate),
          canNavigateToPreviousMonth: this._canNavigateToMonth(visibleMonth - 1, visibleYear, this._defaultMinDate, this._defaultMaxDate),
          showTime,
          min: new Date(this._defaultMinDate),
          max: new Date(this._defaultMaxDate),
          disabledDates: []
        };
        this._state = new Signal(state);
        this._validate(this._state.get());
      }
      get stateBroadcast() {
        return this._state.broadcast;
      }
      get startDate() {
        return this._state.get().value[0];
      }
      get endDate() {
        return this._state.get().value[1];
      }
      _normalizeValue(value2) {
        const onlyHasEndDate = value2[0] == null && value2[1] != null;
        const endDateIsBeforeStartDate = value2[0] != null && value2[1] != null && value2[1].getTime() < value2[0].getTime();
        if (onlyHasEndDate) {
          value2[1] = null;
        }
        if (endDateIsBeforeStartDate) {
          value2[1] = null;
        }
        return value2;
      }
      isSelectingStartDate(potentialDate) {
        const startDate = this.startDate;
        const endDate = this.endDate;
        return startDate == null || startDate != null && potentialDate.getTime() < startDate.getTime() || startDate != null && endDate != null;
      }
      isSelectingEndDate(potentialDate) {
        const startDate = this.startDate;
        const endDate = this.endDate;
        return startDate != null && endDate == null && !this.isSelectingStartDate(potentialDate);
      }
      select(date) {
        const shouldSelectStartDate = this.isSelectingStartDate(date);
        const shouldSelectEndDate = this.isSelectingEndDate(date);
        if (shouldSelectStartDate) {
          this._selectStartDate(date);
          return;
        }
        if (shouldSelectEndDate) {
          const clone = new Date(date);
          clone.setDate(clone.getDate() + 1);
          this._selectEndDate(clone);
          return;
        }
      }
      selectPotential(date) {
        if (!this.isSelectingEndDate(date)) {
          return;
        }
        this._state.transform((s) => {
          const clone = new Date(date);
          clone.setDate(clone.getDate() + 1);
          s.potentialEndDate = clone;
          return s;
        });
      }
      clearPotential() {
        this._state.transform((s) => {
          s.potentialEndDate = null;
          return s;
        });
      }
      _selectStartDate(date) {
        this._state.transform((s) => {
          s.value[0] = date;
          s.value[1] = null;
          s.potentialEndDate = new Date(date);
          s.potentialEndDate.setHours(23, 59, 59, 999);
          s.value = [...s.value];
          this._validate(s);
          return s;
        });
      }
      _selectEndDate(date) {
        this._state.transform((s) => {
          s.value[1] = date;
          s.potentialEndDate = null;
          date.setHours(23, 59, 59, 999);
          s.value = [...s.value];
          this._validate(s);
          return s;
        });
      }
      _validate(state) {
        const error = state.error;
        let validationError = null;
        if (this.startDate != null && this.endDate != null) {
          const startTime = this.startDate.getTime();
          const endTime = this.endDate.getTime();
          const minTime = state.min == null ? -Infinity : state.min.getTime();
          const maxTime = state.max == null ? Infinity : state.max.getTime();
          if (startTime < minTime) {
            validationError = "Selected date is outside acceptable range.";
          } else if (endTime >= maxTime) {
            validationError = "Selected date is outside acceptable range.";
          }
          const isOnDisabledDate = state.disabledDates.some((d) => {
            d.setHours(0, 0, 0, 0);
            const time = d.getTime();
            return time >= startTime && time + 24 * 60 * 60 * 1e3 < endTime;
          });
          if (isOnDisabledDate) {
            validationError = "Selection includes a disabled date.";
          }
        }
        if (validationError !== error) {
          this._state.transform((s) => {
            s.error = validationError;
            return s;
          });
        }
      }
      setShowTime(showTime) {
        this._state.transform((s) => {
          s.showTime = showTime;
          return s;
        });
      }
      setVisibleYear(year) {
        const state = this._state.get();
        this._dateUtility.setFullYear(year);
        this._dateUtility.setDate(1);
        this._dateUtility.setMonth(state.visibleMonth);
        year = this._dateUtility.getFullYear();
        let month = this._dateUtility.getMonth();
        const newDateTime = this._dateUtility.getTime();
        const minDateTime = state.min.getTime();
        const maxDateTime = state.max.getTime();
        if (newDateTime < minDateTime) {
          year = state.min.getFullYear();
          month = state.min.getMonth();
        }
        if (newDateTime >= maxDateTime) {
          const date = new Date(state.max);
          date.setMilliseconds(date.getMilliseconds() - 1);
          year = date.getFullYear();
          month = date.getMonth();
        }
        this._state.transform((s) => {
          s.visibleYear = year;
          s.visibleMonth = month;
          this._calendarDatesGenerator.updateDates(year, month);
          this._updateNavigationAvailability(s);
          return s;
        });
      }
      _updateNavigationAvailability(s) {
        s.canNavigateToNextMonth = this._canNavigateToMonth(s.visibleMonth + 1, s.visibleYear, s.min, s.max);
        s.canNavigateToPreviousMonth = this._canNavigateToMonth(s.visibleMonth - 1, s.visibleYear, s.min, s.max);
      }
      setVisibleMonth(month) {
        const state = this._state.get();
        this._dateUtility.setFullYear(state.visibleYear);
        this._dateUtility.setDate(1);
        this._dateUtility.setMonth(month);
        month = this._dateUtility.getMonth();
        let year = this._dateUtility.getFullYear();
        const newDateTime = this._dateUtility.getTime();
        const minDateTime = state.min.getTime();
        const maxDateTime = state.max.getTime();
        if (newDateTime < minDateTime) {
          year = state.min.getFullYear();
          month = state.min.getMonth();
        }
        if (newDateTime >= maxDateTime) {
          const date = new Date(state.max);
          date.setMilliseconds(date.getMilliseconds() - 1);
          year = date.getFullYear();
          month = date.getMonth();
        }
        this._state.transform((s) => {
          s.visibleMonth = month;
          s.visibleYear = year;
          this._updateNavigationAvailability(s);
          this._calendarDatesGenerator.updateDates(year, month);
          return s;
        });
      }
      _canNavigateToMonth(month, year, minDate, maxDate) {
        this._dateUtility.setFullYear(year);
        this._dateUtility.setMonth(month);
        this._dateUtility.setDate(1);
        this._dateUtility.setHours(0, 0, 0, 0);
        const startTime = this._dateUtility.getTime();
        this._dateUtility.setFullYear(year);
        this._dateUtility.setMonth(month + 1);
        this._dateUtility.setDate(1);
        const endTime = this._dateUtility.getTime();
        const minDateTime = minDate.getTime();
        const maxDateTime = maxDate.getTime();
        const start = Math.max(minDateTime, startTime);
        const end = Math.min(maxDateTime, endTime);
        return start < end;
      }
      setMinDate(value2) {
        this._state.transform((s) => {
          if (value2 == null) {
            s.min = new Date(this._defaultMinDate);
          } else {
            s.min = new Date(value2);
            s.min.setHours(0, 0, 0, 0);
          }
          this._updateNavigationAvailability(s);
          this._validate(s);
          return s;
        });
      }
      setMaxDate(value2) {
        this._state.transform((s) => {
          if (value2 == null) {
            s.max = new Date(this._defaultMaxDate);
          } else {
            s.max = new Date(value2);
            s.max.setHours(0, 0, 0, 0);
          }
          this._updateNavigationAvailability(s);
          this._validate(s);
          return s;
        });
      }
      setDisabledDates(dates) {
        this._state.transform((s) => {
          s.disabledDates = dates;
          this._validate(s);
          return s;
        });
      }
      clear() {
        this._state.transform((s) => {
          s.value[0] = null;
          s.value[1] = null;
          s.potentialEndDate = null;
          this._validate(s);
          return s;
        });
      }
    }
    const dateRangePicker = `_date-range-picker_2d1e5ec`;
    const styles$s = { "date-range-picker": dateRangePicker };
    React.forwardRef(function DateRangePicker({ value: value2, disabled: disable, onChange, onError, showTime = false, min: minDate = null, max: maxDate = null, disabledDates, countryCode = "en-US", renderActions }, ref) {
      const [presenter2] = reactExports.useState(() => {
        const today = /* @__PURE__ */ new Date();
        const year = value2[0] == null ? today.getFullYear() : value2[0].getFullYear();
        const month = value2[0] == null ? today.getMonth() : value2[0].getMonth();
        return new DateRangePickerPresenter(value2, year, month, showTime);
      });
      const state = useSignalValue(presenter2.stateBroadcast);
      const error = state.error;
      useSignalValueEffect((innerState) => {
        error !== innerState.error && onError && onError(innerState.error);
      }, presenter2.stateBroadcast);
      useSignalValueEffect((state2) => {
        onChange && onChange(state2.value);
      }, presenter2.stateBroadcast);
      reactExports.useLayoutEffect(() => {
        presenter2.setShowTime(showTime);
      }, [presenter2, showTime]);
      reactExports.useLayoutEffect(() => {
        if (minDate == null) {
          presenter2.setMinDate(null);
        } else {
          presenter2.setMinDate(minDate);
        }
      }, [presenter2, minDate]);
      reactExports.useLayoutEffect(() => {
        if (maxDate == null) {
          presenter2.setMaxDate(null);
        } else {
          presenter2.setMaxDate(maxDate);
        }
      }, [presenter2, maxDate]);
      reactExports.useLayoutEffect(() => {
        if (disabledDates == null) {
          presenter2.setDisabledDates([]);
        } else {
          presenter2.setDisabledDates(disabledDates);
        }
      }, [presenter2, disabledDates]);
      return React.createElement(
        VStack,
        { ref, className: styles$s["date-range-picker"], "data-is-disabled": disable, inline: true, height: "auto", width: "auto" },
        React.createElement(
          Pad,
          { start: "8px", end: "8px" },
          React.createElement(
            VStack,
            { height: "auto", width: "auto" },
            React.createElement(DateRangePickerHeader, { countryCode, presenter: presenter2 }),
            React.createElement(Divider, null),
            React.createElement(DateRangePickerBody, { countryCode, presenter: presenter2 })
          )
        ),
        React.createElement(Pad, { start: "8px", end: "8px" }, renderActions && renderActions(presenter2)),
        React.createElement(Spacer, { height: "8px" })
      );
    });
    const button$1 = `_button_533e7ad`;
    const popover = `_popover_93c369c`;
    const styles$r = { button: button$1, popover };
    const selectGroup = `_select-group_b59b8f1`;
    const divider$3 = `_divider_99dc837`;
    const option = `_option_2a62c50`;
    const styles$q = { "select-group": selectGroup, divider: divider$3, option };
    const SelectGroup = React.forwardRef(function ButtonGroup2({ children, value: value2, className, onChange, enableDeselect, enableMultiselect, disabled = false, ...props }, ref) {
      const options = Array.isArray(children) ? children : [children];
      return React.createElement(HStack, { ref, inline: true, width: "auto", height: "auto", "data-is-disabled": disabled, className: classNames(styles$q["select-group"], className, "select-group"), ...props }, options.map((option2, i) => {
        function select2() {
          const newValue = [...value2];
          if (value2.includes(option2.props.value)) {
            if (enableDeselect) {
              const index = newValue.indexOf(option2.props.value);
              index > -1 && newValue.splice(index, 1);
            }
          } else {
            if (!enableMultiselect) {
              newValue.length = 0;
            }
            newValue.push(option2.props.value);
          }
          onChange && onChange(newValue);
        }
        const isLast = options.length - 1 === i;
        return React.createElement(
          React.Fragment,
          { key: i },
          React.createElement(Button, { disabled, "data-is-disabled": disabled, className: classNames(styles$q["option"], "select-group-option"), variant: value2.includes(option2.props.value) ? "primary" : "secondary", onClick: select2 }, children[i].props.children),
          !isLast && React.createElement("div", { className: classNames(styles$q.divider, "select-group-divider") })
        );
      }));
    });
    const actions$1 = `_actions_6c50f05`;
    const styles$p = { actions: actions$1 };
    const buttonGroup = `_button-group_b9756bf`;
    const button = `_button_abd4586`;
    const divider$2 = `_divider_d1b6707`;
    const styles$o = { "button-group": buttonGroup, button, divider: divider$2 };
    const ButtonGroup = React.forwardRef(function ButtonGroup2({ children, className, variant = "secondary", ...props }, ref) {
      const buttons = Array.isArray(children) ? children : [children];
      return React.createElement(HStack, { ref, inline: true, width: "auto", height: "auto", "data-variant": variant, className: classNames(styles$o["button-group"], className, "button-group"), ...props }, buttons.map((button2, i) => {
        const isLast = buttons.length - 1 === i;
        return React.createElement(
          React.Fragment,
          { key: i },
          React.createElement(Button, { className: styles$o["button"], ...button2.props, variant }),
          !isLast && React.createElement("div", { className: styles$o.divider })
        );
      }));
    });
    const unitInput = `_unit-input_197ff2c`;
    const unitInputFlexBox = `_unit-input-flex-box_57df10f`;
    const unitInputNumber = `_unit-input-number_7e80a49`;
    const unitInputSelect = `_unit-input-select_6070343`;
    const styles$n = { "unit-input": unitInput, "unit-input-flex-box": unitInputFlexBox, "unit-input-number": unitInputNumber, "unit-input-select": unitInputSelect };
    function getDisplayValue(value2) {
      return value2.replace(/[^.\d-]/g, "").replace(/(?!^)-/g, "").replace(/(\..*?)\.+/g, "$1");
    }
    const UnitInput = React.forwardRef(function UnitInput2({ value: value2, unit, children, onChange, inputRef, unitRef, disabled, ...props }, ref) {
      const internalInputRef = reactExports.useRef(null);
      const forkedInputRef = useForkRef(inputRef, internalInputRef);
      function valueHandler(value3, event) {
        if (event == null) {
          return;
        }
        const input2 = event.currentTarget;
        const cursorPosition = input2.selectionStart || 0;
        const displayValue = getDisplayValue(value3);
        const potentialValue = Number(displayValue);
        input2.value = displayValue;
        if (displayValue.length < value3.length) {
          input2.setSelectionRange(cursorPosition - 1, cursorPosition - 1);
        }
        if (displayValue === "") {
          onChange && onChange(null, unit || "");
        } else if (!isNaN(potentialValue)) {
          onChange && onChange(potentialValue, unit || "");
        }
      }
      function unitHandler(unit2) {
        const input2 = internalInputRef.current;
        if (input2 == null) {
          return;
        }
        const potentialValue = Number(input2.value);
        if (isNaN(potentialValue)) {
          onChange && onChange(null, unit2);
        } else {
          onChange && onChange(potentialValue, unit2);
        }
      }
      return React.createElement(
        HStack,
        { ref, className: classNames(styles$n["unit-input"], "unit-input"), height: "auto", ...props },
        React.createElement(
          FlexBox,
          { className: styles$n["unit-input-flex-box"] },
          React.createElement(Input$1, { className: classNames(styles$n["unit-input-number"], "unit-input-number"), ref: forkedInputRef, onChange: valueHandler, disabled, style: {
            borderEndEndRadius: 0,
            borderStartEndRadius: 0,
            textAlign: "end"
          } })
        ),
        React.createElement(Select, { className: classNames(styles$n["unit-input-select"], "unit-input-select"), selectRef: unitRef, width: "auto", value: unit, onChange: unitHandler, disabled, selectProps: {
          style: { borderStartStartRadius: 0, borderEndStartRadius: 0 }
        } }, children)
      );
    });
    const KeyCaptureInput = React.forwardRef(function InputCapture({ onKeyCapture, onKeyDown, onInput, ...props }, ref) {
      const valueLengthRef = reactExports.useRef(0);
      const selectionStartRef = reactExports.useRef(0);
      const selectionEndRef = reactExports.useRef(0);
      const minCursorPositionRef = reactExports.useRef(0);
      const maxCursorPositionRef = reactExports.useRef(0);
      const cursorPositionRef = reactExports.useRef(0);
      const inputRef = reactExports.useRef(null);
      const forkedRef = useForkRef(ref, inputRef);
      function handleKeydown(event) {
        const inputElement = inputRef.current;
        if (inputElement == null) {
          return;
        }
        valueLengthRef.current = inputElement.value.length;
        selectionStartRef.current = inputElement.selectionStart == null ? 0 : inputElement.selectionStart;
        selectionEndRef.current = inputElement.selectionEnd == null ? 0 : inputElement.selectionEnd;
        cursorPositionRef.current = selectionEndRef.current;
        minCursorPositionRef.current = Math.min(selectionStartRef.current, selectionEndRef.current);
        maxCursorPositionRef.current = Math.max(selectionStartRef.current, selectionEndRef.current);
        onKeyDown && onKeyDown(event);
      }
      function handleInput(event) {
        const inputElement = inputRef.current;
        if (inputElement == null) {
          return;
        }
        const valueLength = inputElement.value.length;
        const hadSelection = selectionStartRef.current !== selectionEndRef.current;
        const inputSelectionStart = inputElement.selectionStart == null ? 0 : inputElement.selectionStart;
        const inputSelectionEnd = inputElement.selectionEnd == null ? 0 : inputElement.selectionEnd;
        const minCursorPosition = Math.min(inputSelectionStart, inputSelectionEnd);
        const maxCursorPosition = Math.max(inputSelectionStart, inputSelectionEnd);
        const cursorPosition = inputSelectionEnd;
        if (hadSelection) {
          const input2 = inputElement.value.slice(minCursorPositionRef.current, maxCursorPosition);
          const selection = {
            start: selectionStartRef.current,
            end: selectionEndRef.current
          };
          onKeyCapture && onKeyCapture(input2, "", selection, cursorPositionRef.current, cursorPosition, inputElement);
        } else {
          const collapsed = valueLengthRef.current > valueLength;
          if (collapsed) {
            const deleted = minCursorPositionRef.current === minCursorPosition;
            if (deleted) {
              onKeyCapture && onKeyCapture("", "Delete", null, cursorPositionRef.current, cursorPosition, inputElement);
            } else {
              onKeyCapture && onKeyCapture("", "Backspace", null, cursorPositionRef.current, cursorPosition, inputElement);
            }
          } else {
            const input2 = inputElement.value.slice(minCursorPositionRef.current, maxCursorPosition);
            onKeyCapture && onKeyCapture(input2, "", null, cursorPositionRef.current, cursorPosition, inputElement);
          }
        }
        onInput && onInput(event);
      }
      return React.createElement(Input$1, { ref: forkedRef, onKeyDown: handleKeydown, onInput: handleInput, ...props });
    });
    class Character {
      constructor(_character, _placeholderCharacter) {
        __publicField(this, "type");
        __publicField(this, "value");
        __publicField(this, "placeholder");
        this.type = "character";
        this.value = _character;
        this.placeholder = _placeholderCharacter == null ? _character : _placeholderCharacter;
      }
      enterFromRight(_cursor) {
        return;
      }
      enterFromLeft(_cursor) {
        return;
      }
      enter(_cursor) {
        return;
      }
      insert(_value, _cursor) {
        return false;
      }
      delete() {
        return;
      }
      isFilled() {
        return false;
      }
    }
    class RegexCharacter extends Character {
      constructor(character, regex, placeholderCharacter) {
        super(character, placeholderCharacter);
        __publicField(this, "regex");
        __publicField(this, "isValueSet", false);
        this.type = "regex";
        this.regex = regex;
        this.value = placeholderCharacter == null ? "_" : placeholderCharacter;
        this.placeholder = this.value;
      }
      enter(cursor) {
        if (!this.isFilled() && cursor.isPreviousCharacterEmpty()) {
          cursor.moveLeft();
        }
      }
      enterFromRight(cursor) {
        const position = cursor.getCursorPosition();
        const isFilledBeyondCurrentPosition = cursor.isFilledBeyondIndex(position);
        if (!this.isFilled() && !isFilledBeyondCurrentPosition) {
          cursor.moveLeft();
        }
        if (this.isFilled()) {
          cursor.moveRight();
        }
      }
      insert(value2, cursor) {
        const passed = this.regex.test(value2);
        if (passed && this.isValueSet) {
          const position = cursor.getCursorPosition();
          cursor.moveRight();
          cursor.insertPush(this.value);
          cursor.moveTo(position);
        }
        if (passed) {
          this.isValueSet = true;
          this.value = value2;
          return true;
        }
        return false;
      }
      delete() {
        this.isValueSet = false;
        this.value = this.placeholder;
      }
      isFilled() {
        return this.isValueSet;
      }
    }
    class AlphaCharacter extends RegexCharacter {
      /**
       *
       * @param character The character supplied to the mask.
       * @param placeholder The placeholder supplied to the mask.
       */
      constructor(character, placeholder) {
        super(character, /[a-zA-Z]/, placeholder);
        this.type = "alpha";
      }
    }
    class AlphaNumericCharacter extends RegexCharacter {
      /**
       *
       * @param character The character supplied to the mask.
       * @param placeholder The placeholder supplied to the mask.
       */
      constructor(character, placeholder) {
        super(character, /[a-zA-Z0-9]/, placeholder);
        this.type = "alpha-numeric";
      }
    }
    class ConstantCharacter extends Character {
      constructor(character, placeholderCharacter) {
        super(character, placeholderCharacter);
        this.type = "constant";
        this.value = character;
        this.placeholder = placeholderCharacter == null ? character : placeholderCharacter;
      }
      enterFromRight(cursor) {
        const position = cursor.getCursorPosition();
        const isEmptyBeforeCurrentPosition = cursor.isEmptyBeforeIndex(position);
        if (isEmptyBeforeCurrentPosition) {
          cursor.moveLeft();
        }
        if (cursor.arePreviousCharactersAllConstants() || position === 0) {
          cursor.moveRight();
        }
      }
      enter(cursor) {
        if (cursor.isPreviousCharacterEmpty()) {
          cursor.moveLeft();
        }
      }
      insert(value2, cursor) {
        if (value2 === this.value) {
          return true;
        }
        cursor.moveRight();
        if (cursor.getCursorPosition() !== cursor.getCharacterLength() - 1) {
          return cursor.insert(value2);
        }
        return false;
      }
      isFilled() {
        return true;
      }
    }
    class LanguageCharacter extends RegexCharacter {
      /**
       *
       * @param character The character supplied to the mask.
       * @param placeholder The placeholder supplied to the mask.
       */
      constructor(character, placeholder) {
        super(character, /[\p{L}]/u, placeholder);
        this.type = "language-character";
      }
    }
    class NumericCharacter extends RegexCharacter {
      /**
       *
       * @param character The character supplied to the mask.
       * @param placeholder The placeholder supplied to the mask.
       */
      constructor(character, placeholder) {
        super(character, /[0-9]/, placeholder);
        this.type = "numeric";
      }
    }
    const characterMap = {
      a: AlphaCharacter,
      "9": NumericCharacter,
      "*": AlphaNumericCharacter,
      u: LanguageCharacter
    };
    const dynamicCharacters = Object.keys(characterMap);
    class Mask {
      constructor(config2) {
        __publicField(this, "_cursorPosition");
        __publicField(this, "_characters");
        this._cursorPosition = 0;
        this._characters = this._makeCharacters(config2);
      }
      get currentCharacter() {
        return this._characters[this._cursorPosition];
      }
      moveRight() {
        this._cursorPosition = Math.min(this._characters.length, this._cursorPosition + 1);
        this.currentCharacter && this.currentCharacter.enterFromLeft(this);
      }
      moveLeft() {
        if (this._cursorPosition === 0) {
          return;
        }
        this._cursorPosition = Math.max(0, this._cursorPosition - 1);
        this.currentCharacter && this.currentCharacter.enterFromRight(this);
      }
      forceMoveTo(position) {
        const finalPosition = Math.min(this.getCharacterLength(), position);
        this._cursorPosition = finalPosition;
      }
      moveTo(position) {
        const prevCharacter = this._characters[position - 1];
        const isCursorBeyond = position >= this._characters.length;
        this._cursorPosition = position;
        if (isCursorBeyond && prevCharacter && !prevCharacter.isFilled()) {
          this.moveLeft();
        }
        this.currentCharacter && this.currentCharacter.enter(this);
      }
      getCursorPosition() {
        return this._cursorPosition;
      }
      insert(character) {
        const parts = [...character];
        if (parts.length > 1) {
          throw new Error("You can only insert a single character.");
        }
        if (this.currentCharacter) {
          return this.currentCharacter.insert(character, this);
        }
        return false;
      }
      insertPush(character) {
        const parts = [...character];
        if (parts.length > 1) {
          throw new Error("You can only insert a single character.");
        }
        if (this.currentCharacter != null && this.currentCharacter.type !== "constant") {
          return this.currentCharacter.insert(character, this);
        }
        return false;
      }
      deleteCharacter() {
        this.currentCharacter && this.currentCharacter.delete();
      }
      clearAll() {
        this._characters.forEach((c) => c.delete());
        this._cursorPosition = 0;
      }
      clearRange(start, end) {
        end = end == null ? this._characters.length - 1 : end;
        for (let i = start; i < end; i++) {
          this._characters[i] && this._characters[i].delete();
        }
      }
      getFilledValue() {
        const cursorPosition = this._cursorPosition;
        const characters = [];
        for (let x = 0; x < this._characters.length; x++) {
          const c = this._characters[x];
          if (!c.isFilled() && c.type !== "constant") {
            let hasMoreFilled = false;
            for (let i = x; i < this._characters.length; i++) {
              const character = this._characters[i];
              if (character.isFilled() && character.type !== "constant") {
                hasMoreFilled = true;
                break;
              }
            }
            if (!hasMoreFilled) {
              while (cursorPosition > x) {
                const constantCharacter = this._characters[x];
                characters.push(constantCharacter.value);
                x++;
              }
              break;
            }
          }
          characters.push(c.value);
        }
        return characters.join("");
      }
      isFilledBeyondIndex(index) {
        for (let x = index + 1; x < this._characters.length; x++) {
          if (this._characters[x].isFilled() && this._characters[x].type !== "constant") {
            return true;
          }
        }
        return false;
      }
      isEmptyBeforeIndex(index) {
        for (let x = index - 1; x > 0; x--) {
          if (!this._characters[x].isFilled()) {
            return true;
          }
        }
        return false;
      }
      isPreviousCharacterEmpty() {
        const index = this._cursorPosition - 1;
        const character = this._characters[index];
        if (character == null) {
          return false;
        }
        if (character.type === "constant" && !this.arePreviousCharactersAllConstants()) {
          return true;
        }
        return !character.isFilled();
      }
      arePreviousCharactersAllConstants(index = this._cursorPosition - 1) {
        return this._characters.slice(0, index).every((c) => c.type === "constant");
      }
      ifFilled() {
        return this._characters.filter((c) => c.type !== "constant").every((c) => c.isFilled());
      }
      getValue() {
        return this._characters.map((c) => c.value).join("");
      }
      getFilledLength() {
        return this.getFilledValue().length;
      }
      getValueLength() {
        return this.getValue().length;
      }
      getCharacterLength() {
        return this._characters.length;
      }
      getInsertableSlotLength() {
        return this._characters.filter((c) => c.type !== "constant").length;
      }
      getInsertableSlotIndexForCharacter(characterIndex) {
        let insertableSlotCount = 0;
        const length = Math.min(characterIndex, this._characters.length - 1);
        for (let x = 0; x < length; x++) {
          const character = this._characters[x];
          if (character.type !== "constant") {
            insertableSlotCount++;
          }
        }
        return insertableSlotCount;
      }
      getCharacterIndexforInsertableSlotIndex(slotIndex) {
        let insertableSlotCount = 0;
        for (let x = 0; x < this._characters.length; x++) {
          const character = this._characters[x];
          if (character.type !== "constant") {
            insertableSlotCount++;
          }
          if (insertableSlotCount > slotIndex) {
            return x;
          }
        }
        return this._characters.length;
      }
      getInsertableSlotValues() {
        const values = this._characters.filter((c) => c.type !== "constant" && c.isFilled()).map((c) => c.value).join("");
        return values;
      }
      getValueWithinRange(start, end) {
        const characters = [];
        for (let x = start; x < end; x++) {
          characters.push(this._characters[x].value);
        }
        return characters.join("");
      }
      _makeCharacters(config2) {
        const { mask, placeholder } = config2;
        const characters = [];
        const { maskParts, placeholderParts } = this._getParts(mask, placeholder);
        for (let x = 0; x < maskParts.length; x++) {
          let character = maskParts[x];
          let placeholderCharacter = placeholderParts[x];
          const isEscaping = character === "\\";
          const CharacterType = characterMap[character];
          if (isEscaping || CharacterType == null) {
            if (isEscaping) {
              x++;
              character = maskParts[x];
            }
            characters.push(new ConstantCharacter(character, placeholderCharacter));
          } else {
            characters.push(new CharacterType(character, placeholderCharacter));
          }
        }
        return characters;
      }
      _getParts(mask, placeholder) {
        const parts = [...mask];
        const placeholderParts = placeholder != null ? [...placeholder] : new Array(parts.length);
        if (placeholderParts.length !== parts.length) {
          throw new Error("Invalid mask overlay. It needs to be the exact character length as the mask.");
        }
        this._validateMask(mask, parts);
        return {
          maskParts: parts,
          placeholderParts
        };
      }
      _validateMask(mask, parts) {
        if (mask.length === 0) {
          throw new Error("Mask cannot be an empty string.");
        }
        const constants = parts.filter((c) => dynamicCharacters.indexOf(c) === -1);
        if (constants.length === parts.length) {
          throw new Error("You cannot have a mask that is all constants.");
        }
      }
    }
    function areMasksUniqueLengths(masks) {
      const set = /* @__PURE__ */ new Set();
      masks.forEach((m) => set.add(m.getCharacterLength()));
      return set.size === masks.length;
    }
    function maskSort(a, b) {
      if (a.getInsertableSlotLength() > b.getInsertableSlotLength()) {
        return 1;
      } else if (a.getInsertableSlotLength() > b.getInsertableSlotLength()) {
        return -1;
      } else {
        return a.getCharacterLength() - b.getCharacterLength();
      }
    }
    class MaskPresenter {
      constructor(maskConfigs) {
        __publicField(this, "_masks");
        __publicField(this, "_currentMaskIndex");
        __publicField(this, "_value");
        __publicField(this, "_filledValue");
        __publicField(this, "_cursorPosition");
        __publicField(this, "_selection");
        __publicField(this, "_maskConfigs");
        this._masks = this._createMasks(maskConfigs);
        this._currentMaskIndex = 0;
        this._cursorPosition = new Signal(0);
        this._value = new Signal(this._masks[this._currentMaskIndex].getValue());
        this._filledValue = new Signal(this._masks[this._currentMaskIndex].getFilledValue());
        this._selection = new Signal(null);
        this._maskConfigs = new Signal(maskConfigs);
      }
      get valueBroadcast() {
        return this._value.broadcast;
      }
      get filledValueBroadcast() {
        return this._filledValue.broadcast;
      }
      get cursorPositionBroadcast() {
        return this._cursorPosition.broadcast;
      }
      get selectionBroadcast() {
        return this._selection.broadcast;
      }
      get currentMask() {
        return this._masks[this._currentMaskIndex];
      }
      get maskConfigsBroadcast() {
        return this._maskConfigs.broadcast;
      }
      _createMasks(maskConfigs) {
        const masks = maskConfigs.map((c) => new Mask(c));
        if (maskConfigs.length < 1) {
          throw new Error("Have to have at least one mask.");
        }
        if (!areMasksUniqueLengths(masks)) {
          throw new Error("Masks need to be different lengths.");
        }
        masks.sort(maskSort);
        return masks;
      }
      initialize() {
        this.moveCursorTo(0);
      }
      isComplete() {
        return this.currentMask.ifFilled();
      }
      setMaskConfigs(maskConfigs) {
        const oldValue = this._value.get();
        this._masks = this._createMasks(maskConfigs);
        this._currentMaskIndex = 0;
        this.moveCursorTo(0);
        this.insertText(oldValue);
        this._maskConfigs.set(maskConfigs);
      }
      setValue(value2) {
        if (this._value.get() === value2) {
          return;
        }
        const cursorPosition = this._cursorPosition.get();
        this.moveCursorTo(0);
        this.insertText(value2);
        this.moveCursorTo(cursorPosition);
      }
      insertText(text) {
        const characters = [...text];
        const selection = this._selection.get();
        if (selection != null) {
          this._removeCharactersWithinSelection(selection);
        }
        if (characters.length < 1) {
          const newValue2 = this.currentMask.getValue();
          const newFilledValue2 = this.currentMask.getFilledValue();
          this._transitionToPreviousMaskIfNecessary();
          this._value.set(newValue2);
          this._filledValue.set(newFilledValue2);
          this._cursorPosition.set(this.currentMask.getCursorPosition());
          return;
        }
        for (let character of characters) {
          const needsToTransitionToNextMask = this.currentMask.ifFilled() && this._currentMaskIndex + 1 < this._masks.length;
          if (needsToTransitionToNextMask) {
            const isOnLast = this.currentMask.getCursorPosition() >= this.currentMask.getCharacterLength();
            const insertableSlotIndex = this.currentMask.getInsertableSlotIndexForCharacter(this.currentMask.getCursorPosition());
            const insertedText = this.currentMask.getInsertableSlotValues();
            this._currentMaskIndex += 1;
            this.currentMask.clearAll();
            this.insertText(insertedText);
            const cursorPosition = this.currentMask.getCharacterIndexforInsertableSlotIndex(insertableSlotIndex);
            if (isOnLast) {
              this.currentMask.moveTo(cursorPosition + 1);
            } else {
              this.currentMask.moveTo(cursorPosition);
            }
          }
          const inserted = this.currentMask.insert(character);
          inserted && this.currentMask.moveRight();
        }
        const newValue = this.currentMask.getValue();
        const newFilledValue = this.currentMask.getFilledValue();
        this._value.set(newValue);
        this._filledValue.set(newFilledValue);
        this._cursorPosition.set(this.currentMask.getCursorPosition());
      }
      delete() {
        const selection = this._selection.get();
        if (selection != null) {
          this._removeCharactersWithinSelection(selection);
        } else {
          this.currentMask.deleteCharacter();
        }
        this._transitionToPreviousMaskIfNecessary();
        this._value.set(this.currentMask.getValue());
        this._filledValue.set(this.currentMask.getFilledValue());
        this._cursorPosition.set(this.currentMask.getCursorPosition());
      }
      _transitionToPreviousMaskIfNecessary() {
        const prevMask = this._masks[this._currentMaskIndex - 1];
        const needsToTransitionToPrevMask = prevMask && this.currentMask.getInsertableSlotValues().length <= prevMask.getInsertableSlotLength();
        if (needsToTransitionToPrevMask) {
          const insertableSlotIndex = this.currentMask.getInsertableSlotIndexForCharacter(this.currentMask.getCursorPosition());
          const text = this.currentMask.getInsertableSlotValues();
          this._currentMaskIndex -= 1;
          prevMask.clearAll();
          this.currentMask.moveTo(0);
          this.insertText(text);
          const cursorPosition = this.currentMask.getCharacterIndexforInsertableSlotIndex(insertableSlotIndex);
          this.currentMask.moveTo(cursorPosition);
        }
      }
      _removeCharactersWithinSelection(selection) {
        this.currentMask.clearRange(selection.start, selection.end);
        this.currentMask.moveTo(selection.start);
        this.removeSelection();
      }
      backspace() {
        const selection = this._selection.get();
        if (selection != null) {
          this._removeCharactersWithinSelection(selection);
        } else {
          this.currentMask.moveTo(this.currentMask.getCursorPosition() - 1);
          this.currentMask.deleteCharacter();
        }
        this._transitionToPreviousMaskIfNecessary();
        this._value.set(this.currentMask.getValue());
        this._filledValue.set(this.currentMask.getFilledValue());
        this._cursorPosition.set(this.currentMask.getCursorPosition());
        if (this.currentMask.getFilledLength() === 0) {
          this._currentMaskIndex = 0;
          this.currentMask.clearAll();
        }
      }
      moveCursorRight() {
        this.removeSelection();
        this.currentMask.moveRight();
        this._cursorPosition.set(this.currentMask.getCursorPosition());
      }
      moveCursorLeft() {
        this.removeSelection();
        this.currentMask.moveLeft();
        this._cursorPosition.set(this.currentMask.getCursorPosition());
      }
      moveCursorTo(position) {
        const finalPosition = Math.min(this.currentMask.getValueLength(), position);
        this.removeSelection();
        this.currentMask.moveTo(finalPosition);
        this._cursorPosition.set(this.currentMask.getCursorPosition());
      }
      forceMoveCursorTo(position) {
        this.currentMask.forceMoveTo(position);
      }
      clearRange(start, end) {
        this.currentMask.clearRange(start, end);
        this.currentMask.moveTo(start);
        this._value.set(this.currentMask.getValue());
        this._filledValue.set(this.currentMask.getFilledValue());
        this._cursorPosition.set(this.currentMask.getCursorPosition());
      }
      clearAll() {
        this.selectAll();
        this.backspace();
      }
      getLength() {
        return this.currentMask.getValueLength();
      }
      selectAll() {
        this.setSelection(0, this.currentMask.getValueLength());
      }
      setSelection(start, end) {
        this._selection.set({ start: Math.min(start, end), end: Math.max(start, end) });
        this._cursorPosition.set(start);
      }
      removeSelection() {
        this._selection.transform((_) => {
          return null;
        });
      }
      getSelectedValue() {
        const selection = this._selection.get();
        if (selection != null) {
          return this.currentMask.getValueWithinRange(selection.start, selection.end);
        }
        return "";
      }
    }
    const MaskInput = React.forwardRef(function MaskInput2({ value: value2 = "", onChange, mask, onPaste, onCut, onCopy, ...props }, ref) {
      const masks = Array.isArray(mask) ? mask : [mask];
      const inputRef = reactExports.useRef(null);
      const forkedRef = useForkRef(ref, inputRef);
      const [presenter2] = reactExports.useState(() => {
        const presenter3 = new MaskPresenter(masks);
        return presenter3;
      });
      const internalValue = useSignalValue(presenter2.valueBroadcast);
      useSignalValue(presenter2.maskConfigsBroadcast);
      function handleInput(input2, key, selection, cursorPosition, _, inputElement) {
        if (selection != null) {
          presenter2.setSelection(selection.start, selection.end);
        } else {
          presenter2.forceMoveCursorTo(cursorPosition);
        }
        switch (key) {
          case "Delete": {
            presenter2.delete();
          }
          case "Backspace": {
            presenter2.backspace();
          }
        }
        presenter2.insertText(input2);
        const value3 = presenter2.valueBroadcast.get();
        const resolvedCursorPosition = presenter2.cursorPositionBroadcast.get();
        inputElement.value = value3;
        inputElement.setSelectionRange(resolvedCursorPosition, resolvedCursorPosition);
        onChange && onChange(value3, presenter2.isComplete());
      }
      reactExports.useLayoutEffect(() => {
        const masks2 = Array.isArray(mask) ? mask : [mask];
        const oldMaskString = masks2.map((m) => m.mask).join("|");
        const newMaskString = presenter2.maskConfigsBroadcast.get().map((m) => m.mask).join("|");
        if (oldMaskString !== newMaskString) {
          presenter2.setMaskConfigs(masks2);
        }
      }, [presenter2, mask]);
      reactExports.useLayoutEffect(() => {
        presenter2.setValue(value2);
        const selection = presenter2.selectionBroadcast.get();
        const cursorPosition = presenter2.cursorPositionBroadcast.get();
        const input2 = inputRef.current;
        if (input2 != null) {
          const hasSelection = selection != null;
          if (hasSelection) {
            input2.setSelectionRange(selection.start, selection.end);
          } else {
            input2.setSelectionRange(cursorPosition, cursorPosition);
          }
        }
      }, [presenter2, value2]);
      function handlePaste(event) {
        const inputElement = event.currentTarget;
        const start = inputElement.selectionStart;
        const end = inputElement.selectionEnd;
        const hasSelection = start != null && end != null && start !== end;
        if (hasSelection) {
          presenter2.setSelection(start, end);
        } else {
          presenter2.moveCursorTo(start || 0);
        }
        presenter2.insertText(event.clipboardData.getData("text/plain"));
        const resolvedCursorPosition = presenter2.cursorPositionBroadcast.get();
        inputElement.value = presenter2.valueBroadcast.get();
        inputElement.setSelectionRange(resolvedCursorPosition, resolvedCursorPosition);
        event.preventDefault();
        onPaste && onPaste(event);
      }
      function handleCut(event) {
        const inputElement = event.currentTarget;
        const start = inputElement.selectionStart;
        const end = inputElement.selectionEnd;
        const hasSelection = start != null && end != null && start !== end;
        if (hasSelection) {
          presenter2.setSelection(start, end);
          const value3 = presenter2.getSelectedValue();
          presenter2.clearRange(start, end);
          const resolvedCursorPosition = presenter2.cursorPositionBroadcast.get();
          event.clipboardData.setData("text/plain", value3);
          inputElement.value = presenter2.valueBroadcast.get();
          inputElement.setSelectionRange(resolvedCursorPosition, resolvedCursorPosition);
        }
        event.preventDefault();
        onCut && onCut(event);
      }
      function handleCopy(event) {
        const input2 = event.currentTarget;
        const start = input2.selectionStart;
        const end = input2.selectionEnd;
        const hasSelection = start != null && end != null && start !== end;
        if (hasSelection) {
          presenter2.setSelection(start, end);
          const value3 = presenter2.getSelectedValue();
          event.clipboardData.setData("text/plain", value3);
        }
        event.preventDefault();
        onCopy && onCopy(event);
      }
      reactExports.useLayoutEffect(() => {
        let mode = "unknown";
        const input2 = inputRef.current;
        if (input2 == null) {
          return;
        }
        function handleMouseDown() {
          mode = "mouse";
        }
        function handleKeyDown() {
          mode = "keyboard";
        }
        function handleSelection() {
          const input3 = inputRef.current;
          if (input3 == null) {
            return;
          }
          const start = input3.selectionStart;
          const end = input3.selectionEnd;
          const hasSelection = start != null && end != null && start !== end;
          if (input3 !== document.activeElement || mode === "keyboard") {
            mode = "unknown";
            return;
          }
          const value3 = presenter2.filledValueBroadcast.get();
          if (hasSelection && value3.length === 0) {
            presenter2.moveCursorTo(0);
            input3.setSelectionRange(0, 0);
            mode = "unknown";
            return;
          }
          if (!hasSelection) {
            presenter2.moveCursorTo(end || 0);
            const cursorPosition = presenter2.cursorPositionBroadcast.get();
            input3.setSelectionRange(cursorPosition, cursorPosition);
          }
          mode = "unknown";
        }
        document.addEventListener("selectionchange", handleSelection);
        document.addEventListener("mousedown", handleMouseDown);
        document.addEventListener("keydown", handleKeyDown);
        return () => {
          document.removeEventListener("selectionchange", handleSelection);
          document.removeEventListener("mousedown", handleMouseDown);
          document.removeEventListener("keydown", handleKeyDown);
        };
      }, [presenter2]);
      return React.createElement(KeyCaptureInput, { value: internalValue, ref: forkedRef, onCopy: handleCopy, onPaste: handlePaste, onCut: handleCut, onKeyCapture: handleInput, ...props });
    });
    const countriesPhoneInformation = [
      {
        name: "Canada",
        code: "CA",
        prefix: "+1",
        masks: [{ mask: "(999) 999-9999" }],
        unicodeFlag: "🇨🇦"
      },
      {
        name: "United States",
        code: "US",
        prefix: "+1",
        masks: [{ mask: "(999) 999-9999" }],
        unicodeFlag: "🇺🇸"
      },
      {
        name: "Kazakhstan",
        code: "KZ",
        prefix: "+7",
        masks: [{ mask: "(999) 999-9999" }],
        unicodeFlag: "🇰🇿"
      },
      {
        name: "Russia",
        code: "RU",
        prefix: "+7",
        masks: [{ mask: "(999) 999-99-99" }],
        unicodeFlag: "🇷🇺"
      },
      {
        name: "Egypt",
        code: "EG",
        prefix: "+20",
        masks: [{ mask: "9999 999 9999" }, { mask: "999 999 9999" }],
        unicodeFlag: "🇪🇬"
      },
      {
        name: "South Africa",
        code: "ZA",
        prefix: "+27",
        masks: [{ mask: "999 999 9999" }],
        unicodeFlag: "🇿🇦"
      },
      {
        name: "Greece",
        code: "GR",
        prefix: "+30",
        masks: [{ mask: "999 9999 9999" }],
        unicodeFlag: "🇬🇷"
      },
      {
        name: "Netherlands",
        code: "NL",
        prefix: "+31",
        masks: [{ mask: "999 999 9999" }],
        unicodeFlag: "🇳🇱"
      },
      {
        name: "Belgium",
        code: "BE",
        prefix: "+32",
        masks: [{ mask: "999 99 99 99" }],
        unicodeFlag: "🇧🇪"
      },
      {
        name: "France",
        code: "FR",
        prefix: "+33",
        masks: [{ mask: "99 99 99 99 99" }],
        unicodeFlag: "🇫🇷"
      },
      {
        name: "Spain",
        code: "ES",
        prefix: "+34",
        masks: [{ mask: "99 999 99 99" }],
        unicodeFlag: "🇪🇸"
      },
      {
        name: "Hungary",
        code: "HU",
        prefix: "+36",
        masks: [{ mask: "(99) 999 9999" }],
        unicodeFlag: "🇭🇺"
      },
      {
        name: "Italy",
        code: "IT",
        prefix: "+39",
        masks: [{ mask: "999 999 9999" }],
        unicodeFlag: "🇮🇹"
      },
      {
        name: "Romania",
        code: "RO",
        prefix: "+40",
        masks: [{ mask: "999 999 999" }],
        unicodeFlag: "🇷🇴"
      },
      {
        name: "Switzerland",
        code: "CH",
        prefix: "+41",
        masks: [{ mask: "99 999 99 99" }],
        unicodeFlag: "🇨🇭"
      },
      {
        name: "Austria",
        code: "AT",
        prefix: "+43",
        masks: [{ mask: "(99) 999 9999" }],
        unicodeFlag: "🇦🇹"
      },
      {
        name: "United Kingdom",
        code: "GB",
        prefix: "+44",
        masks: [{ mask: "99999 999999" }, { mask: "9999 9999" }],
        unicodeFlag: "🇬🇧"
      },
      {
        name: "Denmark",
        code: "DK",
        prefix: "+45",
        masks: [{ mask: "99 99 99 99" }],
        unicodeFlag: "🇩🇰"
      },
      {
        name: "Sweden",
        code: "SE",
        prefix: "+46",
        masks: [{ mask: "99 999 9999" }],
        unicodeFlag: "🇸🇪"
      },
      {
        name: "Norway",
        code: "NO",
        prefix: "+47",
        masks: [{ mask: "999 99 999" }],
        unicodeFlag: "🇳🇴"
      },
      {
        name: "Poland",
        code: "PL",
        prefix: "+48",
        masks: [{ mask: "999 999 999" }],
        unicodeFlag: "🇵🇱"
      },
      {
        name: "Germany",
        code: "DE",
        prefix: "+49",
        masks: [{ mask: "999 9999 9999" }],
        unicodeFlag: "🇩🇪"
      },
      {
        name: "Peru",
        code: "PE",
        prefix: "+51",
        masks: [{ mask: "(99) 999 9999" }],
        unicodeFlag: "🇵🇪"
      },
      {
        name: "Mexico",
        code: "MX",
        prefix: "+52",
        masks: [{ mask: "(999) 999 9999" }],
        unicodeFlag: "🇲🇽"
      },
      {
        name: "Cuba",
        code: "CU",
        prefix: "+53",
        masks: [{ mask: "(99) 999 9999" }],
        unicodeFlag: "🇨🇺"
      },
      {
        name: "Argentina",
        code: "AR",
        prefix: "+54",
        masks: [{ mask: "(99) 9999-9999" }],
        unicodeFlag: "🇦🇷"
      },
      {
        name: "Brazil",
        code: "BR",
        prefix: "+55",
        masks: [{ mask: "(99) 99999-9999" }],
        unicodeFlag: "🇧🇷"
      },
      {
        name: "Japan",
        code: "JP",
        prefix: "+81",
        masks: [{ mask: "99-9999-9999" }],
        unicodeFlag: "🇯🇵"
      },
      {
        name: "South Korea",
        code: "KR",
        prefix: "+82",
        masks: [{ mask: "(999) 9999-9999" }],
        unicodeFlag: "🇰🇷"
      },
      {
        name: "China",
        code: "CN",
        prefix: "+86",
        masks: [{ mask: "999 9999 9999" }],
        unicodeFlag: "🇨🇳"
      },
      {
        name: "Turkey",
        code: "TR",
        prefix: "+90",
        masks: [{ mask: "(999) 999 99 99" }],
        unicodeFlag: "🇹🇷"
      },
      {
        name: "India",
        code: "IN",
        prefix: "+91",
        masks: [{ mask: "99999-99999" }],
        unicodeFlag: "🇮🇳"
      },
      {
        name: "Pakistan",
        code: "PK",
        prefix: "+92",
        masks: [{ mask: "999 9999999" }],
        unicodeFlag: "🇵🇰"
      },
      {
        name: "Iran",
        code: "IR",
        prefix: "+98",
        masks: [{ mask: "999 999 9999" }],
        unicodeFlag: "🇮🇷"
      },
      {
        name: "Western Sahara",
        code: "EH",
        prefix: "+212",
        masks: [{ mask: "999 99 9999" }],
        unicodeFlag: "🇪🇭"
      },
      {
        name: "Algeria",
        code: "DZ",
        prefix: "+213",
        masks: [{ mask: "999 99 99 99" }],
        unicodeFlag: "🇩🇿"
      },
      {
        name: "Tunisia",
        code: "TN",
        prefix: "+216",
        masks: [{ mask: "99 999 999" }],
        unicodeFlag: "🇹🇳"
      },
      {
        name: "Libya",
        code: "LY",
        prefix: "+218",
        masks: [{ mask: "99-9999999" }],
        unicodeFlag: "🇱🇾"
      },
      {
        name: "Gambia",
        code: "GM",
        prefix: "+220",
        masks: [{ mask: "999 9999" }],
        unicodeFlag: "🇬🇲"
      },
      {
        name: "Senegal",
        code: "SN",
        prefix: "+221",
        masks: [{ mask: "99 999 9999" }],
        unicodeFlag: "🇸🇳"
      },
      {
        name: "Mauritania",
        code: "MR",
        prefix: "+222",
        masks: [{ mask: "999 99 99 99" }],
        unicodeFlag: "🇲🇷"
      },
      {
        name: "Mali",
        code: "ML",
        prefix: "+223",
        masks: [{ mask: "99 99 99 99" }],
        unicodeFlag: "🇲🇱"
      },
      {
        name: "Guinea",
        code: "GN",
        prefix: "+224",
        masks: [{ mask: "999 99 99 99" }],
        unicodeFlag: "🇬🇳"
      },
      {
        name: "Ivory Coast",
        code: "CI",
        prefix: "+225",
        masks: [{ mask: "99 99 99 99" }],
        unicodeFlag: "🇨🇮"
      },
      {
        name: "Burkina Faso",
        code: "BF",
        prefix: "+226",
        masks: [{ mask: "99 99 99 99" }],
        unicodeFlag: "🇧🇫"
      },
      {
        name: "Niger",
        code: "NE",
        prefix: "+227",
        masks: [{ mask: "99 99 99 99" }],
        unicodeFlag: "🇳🇪"
      },
      {
        name: "Togo",
        code: "TG",
        prefix: "+228",
        masks: [{ mask: "99 99 99 99" }],
        unicodeFlag: "🇹🇬"
      },
      {
        name: "Benin",
        code: "BJ",
        prefix: "+229",
        masks: [{ mask: "99 99 99 99" }],
        unicodeFlag: "🇧🇯"
      },
      {
        name: "Mauritius",
        code: "MU",
        prefix: "+230",
        masks: [{ mask: "999 9999" }],
        unicodeFlag: "🇲🇺"
      },
      {
        name: "Liberia",
        code: "LR",
        prefix: "+231",
        masks: [{ mask: "77 999 999" }],
        unicodeFlag: "🇱🇷"
      },
      {
        name: "Sierra Leone",
        code: "SL",
        prefix: "+232",
        masks: [{ mask: "99 99 9999" }],
        unicodeFlag: "🇸🇱"
      },
      {
        name: "Ghana",
        code: "GH",
        prefix: "+233",
        masks: [{ mask: "99 999 9999" }],
        unicodeFlag: "🇬🇭"
      },
      {
        name: "Nigeria",
        code: "NG",
        prefix: "+234",
        masks: [{ mask: "999 999 9999" }],
        unicodeFlag: "🇳🇬"
      },
      {
        name: "Chad",
        code: "TD",
        prefix: "+235",
        masks: [{ mask: "99 99 99 99" }],
        unicodeFlag: "🇹🇩"
      },
      {
        name: "Central African Republic",
        code: "CF",
        prefix: "+236",
        masks: [{ mask: "99 99 99 99" }],
        unicodeFlag: "🇨🇫"
      },
      {
        name: "Cameroon",
        code: "CM",
        prefix: "+237",
        masks: [{ mask: "99 99 99 99" }],
        unicodeFlag: "🇨🇲"
      },
      {
        name: "Cape Verde",
        code: "CV",
        prefix: "+238",
        masks: [{ mask: "999 99 99" }],
        unicodeFlag: "🇨🇻"
      },
      {
        name: "Sao Tome and Principe",
        code: "ST",
        prefix: "+239",
        masks: [{ mask: "99 99999" }],
        unicodeFlag: "🇸🇹"
      },
      {
        name: "Equatorial Guinea",
        code: "GQ",
        prefix: "+240",
        masks: [{ mask: "99 99 99 99" }],
        unicodeFlag: "🇬🇶"
      },
      {
        name: "Gabon",
        code: "GA",
        prefix: "+241",
        masks: [{ mask: "99 99 99 99" }],
        unicodeFlag: "🇬🇦"
      },
      {
        name: "Republic of the Congo",
        code: "CG",
        prefix: "+242",
        masks: [{ mask: "99 999 9999" }],
        unicodeFlag: "🇨🇬"
      },
      {
        name: "Democratic Republic of the Congo",
        code: "CD",
        prefix: "+243",
        masks: [{ mask: "99 999 9999" }],
        unicodeFlag: "🇨🇩"
      },
      {
        name: "Angola",
        code: "AO",
        prefix: "+244",
        masks: [{ mask: "999 999 999" }],
        unicodeFlag: "🇦🇴"
      },
      {
        name: "Guinea-Bissau",
        code: "GW",
        prefix: "+245",
        masks: [{ mask: "99 99 99 99" }],
        unicodeFlag: "🇬🇼"
      },
      {
        name: "British Indian Ocean Territory",
        code: "IO",
        prefix: "+246",
        masks: [{ mask: "999 9999" }],
        unicodeFlag: "🇮🇴"
      },
      {
        name: "Seychelles",
        code: "SC",
        prefix: "+248",
        masks: [{ mask: "9 999 999" }],
        unicodeFlag: "🇸🇨"
      },
      {
        name: "Sudan",
        code: "SD",
        prefix: "+249",
        masks: [{ mask: "99 999 9999" }],
        unicodeFlag: "🇸🇩"
      },
      {
        name: "Rwanda",
        code: "RW",
        prefix: "+250",
        masks: [{ mask: "99 999 9999" }],
        unicodeFlag: "🇷🇼"
      },
      {
        name: "Ethiopia",
        code: "ET",
        prefix: "+251",
        masks: [{ mask: "99 999 9999" }],
        unicodeFlag: "🇪🇹"
      },
      {
        name: "Somalia",
        code: "SO",
        prefix: "+252",
        masks: [{ mask: "99 999 9999" }],
        unicodeFlag: "🇸🇴"
      },
      {
        name: "Djibouti",
        code: "DJ",
        prefix: "+253",
        masks: [{ mask: "99 99 99 99" }],
        unicodeFlag: "🇩🇯"
      },
      {
        name: "Kenya",
        code: "KE",
        prefix: "+254",
        masks: [{ mask: "999 999 999" }],
        unicodeFlag: "🇰🇪"
      },
      {
        name: "Tanzania",
        code: "TZ",
        prefix: "+255",
        masks: [{ mask: "99 999 9999" }],
        unicodeFlag: "🇹🇿"
      },
      {
        name: "Uganda",
        code: "UG",
        prefix: "+256",
        masks: [{ mask: "999 999 999" }],
        unicodeFlag: "🇺🇬"
      },
      {
        name: "Burundi",
        code: "BI",
        prefix: "+257",
        masks: [{ mask: "99 99 99 99" }],
        unicodeFlag: "🇧🇮"
      },
      {
        name: "Mozambique",
        code: "MZ",
        prefix: "+258",
        masks: [{ mask: "99 999 9999" }],
        unicodeFlag: "🇲🇿"
      },
      {
        name: "Zambia",
        code: "ZM",
        prefix: "+260",
        masks: [{ mask: "999 999 999" }],
        unicodeFlag: "🇿🇲"
      },
      {
        name: "Madagascar",
        code: "MG",
        prefix: "+261",
        masks: [{ mask: "99 99 999 99" }],
        unicodeFlag: "🇲🇬"
      },
      {
        name: "Mayotte",
        code: "YT",
        prefix: "+262",
        masks: [{ mask: "999 99 99 99" }],
        unicodeFlag: "🇾🇹"
      },
      {
        name: "Reunion",
        code: "RE",
        prefix: "+262",
        masks: [{ mask: "999 99 99 99" }],
        unicodeFlag: "🇷🇪"
      },
      {
        name: "Zimbabwe",
        code: "ZW",
        prefix: "+263",
        masks: [{ mask: "999 999 999" }],
        unicodeFlag: "🇿🇼"
      },
      {
        name: "Namibia",
        code: "NA",
        prefix: "+264",
        masks: [{ mask: "99 999 9999" }],
        unicodeFlag: "🇳🇦"
      },
      {
        name: "Malawi",
        code: "MW",
        prefix: "+265",
        masks: [{ mask: "999 99 99" }],
        unicodeFlag: "🇲🇼"
      },
      {
        name: "Lesotho",
        code: "LS",
        prefix: "+266",
        masks: [{ mask: "999 9999" }],
        unicodeFlag: "🇱🇸"
      },
      {
        name: "Botswana",
        code: "BW",
        prefix: "+267",
        masks: [{ mask: "99 999 999" }],
        unicodeFlag: "🇧🇼"
      },
      {
        name: "Swaziland",
        code: "SZ",
        prefix: "+268",
        masks: [{ mask: "99 99 9999" }],
        unicodeFlag: "🇸🇿"
      },
      {
        name: "Comoros",
        code: "KM",
        prefix: "+269",
        masks: [{ mask: "999 99 99" }],
        unicodeFlag: "🇰🇲"
      },
      {
        name: "Saint Helena",
        code: "SH",
        prefix: "+290",
        masks: [{ mask: "9999" }],
        unicodeFlag: "🇸🇭"
      },
      {
        name: "Eritrea",
        code: "ER",
        prefix: "+291",
        masks: [{ mask: "1 999 999" }],
        unicodeFlag: "🇪🇷"
      },
      {
        name: "Aruba",
        code: "AW",
        prefix: "+297",
        masks: [{ mask: "999 9999" }],
        unicodeFlag: "🇦🇼"
      },
      {
        name: "Faroe Islands",
        code: "FO",
        prefix: "+298",
        masks: [{ mask: "999 999" }],
        unicodeFlag: "🇫🇴"
      },
      {
        name: "Greenland",
        code: "GL",
        prefix: "+299",
        masks: [{ mask: "99 99 99" }],
        unicodeFlag: "🇬🇱"
      },
      {
        name: "Gibraltar",
        code: "GI",
        prefix: "+350",
        masks: [{ mask: "9999 9999" }],
        unicodeFlag: "🇬🇮"
      },
      {
        name: "Portugal",
        code: "PT",
        prefix: "+351",
        masks: [{ mask: "999 999 999" }],
        unicodeFlag: "🇵🇹"
      },
      {
        name: "Luxembourg",
        code: "LU",
        prefix: "+352",
        masks: [{ mask: "999 999 999" }],
        unicodeFlag: "🇱🇺"
      },
      {
        name: "Ireland",
        code: "IE",
        prefix: "+353",
        masks: [{ mask: "99 999 9999" }],
        unicodeFlag: "🇮🇪"
      },
      {
        name: "Iceland",
        code: "IS",
        prefix: "+354",
        masks: [{ mask: "999 9999" }],
        unicodeFlag: "🇮🇸"
      },
      {
        name: "Albania",
        code: "AL",
        prefix: "+355",
        masks: [{ mask: "999 999 9999" }],
        unicodeFlag: "🇦🇱"
      },
      {
        name: "Malta",
        code: "MT",
        prefix: "+356",
        masks: [{ mask: "9999 9999" }],
        unicodeFlag: "🇲🇹"
      },
      {
        name: "Cyprus",
        code: "CY",
        prefix: "+357",
        masks: [{ mask: "99 999999" }],
        unicodeFlag: "🇨🇾"
      },
      {
        name: "Finland",
        code: "FI",
        prefix: "+358",
        masks: [{ mask: "999 999 99" }],
        unicodeFlag: "🇫🇮"
      },
      {
        name: "Bulgaria",
        code: "BG",
        prefix: "+359",
        masks: [{ mask: "999 999 999" }],
        unicodeFlag: "🇧🇬"
      },
      {
        name: "Lithuania",
        code: "LT",
        prefix: "+370",
        masks: [{ mask: "999 99999" }],
        unicodeFlag: "🇱🇹"
      },
      {
        name: "Latvia",
        code: "LV",
        prefix: "+371",
        masks: [{ mask: "99 999 999" }],
        unicodeFlag: "🇱🇻"
      },
      {
        name: "Estonia",
        code: "EE",
        prefix: "+372",
        masks: [{ mask: "9999 9999" }],
        unicodeFlag: "🇪🇪"
      },
      {
        name: "Moldova",
        code: "MD",
        prefix: "+373",
        masks: [{ mask: "9999 9999" }],
        unicodeFlag: "🇲🇩"
      },
      {
        name: "Armenia",
        code: "AM",
        prefix: "+374",
        masks: [{ mask: "99 999999" }],
        unicodeFlag: "🇦🇲"
      },
      {
        name: "Belarus",
        code: "BY",
        prefix: "+375",
        masks: [{ mask: "999 9999999" }],
        unicodeFlag: "🇧🇾"
      },
      {
        name: "Andorra",
        code: "AD",
        prefix: "+376",
        masks: [{ mask: "999 999" }],
        unicodeFlag: "🇦🇩"
      },
      {
        name: "Monaco",
        code: "MC",
        prefix: "+377",
        masks: [{ mask: "99 99 99 99" }],
        unicodeFlag: "🇲🇨"
      },
      {
        name: "San Marino",
        code: "SM",
        prefix: "+378",
        masks: [{ mask: "9999 999999" }],
        unicodeFlag: "🇸🇲"
      },
      {
        name: "Vatican",
        code: "VA",
        prefix: "+379",
        masks: [{ mask: "999" }],
        unicodeFlag: "🇻🇦"
      },
      {
        name: "Ukraine",
        code: "UA",
        prefix: "+380",
        masks: [{ mask: "99 999 9999" }],
        unicodeFlag: "🇺🇦"
      },
      {
        name: "Serbia",
        code: "RS",
        prefix: "+381",
        masks: [{ mask: "99 9999999" }],
        unicodeFlag: "🇷🇸"
      },
      {
        name: "Montenegro",
        code: "ME",
        prefix: "+382",
        masks: [{ mask: "999 999 999" }],
        unicodeFlag: "🇲🇪"
      },
      {
        name: "Kosovo",
        code: "XK",
        prefix: "+383",
        masks: [{ mask: "49 999 999" }],
        unicodeFlag: "🇽🇰"
      },
      {
        name: "Croatia",
        code: "HR",
        prefix: "+385",
        masks: [{ mask: "99 999 999" }],
        unicodeFlag: "🇭🇷"
      },
      {
        name: "Slovenia",
        code: "SI",
        prefix: "+386",
        masks: [{ mask: "9 999 999" }],
        unicodeFlag: "🇸🇮"
      },
      {
        name: "Bosnia and Herzegovina",
        code: "BA",
        prefix: "+387",
        masks: [{ mask: "99 999 999" }],
        unicodeFlag: "🇧🇦"
      },
      {
        name: "Macedonia",
        code: "MK",
        prefix: "+389",
        masks: [{ mask: "99 999 999" }],
        unicodeFlag: "🇲🇰"
      },
      {
        name: "Czech Republic",
        code: "CZ",
        prefix: "+420",
        masks: [{ mask: "999 999 999" }],
        unicodeFlag: "🇨🇿"
      },
      {
        name: "Slovakia",
        code: "SK",
        prefix: "+421",
        masks: [{ mask: "999 999 999" }],
        unicodeFlag: "🇸🇰"
      },
      {
        name: "Liechtenstein",
        code: "LI",
        prefix: "+423",
        masks: [{ mask: "999 99 999" }],
        unicodeFlag: "🇱🇮"
      },
      {
        name: "Falkland Islands",
        code: "FK",
        prefix: "+500",
        masks: [{ mask: "99999" }],
        unicodeFlag: "🇫🇰"
      },
      {
        name: "Belize",
        code: "BZ",
        prefix: "+501",
        masks: [{ mask: "999 9999" }],
        unicodeFlag: "🇧🇿"
      },
      {
        name: "Guatemala",
        code: "GT",
        prefix: "+502",
        masks: [{ mask: "9999 9999" }],
        unicodeFlag: "🇬🇹"
      },
      {
        name: "El Salvador",
        code: "SV",
        prefix: "+503",
        masks: [{ mask: "9999 9999" }],
        unicodeFlag: "🇸🇻"
      },
      {
        name: "Honduras",
        code: "HN",
        prefix: "+504",
        masks: [{ mask: "9999 9999" }],
        unicodeFlag: "🇭🇳"
      },
      {
        name: "Nicaragua",
        code: "NI",
        prefix: "+505",
        masks: [{ mask: "9999 9999" }],
        unicodeFlag: "🇳🇮"
      },
      {
        name: "Costa Rica",
        code: "CR",
        prefix: "+506",
        masks: [{ mask: "9999 9999" }],
        unicodeFlag: "🇨🇷"
      },
      {
        name: "Panama",
        code: "PA",
        prefix: "+507",
        masks: [{ mask: "999 9999" }],
        unicodeFlag: "🇵🇦"
      },
      {
        name: "Saint Pierre and Miquelon",
        code: "PM",
        prefix: "+508",
        masks: [{ mask: "99 99 99" }],
        unicodeFlag: "🇵🇲"
      },
      {
        name: "Haiti",
        code: "HT",
        prefix: "+509",
        masks: [{ mask: "99 99 9999" }],
        unicodeFlag: "🇭🇹"
      },
      {
        name: "Saint Barthelemy",
        code: "BL",
        prefix: "+590",
        masks: [{ mask: "999 99 99" }],
        unicodeFlag: "🇧🇱"
      },
      {
        name: "Saint Martin",
        code: "MF",
        prefix: "+590",
        masks: [{ mask: "999 99 99" }],
        unicodeFlag: "🇲🇫"
      },
      {
        name: "Bolivia",
        code: "BO",
        prefix: "+591",
        masks: [{ mask: "999 99999" }],
        unicodeFlag: "🇧🇴"
      },
      {
        name: "Guyana",
        code: "GY",
        prefix: "+592",
        masks: [{ mask: "999 9999" }],
        unicodeFlag: "🇬🇾"
      },
      {
        name: "Ecuador",
        code: "EC",
        prefix: "+593",
        masks: [{ mask: "99 999 9999" }],
        unicodeFlag: "🇪🇨"
      },
      {
        name: "Paraguay",
        code: "PY",
        prefix: "+595",
        masks: [{ mask: "999 999 999" }],
        unicodeFlag: "🇵🇾"
      },
      {
        name: "Suriname",
        code: "SR",
        prefix: "+597",
        masks: [{ mask: "999 999" }],
        unicodeFlag: "🇸🇷"
      },
      {
        name: "Uruguay",
        code: "UY",
        prefix: "+598",
        masks: [{ mask: "9 999 99 99" }],
        unicodeFlag: "🇺🇾"
      },
      {
        name: "Curacao",
        code: "CW",
        prefix: "+599",
        masks: [{ mask: "9 999 9999" }],
        unicodeFlag: "🇨🇼"
      },
      {
        name: "Netherlands Antilles",
        code: "AN",
        prefix: "+599",
        masks: [{ mask: "9 999 9999" }],
        unicodeFlag: "🇳🇱"
      },
      {
        name: "East Timor",
        code: "TL",
        prefix: "+670",
        masks: [{ mask: "9999 9999" }],
        unicodeFlag: "🇹🇱"
      },
      {
        name: "Antarctica",
        code: "AQ",
        prefix: "+672",
        masks: [{ mask: "99 9999" }],
        unicodeFlag: "🇦🇶"
      },
      {
        name: "Brunei",
        code: "BN",
        prefix: "+673",
        masks: [{ mask: "999 9999" }],
        unicodeFlag: "🇧🇳"
      },
      {
        name: "Nauru",
        code: "NR",
        prefix: "+674",
        masks: [{ mask: "999 9999" }],
        unicodeFlag: "🇳🇷"
      },
      {
        name: "Papua New Guinea",
        code: "PG",
        prefix: "+675",
        masks: [{ mask: "9999 9999" }],
        unicodeFlag: "🇵🇬"
      },
      {
        name: "Tonga",
        code: "TO",
        prefix: "+676",
        masks: [{ mask: "999 9999" }],
        unicodeFlag: "🇹🇴"
      },
      {
        name: "Solomon Islands",
        code: "SB",
        prefix: "+677",
        masks: [{ mask: "99999" }],
        unicodeFlag: "🇸🇧"
      },
      {
        name: "Vanuatu",
        code: "VU",
        prefix: "+678",
        masks: [{ mask: "999 9999" }],
        unicodeFlag: "🇻🇺"
      },
      {
        name: "Fiji",
        code: "FJ",
        prefix: "+679",
        masks: [{ mask: "999 9999" }],
        unicodeFlag: "🇫🇯"
      },
      {
        name: "Palau",
        code: "PW",
        prefix: "+680",
        masks: [{ mask: "999 9999" }],
        unicodeFlag: "🇵🇼"
      },
      {
        name: "Wallis and Futuna",
        code: "WF",
        prefix: "+681",
        masks: [{ mask: "99 9999" }],
        unicodeFlag: "🇼🇫"
      },
      {
        name: "Cook Islands",
        code: "CK",
        prefix: "+682",
        masks: [{ mask: "99 999" }],
        unicodeFlag: "🇨🇰"
      },
      {
        name: "Niue",
        code: "NU",
        prefix: "+683",
        masks: [{ mask: "9999" }],
        unicodeFlag: "🇳🇺"
      },
      {
        name: "Samoa",
        code: "WS",
        prefix: "+685",
        masks: [{ mask: "99 9999" }],
        unicodeFlag: "🇼🇸"
      },
      {
        name: "Kiribati",
        code: "KI",
        prefix: "+686",
        masks: [{ mask: "999 9999" }],
        unicodeFlag: "🇰🇮"
      },
      {
        name: "New Caledonia",
        code: "NC",
        prefix: "+687",
        masks: [{ mask: "99 9999" }],
        unicodeFlag: "🇳🇨"
      },
      {
        name: "Tuvalu",
        code: "TV",
        prefix: "+688",
        masks: [{ mask: "999 9999" }],
        unicodeFlag: "🇹🇻"
      },
      {
        name: "French Polynesia",
        code: "PF",
        prefix: "+689",
        masks: [{ mask: "99 99 99" }],
        unicodeFlag: "🇵🇫"
      },
      {
        name: "Tokelau",
        code: "TK",
        prefix: "+690",
        masks: [{ mask: "9999" }],
        unicodeFlag: "🇹🇰"
      },
      {
        name: "Micronesia",
        code: "FM",
        prefix: "+691",
        masks: [{ mask: "999 9999" }],
        unicodeFlag: "🇫🇲"
      },
      {
        name: "Marshall Islands",
        code: "MH",
        prefix: "+692",
        masks: [{ mask: "999 9999" }],
        unicodeFlag: "🇲🇭"
      },
      {
        name: "North Korea",
        code: "KP",
        prefix: "+850",
        masks: [{ mask: "9 999 9999" }],
        unicodeFlag: "🇰🇵"
      },
      {
        name: "Hong Kong",
        code: "HK",
        prefix: "+852",
        masks: [{ mask: "9999 9999" }],
        unicodeFlag: "🇭🇰"
      },
      {
        name: "Macau",
        code: "MO",
        prefix: "+853",
        masks: [{ mask: "9999 9999" }],
        unicodeFlag: "🇲🇴"
      },
      {
        name: "Cambodia",
        code: "KH",
        prefix: "+855",
        masks: [{ mask: "99 999 999" }],
        unicodeFlag: "🇰🇭"
      },
      {
        name: "Laos",
        code: "LA",
        prefix: "+856",
        masks: [{ mask: "99 99 999 999" }],
        unicodeFlag: "🇱🇦"
      },
      {
        name: "Bangladesh",
        code: "BD",
        prefix: "+880",
        masks: [{ mask: "9999 999999" }],
        unicodeFlag: "🇧🇩"
      },
      {
        name: "Taiwan",
        code: "TW",
        prefix: "+886",
        masks: [{ mask: "9 999 9999" }],
        unicodeFlag: "🇹🇼"
      },
      {
        name: "Maldives",
        code: "MV",
        prefix: "+960",
        masks: [{ mask: "999 9999" }],
        unicodeFlag: "🇲🇻"
      },
      {
        name: "Lebanon",
        code: "LB",
        prefix: "+961",
        masks: [{ mask: "1 999 999" }],
        unicodeFlag: "🇱🇧"
      },
      {
        name: "Jordan",
        code: "JO",
        prefix: "+962",
        masks: [{ mask: "9 9999 9999" }],
        unicodeFlag: "🇯🇴"
      },
      {
        name: "Syria",
        code: "SY",
        prefix: "+963",
        masks: [{ mask: "9999 999 999" }],
        unicodeFlag: "🇸🇾"
      }
    ];
    const phoneNumberInput = `_phone-number-input_e7433ea`;
    const phoneNumberInputSelect = `_phone-number-input-select_340a43e`;
    const phoneNumberInputInput = `_phone-number-input-input_b949ef4`;
    const styles$m = { "phone-number-input": phoneNumberInput, "phone-number-input-select": phoneNumberInputSelect, "phone-number-input-input": phoneNumberInputInput };
    const overflowMask = { mask: "9999999999999999999", placeholder: "                   " };
    const countryList = countriesPhoneInformation.map((i) => ({
      label: `${i.prefix} (${i.code}) ${i.unicodeFlag}`,
      value: i.code
    }));
    countryList.sort((a, b) => parseInt(a.value) - parseInt(b.value));
    const countryPrefixMap = /* @__PURE__ */ new Map();
    const countryCodeMap = /* @__PURE__ */ new Map();
    countriesPhoneInformation.forEach((i) => {
      countryCodeMap.set(i.code, i);
      countryPrefixMap.set(i.prefix, i);
    });
    function createCountryOptions(allowedCountryCodes) {
      if (allowedCountryCodes != null) {
        const allowedMap = {};
        allowedCountryCodes.forEach((c) => allowedMap[c] = true);
        return countryList.filter((c) => Boolean(allowedMap[c.value])).map((i, index) => {
          return React.createElement("option", { key: index, value: i.value }, i.label);
        });
      } else {
        return countryList.map((i, index) => {
          return React.createElement("option", { key: index, value: i.value }, i.label);
        });
      }
    }
    function getCountryCodeFromValue(value2, defaultCountry) {
      for (let x = 5; x > 1; x--) {
        const prefix = value2.slice(0, x);
        const countryInformation = countryPrefixMap.get(prefix);
        if (countryInformation != null) {
          return countryInformation;
        }
      }
      return countryCodeMap.get(defaultCountry.toUpperCase()) || countryCodeMap.get("US");
    }
    function stripNonNumeric(input2) {
      return input2.replace(/\D/g, "");
    }
    const PhoneNumberInput = React.forwardRef(function PhoneNumberInput2({ value: value2 = "", defaultCountry = "US", onChange, countrySelectRef: countryRef, phoneNumberInputRef: numberRef, disabled = false, allowedCountryCodes, ...props }, ref) {
      const lastOutputValueRef = reactExports.useRef(value2);
      const countryInformation = getCountryCodeFromValue(value2, defaultCountry);
      const [phoneNumber, setPhoneNumber] = reactExports.useState(() => {
        const phoneNumber2 = value2.split(countryInformation.prefix)[1];
        return phoneNumber2 == null ? "" : stripNonNumeric(phoneNumber2);
      });
      const [countryCode, setCountryCode] = reactExports.useState(countryInformation.code);
      const [currentMasks, setCurrentMasks] = reactExports.useState([
        ...countriesPhoneInformation[0].masks,
        overflowMask
      ]);
      const countryOptions = reactExports.useMemo(() => {
        return createCountryOptions(allowedCountryCodes);
      }, [allowedCountryCodes]);
      function changeCountry(countryCodeValue) {
        const countryInformation2 = countryCodeMap.get(countryCodeValue);
        if (countryInformation2 == null) {
          return;
        }
        setCountryCode(countryInformation2.code);
        setCurrentMasks([...countryInformation2.masks, overflowMask]);
        onChange && onChange(`${countryInformation2.prefix}${stripNonNumeric(phoneNumber)}`);
      }
      reactExports.useLayoutEffect(() => {
        const countryInformation2 = getCountryCodeFromValue(value2, defaultCountry);
        setCountryCode(countryInformation2.code);
      }, [value2, defaultCountry]);
      function transformValue(newPhoneNumber) {
        var _a2;
        const countryPrefix = (_a2 = countryCodeMap.get(countryCode)) == null ? void 0 : _a2.prefix;
        const lineNumber = stripNonNumeric(newPhoneNumber);
        const outputValue = countryPrefix + lineNumber;
        lastOutputValueRef.current = outputValue;
        phoneNumber !== newPhoneNumber && setPhoneNumber(newPhoneNumber);
        onChange && onChange(outputValue);
      }
      reactExports.useLayoutEffect(() => {
        const oldValue = lastOutputValueRef.current;
        const countryInformation2 = getCountryCodeFromValue(value2, defaultCountry);
        const phoneNumber2 = value2.split(countryInformation2.prefix)[1];
        if (oldValue !== value2) {
          setPhoneNumber(phoneNumber2);
        }
      }, [value2, defaultCountry]);
      return React.createElement(
        HStack,
        { ref, className: classNames(styles$m["phone-number-input"], "phone-number-input"), height: "auto", ...props },
        React.createElement(Select, { className: classNames(styles$m["phone-number-input-select"], "phone-number-input-select"), selectRef: countryRef, width: "auto", value: countryCode, onChange: changeCountry, disabled, "data-is-disabled": disabled, selectProps: {
          style: { borderEndEndRadius: 0, borderStartEndRadius: 0 }
        } }, countryOptions),
        React.createElement(
          FlexBox,
          { className: styles$m["phone-number-input-input"] },
          React.createElement(MaskInput, { ref: numberRef, value: phoneNumber, mask: currentMasks, onChange: transformValue, disabled, "data-is-disabled": disabled, className: "phone-number-input-input", style: {
            borderStartStartRadius: 0,
            borderEndStartRadius: 0
          } })
        )
      );
    });
    const menu = `_menu_987f8d2`;
    const menuItem = `_menu-item_d919b83`;
    const styles$l = { menu, "menu-item": menuItem };
    const Menu = React.forwardRef(function Menu2({ anchorElement, verticalAnchor, verticalOrigin, verticalOffset, horizontalAnchor, horizontalOrigin, horizontalOffset, direction, open, onClose, restoreFocus, veil, onActivatedMenu, children = [], ...props }, ref) {
      const [focusedIndex, setFocusedIndex] = reactExports.useState(-1);
      const clonedChildren = React.Children.toArray(children).map((child, index) => {
        if (!React.isValidElement(child)) {
          return child;
        }
        const props2 = {
          ...child.props,
          key: index,
          verticalAnchor: direction === "up" ? "bottom" : "top",
          verticalOrigin: direction === "up" ? "bottom" : "top",
          verticalOffset,
          horizontalAnchor: "end",
          horizontalOrigin: "start",
          horizontalOffset,
          direction,
          onClick: (e) => {
            onClose && onClose();
            child.props.onClick && child.props.onClick(e);
          },
          onMouseEnter: (e) => {
            setFocusedIndex(index);
            onActivatedMenu && onActivatedMenu(true);
            child.props.onMouseEnter && child.props.onMouseEnter(e);
          }
        };
        if (child.type === MenuItem) {
          props2.open = focusedIndex === index;
        }
        return React.cloneElement(child, props2);
      });
      direction === "up" && clonedChildren.reverse();
      reactExports.useLayoutEffect(() => {
        if (!open) {
          setFocusedIndex(-1);
          onActivatedMenu && onActivatedMenu(false);
        }
      }, [open, onActivatedMenu]);
      return React.createElement(
        Popover,
        { anchorElement, verticalAnchor, verticalOrigin, verticalOffset, horizontalAnchor: horizontalAnchor || "end", horizontalOrigin: horizontalOrigin || "end", horizontalOffset, open, onClose, restoreFocus, veil },
        React.createElement(VStack, { ref, className: styles$l.menu, ...props }, clonedChildren)
      );
    });
    const MenuItem = React.forwardRef(function MenuItem2({ selected, iconName, label, endAdornments, className, children, direction = "down", verticalAnchor = "top", verticalOrigin = "top", verticalOffset, horizontalAnchor = "end", horizontalOrigin = "start", horizontalOffset, open = false, ...props }, ref) {
      const hasEnteredMenuRef = reactExports.useRef(false);
      const cursorPositionRef = reactExports.useRef({ x: -1, y: -1 });
      const cursorDeltaRef = reactExports.useRef({ x: -1, y: -1 });
      const [showVeil, setShowVeil] = reactExports.useState(false);
      const itemRef = reactExports.useRef(null);
      const forkedRef = useForkRef(ref, itemRef);
      const hasSubmenu = children != null && children.length > 0;
      function close() {
        setShowVeil(false);
      }
      reactExports.useLayoutEffect(() => {
        const itemElement = itemRef.current;
        if (itemElement && hasSubmenu && open) {
          const direction2 = window.getComputedStyle(itemElement).direction;
          const startPosition = cursorPositionRef.current;
          const delta = cursorDeltaRef.current;
          const calculateSlope = (event) => {
            if (startPosition.x === -1) {
              startPosition.x = event.clientX;
              startPosition.y = event.clientY;
            }
            const deltaX = event.clientX - startPosition.x;
            const deltaY = event.clientY - startPosition.y;
            delta.x = Math.max(Math.abs(deltaX), 1e-3);
            delta.y = Math.max(Math.abs(deltaY), 1e-3);
            const isSlopeWrongDirection = (deltaX < 0 || direction2 === "down" && deltaY < 0 || direction2 === "up" && deltaY > 0) && direction2 === "ltr" || (deltaX > 0 || direction2 === "down" && deltaY < 0 || direction2 === "up" && deltaY > 0) && direction2 === "rtl";
            if (isSlopeWrongDirection) {
              startPosition.x = event.clientX;
              startPosition.y = event.clientY;
              setShowVeil(false);
              return;
            }
            const distance = Math.sqrt(delta.x ** 2 + delta.y ** 2);
            if (hasEnteredMenuRef.current) {
              startPosition.x = event.clientX;
              startPosition.y = event.clientY;
              setShowVeil(false);
              return;
            }
            if (distance > 5) {
              const movingHorizontal = delta.x / delta.y > 0.2;
              if (movingHorizontal) {
                setShowVeil(true);
              } else {
                setShowVeil(false);
              }
              startPosition.x = event.clientX;
              startPosition.y = event.clientY;
            }
          };
          window.addEventListener("mousemove", calculateSlope);
          return () => {
            window.removeEventListener("mousemove", calculateSlope);
          };
        }
      }, [hasSubmenu, open]);
      reactExports.useLayoutEffect(() => {
        setShowVeil(open);
      }, [open]);
      return React.createElement(
        React.Fragment,
        null,
        React.createElement(
          HStack,
          { as: "button", ref: forkedRef, "data-is-selected": Boolean(selected), "data-has-children": Boolean(hasSubmenu), className: classNames(className, styles$l["menu-item"]), "data-is-open": open, ...props },
          iconName && React.createElement(
            React.Fragment,
            null,
            React.createElement(Icon, { name: iconName, size: "20px" }),
            React.createElement(Spacer, { width: "4px" })
          ),
          React.createElement(BodyText, { color: "inherit" }, label),
          React.createElement(Spacer, null),
          endAdornments,
          hasSubmenu && React.createElement(
            React.Fragment,
            null,
            React.createElement(Spacer, { width: "8px" }),
            React.createElement(Icon, { name: "chevron_right", size: "20px", flipOnRtl: true })
          )
        ),
        children && React.createElement(Menu, { anchorElement: itemRef.current, veil: showVeil, onClose: close, open, direction, verticalAnchor, verticalOrigin, verticalOffset, horizontalAnchor, horizontalOrigin, horizontalOffset, horizontalAlignment: "start", onActivatedMenu: (hasActiveMenu) => {
          hasEnteredMenuRef.current = hasActiveMenu;
        } }, children)
      );
    });
    function ContextMenu({ open, position, children, onClose }) {
      const [anchorElement, setAnchorElement] = reactExports.useState(null);
      if (!open || position == null) {
        return null;
      }
      return React.createElement(
        React.Fragment,
        null,
        React.createElement(
          Portal,
          null,
          React.createElement(
            "div",
            { style: { position: "fixed", inset: 0 } },
            React.createElement("div", { ref: (element) => {
              setAnchorElement(element);
            }, style: {
              position: "absolute",
              top: position.y,
              left: position.x,
              width: "1px",
              height: "1px",
              opacity: 0
            } })
          )
        ),
        React.createElement(Menu, { veil: true, horizontalAnchor: "start", verticalAnchor: "top", horizontalOrigin: "start", verticalOrigin: "top", anchorElement, open, onClose, minWidth: "150px" }, children)
      );
    }
    var lib = {};
    var flattenNames = {};
    var _freeGlobal;
    var hasRequired_freeGlobal;
    function require_freeGlobal() {
      if (hasRequired_freeGlobal) return _freeGlobal;
      hasRequired_freeGlobal = 1;
      var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
      _freeGlobal = freeGlobal2;
      return _freeGlobal;
    }
    var _root;
    var hasRequired_root;
    function require_root() {
      if (hasRequired_root) return _root;
      hasRequired_root = 1;
      var freeGlobal2 = require_freeGlobal();
      var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
      var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
      _root = root2;
      return _root;
    }
    var _Symbol;
    var hasRequired_Symbol;
    function require_Symbol() {
      if (hasRequired_Symbol) return _Symbol;
      hasRequired_Symbol = 1;
      var root2 = require_root();
      var Symbol2 = root2.Symbol;
      _Symbol = Symbol2;
      return _Symbol;
    }
    var _getRawTag;
    var hasRequired_getRawTag;
    function require_getRawTag() {
      if (hasRequired_getRawTag) return _getRawTag;
      hasRequired_getRawTag = 1;
      var Symbol2 = require_Symbol();
      var objectProto2 = Object.prototype;
      var hasOwnProperty2 = objectProto2.hasOwnProperty;
      var nativeObjectToString2 = objectProto2.toString;
      var symToStringTag2 = Symbol2 ? Symbol2.toStringTag : void 0;
      function getRawTag2(value2) {
        var isOwn = hasOwnProperty2.call(value2, symToStringTag2), tag = value2[symToStringTag2];
        try {
          value2[symToStringTag2] = void 0;
          var unmasked = true;
        } catch (e) {
        }
        var result = nativeObjectToString2.call(value2);
        if (unmasked) {
          if (isOwn) {
            value2[symToStringTag2] = tag;
          } else {
            delete value2[symToStringTag2];
          }
        }
        return result;
      }
      _getRawTag = getRawTag2;
      return _getRawTag;
    }
    var _objectToString;
    var hasRequired_objectToString;
    function require_objectToString() {
      if (hasRequired_objectToString) return _objectToString;
      hasRequired_objectToString = 1;
      var objectProto2 = Object.prototype;
      var nativeObjectToString2 = objectProto2.toString;
      function objectToString2(value2) {
        return nativeObjectToString2.call(value2);
      }
      _objectToString = objectToString2;
      return _objectToString;
    }
    var _baseGetTag;
    var hasRequired_baseGetTag;
    function require_baseGetTag() {
      if (hasRequired_baseGetTag) return _baseGetTag;
      hasRequired_baseGetTag = 1;
      var Symbol2 = require_Symbol(), getRawTag2 = require_getRawTag(), objectToString2 = require_objectToString();
      var nullTag2 = "[object Null]", undefinedTag2 = "[object Undefined]";
      var symToStringTag2 = Symbol2 ? Symbol2.toStringTag : void 0;
      function baseGetTag2(value2) {
        if (value2 == null) {
          return value2 === void 0 ? undefinedTag2 : nullTag2;
        }
        return symToStringTag2 && symToStringTag2 in Object(value2) ? getRawTag2(value2) : objectToString2(value2);
      }
      _baseGetTag = baseGetTag2;
      return _baseGetTag;
    }
    var isArray_1;
    var hasRequiredIsArray;
    function requireIsArray() {
      if (hasRequiredIsArray) return isArray_1;
      hasRequiredIsArray = 1;
      var isArray2 = Array.isArray;
      isArray_1 = isArray2;
      return isArray_1;
    }
    var isObjectLike_1;
    var hasRequiredIsObjectLike;
    function requireIsObjectLike() {
      if (hasRequiredIsObjectLike) return isObjectLike_1;
      hasRequiredIsObjectLike = 1;
      function isObjectLike2(value2) {
        return value2 != null && typeof value2 == "object";
      }
      isObjectLike_1 = isObjectLike2;
      return isObjectLike_1;
    }
    var isString_1;
    var hasRequiredIsString;
    function requireIsString() {
      if (hasRequiredIsString) return isString_1;
      hasRequiredIsString = 1;
      var baseGetTag2 = require_baseGetTag(), isArray2 = requireIsArray(), isObjectLike2 = requireIsObjectLike();
      var stringTag2 = "[object String]";
      function isString(value2) {
        return typeof value2 == "string" || !isArray2(value2) && isObjectLike2(value2) && baseGetTag2(value2) == stringTag2;
      }
      isString_1 = isString;
      return isString_1;
    }
    var _createBaseFor;
    var hasRequired_createBaseFor;
    function require_createBaseFor() {
      if (hasRequired_createBaseFor) return _createBaseFor;
      hasRequired_createBaseFor = 1;
      function createBaseFor2(fromRight) {
        return function(object, iteratee, keysFunc) {
          var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      _createBaseFor = createBaseFor2;
      return _createBaseFor;
    }
    var _baseFor;
    var hasRequired_baseFor;
    function require_baseFor() {
      if (hasRequired_baseFor) return _baseFor;
      hasRequired_baseFor = 1;
      var createBaseFor2 = require_createBaseFor();
      var baseFor2 = createBaseFor2();
      _baseFor = baseFor2;
      return _baseFor;
    }
    var _baseTimes;
    var hasRequired_baseTimes;
    function require_baseTimes() {
      if (hasRequired_baseTimes) return _baseTimes;
      hasRequired_baseTimes = 1;
      function baseTimes2(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      _baseTimes = baseTimes2;
      return _baseTimes;
    }
    var _baseIsArguments;
    var hasRequired_baseIsArguments;
    function require_baseIsArguments() {
      if (hasRequired_baseIsArguments) return _baseIsArguments;
      hasRequired_baseIsArguments = 1;
      var baseGetTag2 = require_baseGetTag(), isObjectLike2 = requireIsObjectLike();
      var argsTag2 = "[object Arguments]";
      function baseIsArguments2(value2) {
        return isObjectLike2(value2) && baseGetTag2(value2) == argsTag2;
      }
      _baseIsArguments = baseIsArguments2;
      return _baseIsArguments;
    }
    var isArguments_1;
    var hasRequiredIsArguments;
    function requireIsArguments() {
      if (hasRequiredIsArguments) return isArguments_1;
      hasRequiredIsArguments = 1;
      var baseIsArguments2 = require_baseIsArguments(), isObjectLike2 = requireIsObjectLike();
      var objectProto2 = Object.prototype;
      var hasOwnProperty2 = objectProto2.hasOwnProperty;
      var propertyIsEnumerable2 = objectProto2.propertyIsEnumerable;
      var isArguments2 = baseIsArguments2(/* @__PURE__ */ function() {
        return arguments;
      }()) ? baseIsArguments2 : function(value2) {
        return isObjectLike2(value2) && hasOwnProperty2.call(value2, "callee") && !propertyIsEnumerable2.call(value2, "callee");
      };
      isArguments_1 = isArguments2;
      return isArguments_1;
    }
    var isBuffer$1 = { exports: {} };
    var stubFalse_1;
    var hasRequiredStubFalse;
    function requireStubFalse() {
      if (hasRequiredStubFalse) return stubFalse_1;
      hasRequiredStubFalse = 1;
      function stubFalse2() {
        return false;
      }
      stubFalse_1 = stubFalse2;
      return stubFalse_1;
    }
    isBuffer$1.exports;
    var hasRequiredIsBuffer;
    function requireIsBuffer() {
      if (hasRequiredIsBuffer) return isBuffer$1.exports;
      hasRequiredIsBuffer = 1;
      (function(module2, exports2) {
        var root2 = require_root(), stubFalse2 = requireStubFalse();
        var freeExports2 = exports2 && !exports2.nodeType && exports2;
        var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
        var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
        var Buffer3 = moduleExports2 ? root2.Buffer : void 0;
        var nativeIsBuffer2 = Buffer3 ? Buffer3.isBuffer : void 0;
        var isBuffer2 = nativeIsBuffer2 || stubFalse2;
        module2.exports = isBuffer2;
      })(isBuffer$1, isBuffer$1.exports);
      return isBuffer$1.exports;
    }
    var _isIndex;
    var hasRequired_isIndex;
    function require_isIndex() {
      if (hasRequired_isIndex) return _isIndex;
      hasRequired_isIndex = 1;
      var MAX_SAFE_INTEGER2 = 9007199254740991;
      var reIsUint2 = /^(?:0|[1-9]\d*)$/;
      function isIndex2(value2, length) {
        var type = typeof value2;
        length = length == null ? MAX_SAFE_INTEGER2 : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint2.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length);
      }
      _isIndex = isIndex2;
      return _isIndex;
    }
    var isLength_1;
    var hasRequiredIsLength;
    function requireIsLength() {
      if (hasRequiredIsLength) return isLength_1;
      hasRequiredIsLength = 1;
      var MAX_SAFE_INTEGER2 = 9007199254740991;
      function isLength2(value2) {
        return typeof value2 == "number" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER2;
      }
      isLength_1 = isLength2;
      return isLength_1;
    }
    var _baseIsTypedArray;
    var hasRequired_baseIsTypedArray;
    function require_baseIsTypedArray() {
      if (hasRequired_baseIsTypedArray) return _baseIsTypedArray;
      hasRequired_baseIsTypedArray = 1;
      var baseGetTag2 = require_baseGetTag(), isLength2 = requireIsLength(), isObjectLike2 = requireIsObjectLike();
      var argsTag2 = "[object Arguments]", arrayTag2 = "[object Array]", boolTag2 = "[object Boolean]", dateTag2 = "[object Date]", errorTag2 = "[object Error]", funcTag2 = "[object Function]", mapTag2 = "[object Map]", numberTag2 = "[object Number]", objectTag2 = "[object Object]", regexpTag2 = "[object RegExp]", setTag2 = "[object Set]", stringTag2 = "[object String]", weakMapTag2 = "[object WeakMap]";
      var arrayBufferTag2 = "[object ArrayBuffer]", dataViewTag2 = "[object DataView]", float32Tag2 = "[object Float32Array]", float64Tag2 = "[object Float64Array]", int8Tag2 = "[object Int8Array]", int16Tag2 = "[object Int16Array]", int32Tag2 = "[object Int32Array]", uint8Tag2 = "[object Uint8Array]", uint8ClampedTag2 = "[object Uint8ClampedArray]", uint16Tag2 = "[object Uint16Array]", uint32Tag2 = "[object Uint32Array]";
      var typedArrayTags2 = {};
      typedArrayTags2[float32Tag2] = typedArrayTags2[float64Tag2] = typedArrayTags2[int8Tag2] = typedArrayTags2[int16Tag2] = typedArrayTags2[int32Tag2] = typedArrayTags2[uint8Tag2] = typedArrayTags2[uint8ClampedTag2] = typedArrayTags2[uint16Tag2] = typedArrayTags2[uint32Tag2] = true;
      typedArrayTags2[argsTag2] = typedArrayTags2[arrayTag2] = typedArrayTags2[arrayBufferTag2] = typedArrayTags2[boolTag2] = typedArrayTags2[dataViewTag2] = typedArrayTags2[dateTag2] = typedArrayTags2[errorTag2] = typedArrayTags2[funcTag2] = typedArrayTags2[mapTag2] = typedArrayTags2[numberTag2] = typedArrayTags2[objectTag2] = typedArrayTags2[regexpTag2] = typedArrayTags2[setTag2] = typedArrayTags2[stringTag2] = typedArrayTags2[weakMapTag2] = false;
      function baseIsTypedArray2(value2) {
        return isObjectLike2(value2) && isLength2(value2.length) && !!typedArrayTags2[baseGetTag2(value2)];
      }
      _baseIsTypedArray = baseIsTypedArray2;
      return _baseIsTypedArray;
    }
    var _baseUnary;
    var hasRequired_baseUnary;
    function require_baseUnary() {
      if (hasRequired_baseUnary) return _baseUnary;
      hasRequired_baseUnary = 1;
      function baseUnary2(func) {
        return function(value2) {
          return func(value2);
        };
      }
      _baseUnary = baseUnary2;
      return _baseUnary;
    }
    var _nodeUtil = { exports: {} };
    _nodeUtil.exports;
    var hasRequired_nodeUtil;
    function require_nodeUtil() {
      if (hasRequired_nodeUtil) return _nodeUtil.exports;
      hasRequired_nodeUtil = 1;
      (function(module2, exports2) {
        var freeGlobal2 = require_freeGlobal();
        var freeExports2 = exports2 && !exports2.nodeType && exports2;
        var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
        var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
        var freeProcess2 = moduleExports2 && freeGlobal2.process;
        var nodeUtil2 = function() {
          try {
            var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
            if (types) {
              return types;
            }
            return freeProcess2 && freeProcess2.binding && freeProcess2.binding("util");
          } catch (e) {
          }
        }();
        module2.exports = nodeUtil2;
      })(_nodeUtil, _nodeUtil.exports);
      return _nodeUtil.exports;
    }
    var isTypedArray_1;
    var hasRequiredIsTypedArray;
    function requireIsTypedArray() {
      if (hasRequiredIsTypedArray) return isTypedArray_1;
      hasRequiredIsTypedArray = 1;
      var baseIsTypedArray2 = require_baseIsTypedArray(), baseUnary2 = require_baseUnary(), nodeUtil2 = require_nodeUtil();
      var nodeIsTypedArray2 = nodeUtil2 && nodeUtil2.isTypedArray;
      var isTypedArray2 = nodeIsTypedArray2 ? baseUnary2(nodeIsTypedArray2) : baseIsTypedArray2;
      isTypedArray_1 = isTypedArray2;
      return isTypedArray_1;
    }
    var _arrayLikeKeys;
    var hasRequired_arrayLikeKeys;
    function require_arrayLikeKeys() {
      if (hasRequired_arrayLikeKeys) return _arrayLikeKeys;
      hasRequired_arrayLikeKeys = 1;
      var baseTimes2 = require_baseTimes(), isArguments2 = requireIsArguments(), isArray2 = requireIsArray(), isBuffer2 = requireIsBuffer(), isIndex2 = require_isIndex(), isTypedArray2 = requireIsTypedArray();
      var objectProto2 = Object.prototype;
      var hasOwnProperty2 = objectProto2.hasOwnProperty;
      function arrayLikeKeys2(value2, inherited) {
        var isArr = isArray2(value2), isArg = !isArr && isArguments2(value2), isBuff = !isArr && !isArg && isBuffer2(value2), isType = !isArr && !isArg && !isBuff && isTypedArray2(value2), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes2(value2.length, String) : [], length = result.length;
        for (var key in value2) {
          if ((inherited || hasOwnProperty2.call(value2, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex2(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      _arrayLikeKeys = arrayLikeKeys2;
      return _arrayLikeKeys;
    }
    var _isPrototype;
    var hasRequired_isPrototype;
    function require_isPrototype() {
      if (hasRequired_isPrototype) return _isPrototype;
      hasRequired_isPrototype = 1;
      var objectProto2 = Object.prototype;
      function isPrototype2(value2) {
        var Ctor = value2 && value2.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
        return value2 === proto;
      }
      _isPrototype = isPrototype2;
      return _isPrototype;
    }
    var _overArg;
    var hasRequired_overArg;
    function require_overArg() {
      if (hasRequired_overArg) return _overArg;
      hasRequired_overArg = 1;
      function overArg2(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      _overArg = overArg2;
      return _overArg;
    }
    var _nativeKeys;
    var hasRequired_nativeKeys;
    function require_nativeKeys() {
      if (hasRequired_nativeKeys) return _nativeKeys;
      hasRequired_nativeKeys = 1;
      var overArg2 = require_overArg();
      var nativeKeys2 = overArg2(Object.keys, Object);
      _nativeKeys = nativeKeys2;
      return _nativeKeys;
    }
    var _baseKeys;
    var hasRequired_baseKeys;
    function require_baseKeys() {
      if (hasRequired_baseKeys) return _baseKeys;
      hasRequired_baseKeys = 1;
      var isPrototype2 = require_isPrototype(), nativeKeys2 = require_nativeKeys();
      var objectProto2 = Object.prototype;
      var hasOwnProperty2 = objectProto2.hasOwnProperty;
      function baseKeys2(object) {
        if (!isPrototype2(object)) {
          return nativeKeys2(object);
        }
        var result = [];
        for (var key in Object(object)) {
          if (hasOwnProperty2.call(object, key) && key != "constructor") {
            result.push(key);
          }
        }
        return result;
      }
      _baseKeys = baseKeys2;
      return _baseKeys;
    }
    var isObject_1;
    var hasRequiredIsObject;
    function requireIsObject() {
      if (hasRequiredIsObject) return isObject_1;
      hasRequiredIsObject = 1;
      function isObject2(value2) {
        var type = typeof value2;
        return value2 != null && (type == "object" || type == "function");
      }
      isObject_1 = isObject2;
      return isObject_1;
    }
    var isFunction_1;
    var hasRequiredIsFunction;
    function requireIsFunction() {
      if (hasRequiredIsFunction) return isFunction_1;
      hasRequiredIsFunction = 1;
      var baseGetTag2 = require_baseGetTag(), isObject2 = requireIsObject();
      var asyncTag2 = "[object AsyncFunction]", funcTag2 = "[object Function]", genTag2 = "[object GeneratorFunction]", proxyTag2 = "[object Proxy]";
      function isFunction2(value2) {
        if (!isObject2(value2)) {
          return false;
        }
        var tag = baseGetTag2(value2);
        return tag == funcTag2 || tag == genTag2 || tag == asyncTag2 || tag == proxyTag2;
      }
      isFunction_1 = isFunction2;
      return isFunction_1;
    }
    var isArrayLike_1;
    var hasRequiredIsArrayLike;
    function requireIsArrayLike() {
      if (hasRequiredIsArrayLike) return isArrayLike_1;
      hasRequiredIsArrayLike = 1;
      var isFunction2 = requireIsFunction(), isLength2 = requireIsLength();
      function isArrayLike2(value2) {
        return value2 != null && isLength2(value2.length) && !isFunction2(value2);
      }
      isArrayLike_1 = isArrayLike2;
      return isArrayLike_1;
    }
    var keys_1;
    var hasRequiredKeys;
    function requireKeys() {
      if (hasRequiredKeys) return keys_1;
      hasRequiredKeys = 1;
      var arrayLikeKeys2 = require_arrayLikeKeys(), baseKeys2 = require_baseKeys(), isArrayLike2 = requireIsArrayLike();
      function keys2(object) {
        return isArrayLike2(object) ? arrayLikeKeys2(object) : baseKeys2(object);
      }
      keys_1 = keys2;
      return keys_1;
    }
    var _baseForOwn;
    var hasRequired_baseForOwn;
    function require_baseForOwn() {
      if (hasRequired_baseForOwn) return _baseForOwn;
      hasRequired_baseForOwn = 1;
      var baseFor2 = require_baseFor(), keys2 = requireKeys();
      function baseForOwn2(object, iteratee) {
        return object && baseFor2(object, iteratee, keys2);
      }
      _baseForOwn = baseForOwn2;
      return _baseForOwn;
    }
    var identity_1;
    var hasRequiredIdentity;
    function requireIdentity() {
      if (hasRequiredIdentity) return identity_1;
      hasRequiredIdentity = 1;
      function identity2(value2) {
        return value2;
      }
      identity_1 = identity2;
      return identity_1;
    }
    var _castFunction;
    var hasRequired_castFunction;
    function require_castFunction() {
      if (hasRequired_castFunction) return _castFunction;
      hasRequired_castFunction = 1;
      var identity2 = requireIdentity();
      function castFunction2(value2) {
        return typeof value2 == "function" ? value2 : identity2;
      }
      _castFunction = castFunction2;
      return _castFunction;
    }
    var forOwn_1;
    var hasRequiredForOwn;
    function requireForOwn() {
      if (hasRequiredForOwn) return forOwn_1;
      hasRequiredForOwn = 1;
      var baseForOwn2 = require_baseForOwn(), castFunction2 = require_castFunction();
      function forOwn(object, iteratee) {
        return object && baseForOwn2(object, castFunction2(iteratee));
      }
      forOwn_1 = forOwn;
      return forOwn_1;
    }
    var _getPrototype;
    var hasRequired_getPrototype;
    function require_getPrototype() {
      if (hasRequired_getPrototype) return _getPrototype;
      hasRequired_getPrototype = 1;
      var overArg2 = require_overArg();
      var getPrototype2 = overArg2(Object.getPrototypeOf, Object);
      _getPrototype = getPrototype2;
      return _getPrototype;
    }
    var isPlainObject_1;
    var hasRequiredIsPlainObject;
    function requireIsPlainObject() {
      if (hasRequiredIsPlainObject) return isPlainObject_1;
      hasRequiredIsPlainObject = 1;
      var baseGetTag2 = require_baseGetTag(), getPrototype2 = require_getPrototype(), isObjectLike2 = requireIsObjectLike();
      var objectTag2 = "[object Object]";
      var funcProto2 = Function.prototype, objectProto2 = Object.prototype;
      var funcToString2 = funcProto2.toString;
      var hasOwnProperty2 = objectProto2.hasOwnProperty;
      var objectCtorString2 = funcToString2.call(Object);
      function isPlainObject2(value2) {
        if (!isObjectLike2(value2) || baseGetTag2(value2) != objectTag2) {
          return false;
        }
        var proto = getPrototype2(value2);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString2.call(Ctor) == objectCtorString2;
      }
      isPlainObject_1 = isPlainObject2;
      return isPlainObject_1;
    }
    var _arrayMap;
    var hasRequired_arrayMap;
    function require_arrayMap() {
      if (hasRequired_arrayMap) return _arrayMap;
      hasRequired_arrayMap = 1;
      function arrayMap2(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      _arrayMap = arrayMap2;
      return _arrayMap;
    }
    var _listCacheClear;
    var hasRequired_listCacheClear;
    function require_listCacheClear() {
      if (hasRequired_listCacheClear) return _listCacheClear;
      hasRequired_listCacheClear = 1;
      function listCacheClear2() {
        this.__data__ = [];
        this.size = 0;
      }
      _listCacheClear = listCacheClear2;
      return _listCacheClear;
    }
    var eq_1;
    var hasRequiredEq;
    function requireEq() {
      if (hasRequiredEq) return eq_1;
      hasRequiredEq = 1;
      function eq2(value2, other) {
        return value2 === other || value2 !== value2 && other !== other;
      }
      eq_1 = eq2;
      return eq_1;
    }
    var _assocIndexOf;
    var hasRequired_assocIndexOf;
    function require_assocIndexOf() {
      if (hasRequired_assocIndexOf) return _assocIndexOf;
      hasRequired_assocIndexOf = 1;
      var eq2 = requireEq();
      function assocIndexOf2(array, key) {
        var length = array.length;
        while (length--) {
          if (eq2(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      _assocIndexOf = assocIndexOf2;
      return _assocIndexOf;
    }
    var _listCacheDelete;
    var hasRequired_listCacheDelete;
    function require_listCacheDelete() {
      if (hasRequired_listCacheDelete) return _listCacheDelete;
      hasRequired_listCacheDelete = 1;
      var assocIndexOf2 = require_assocIndexOf();
      var arrayProto2 = Array.prototype;
      var splice2 = arrayProto2.splice;
      function listCacheDelete2(key) {
        var data = this.__data__, index = assocIndexOf2(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice2.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      _listCacheDelete = listCacheDelete2;
      return _listCacheDelete;
    }
    var _listCacheGet;
    var hasRequired_listCacheGet;
    function require_listCacheGet() {
      if (hasRequired_listCacheGet) return _listCacheGet;
      hasRequired_listCacheGet = 1;
      var assocIndexOf2 = require_assocIndexOf();
      function listCacheGet2(key) {
        var data = this.__data__, index = assocIndexOf2(data, key);
        return index < 0 ? void 0 : data[index][1];
      }
      _listCacheGet = listCacheGet2;
      return _listCacheGet;
    }
    var _listCacheHas;
    var hasRequired_listCacheHas;
    function require_listCacheHas() {
      if (hasRequired_listCacheHas) return _listCacheHas;
      hasRequired_listCacheHas = 1;
      var assocIndexOf2 = require_assocIndexOf();
      function listCacheHas2(key) {
        return assocIndexOf2(this.__data__, key) > -1;
      }
      _listCacheHas = listCacheHas2;
      return _listCacheHas;
    }
    var _listCacheSet;
    var hasRequired_listCacheSet;
    function require_listCacheSet() {
      if (hasRequired_listCacheSet) return _listCacheSet;
      hasRequired_listCacheSet = 1;
      var assocIndexOf2 = require_assocIndexOf();
      function listCacheSet2(key, value2) {
        var data = this.__data__, index = assocIndexOf2(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value2]);
        } else {
          data[index][1] = value2;
        }
        return this;
      }
      _listCacheSet = listCacheSet2;
      return _listCacheSet;
    }
    var _ListCache;
    var hasRequired_ListCache;
    function require_ListCache() {
      if (hasRequired_ListCache) return _ListCache;
      hasRequired_ListCache = 1;
      var listCacheClear2 = require_listCacheClear(), listCacheDelete2 = require_listCacheDelete(), listCacheGet2 = require_listCacheGet(), listCacheHas2 = require_listCacheHas(), listCacheSet2 = require_listCacheSet();
      function ListCache2(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      ListCache2.prototype.clear = listCacheClear2;
      ListCache2.prototype["delete"] = listCacheDelete2;
      ListCache2.prototype.get = listCacheGet2;
      ListCache2.prototype.has = listCacheHas2;
      ListCache2.prototype.set = listCacheSet2;
      _ListCache = ListCache2;
      return _ListCache;
    }
    var _stackClear;
    var hasRequired_stackClear;
    function require_stackClear() {
      if (hasRequired_stackClear) return _stackClear;
      hasRequired_stackClear = 1;
      var ListCache2 = require_ListCache();
      function stackClear2() {
        this.__data__ = new ListCache2();
        this.size = 0;
      }
      _stackClear = stackClear2;
      return _stackClear;
    }
    var _stackDelete;
    var hasRequired_stackDelete;
    function require_stackDelete() {
      if (hasRequired_stackDelete) return _stackDelete;
      hasRequired_stackDelete = 1;
      function stackDelete2(key) {
        var data = this.__data__, result = data["delete"](key);
        this.size = data.size;
        return result;
      }
      _stackDelete = stackDelete2;
      return _stackDelete;
    }
    var _stackGet;
    var hasRequired_stackGet;
    function require_stackGet() {
      if (hasRequired_stackGet) return _stackGet;
      hasRequired_stackGet = 1;
      function stackGet2(key) {
        return this.__data__.get(key);
      }
      _stackGet = stackGet2;
      return _stackGet;
    }
    var _stackHas;
    var hasRequired_stackHas;
    function require_stackHas() {
      if (hasRequired_stackHas) return _stackHas;
      hasRequired_stackHas = 1;
      function stackHas2(key) {
        return this.__data__.has(key);
      }
      _stackHas = stackHas2;
      return _stackHas;
    }
    var _coreJsData;
    var hasRequired_coreJsData;
    function require_coreJsData() {
      if (hasRequired_coreJsData) return _coreJsData;
      hasRequired_coreJsData = 1;
      var root2 = require_root();
      var coreJsData2 = root2["__core-js_shared__"];
      _coreJsData = coreJsData2;
      return _coreJsData;
    }
    var _isMasked;
    var hasRequired_isMasked;
    function require_isMasked() {
      if (hasRequired_isMasked) return _isMasked;
      hasRequired_isMasked = 1;
      var coreJsData2 = require_coreJsData();
      var maskSrcKey2 = function() {
        var uid = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      function isMasked2(func) {
        return !!maskSrcKey2 && maskSrcKey2 in func;
      }
      _isMasked = isMasked2;
      return _isMasked;
    }
    var _toSource;
    var hasRequired_toSource;
    function require_toSource() {
      if (hasRequired_toSource) return _toSource;
      hasRequired_toSource = 1;
      var funcProto2 = Function.prototype;
      var funcToString2 = funcProto2.toString;
      function toSource2(func) {
        if (func != null) {
          try {
            return funcToString2.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      _toSource = toSource2;
      return _toSource;
    }
    var _baseIsNative;
    var hasRequired_baseIsNative;
    function require_baseIsNative() {
      if (hasRequired_baseIsNative) return _baseIsNative;
      hasRequired_baseIsNative = 1;
      var isFunction2 = requireIsFunction(), isMasked2 = require_isMasked(), isObject2 = requireIsObject(), toSource2 = require_toSource();
      var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
      var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
      var funcProto2 = Function.prototype, objectProto2 = Object.prototype;
      var funcToString2 = funcProto2.toString;
      var hasOwnProperty2 = objectProto2.hasOwnProperty;
      var reIsNative2 = RegExp(
        "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      function baseIsNative2(value2) {
        if (!isObject2(value2) || isMasked2(value2)) {
          return false;
        }
        var pattern2 = isFunction2(value2) ? reIsNative2 : reIsHostCtor2;
        return pattern2.test(toSource2(value2));
      }
      _baseIsNative = baseIsNative2;
      return _baseIsNative;
    }
    var _getValue;
    var hasRequired_getValue;
    function require_getValue() {
      if (hasRequired_getValue) return _getValue;
      hasRequired_getValue = 1;
      function getValue2(object, key) {
        return object == null ? void 0 : object[key];
      }
      _getValue = getValue2;
      return _getValue;
    }
    var _getNative;
    var hasRequired_getNative;
    function require_getNative() {
      if (hasRequired_getNative) return _getNative;
      hasRequired_getNative = 1;
      var baseIsNative2 = require_baseIsNative(), getValue2 = require_getValue();
      function getNative2(object, key) {
        var value2 = getValue2(object, key);
        return baseIsNative2(value2) ? value2 : void 0;
      }
      _getNative = getNative2;
      return _getNative;
    }
    var _Map;
    var hasRequired_Map;
    function require_Map() {
      if (hasRequired_Map) return _Map;
      hasRequired_Map = 1;
      var getNative2 = require_getNative(), root2 = require_root();
      var Map2 = getNative2(root2, "Map");
      _Map = Map2;
      return _Map;
    }
    var _nativeCreate;
    var hasRequired_nativeCreate;
    function require_nativeCreate() {
      if (hasRequired_nativeCreate) return _nativeCreate;
      hasRequired_nativeCreate = 1;
      var getNative2 = require_getNative();
      var nativeCreate2 = getNative2(Object, "create");
      _nativeCreate = nativeCreate2;
      return _nativeCreate;
    }
    var _hashClear;
    var hasRequired_hashClear;
    function require_hashClear() {
      if (hasRequired_hashClear) return _hashClear;
      hasRequired_hashClear = 1;
      var nativeCreate2 = require_nativeCreate();
      function hashClear2() {
        this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
        this.size = 0;
      }
      _hashClear = hashClear2;
      return _hashClear;
    }
    var _hashDelete;
    var hasRequired_hashDelete;
    function require_hashDelete() {
      if (hasRequired_hashDelete) return _hashDelete;
      hasRequired_hashDelete = 1;
      function hashDelete2(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }
      _hashDelete = hashDelete2;
      return _hashDelete;
    }
    var _hashGet;
    var hasRequired_hashGet;
    function require_hashGet() {
      if (hasRequired_hashGet) return _hashGet;
      hasRequired_hashGet = 1;
      var nativeCreate2 = require_nativeCreate();
      var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
      var objectProto2 = Object.prototype;
      var hasOwnProperty2 = objectProto2.hasOwnProperty;
      function hashGet2(key) {
        var data = this.__data__;
        if (nativeCreate2) {
          var result = data[key];
          return result === HASH_UNDEFINED2 ? void 0 : result;
        }
        return hasOwnProperty2.call(data, key) ? data[key] : void 0;
      }
      _hashGet = hashGet2;
      return _hashGet;
    }
    var _hashHas;
    var hasRequired_hashHas;
    function require_hashHas() {
      if (hasRequired_hashHas) return _hashHas;
      hasRequired_hashHas = 1;
      var nativeCreate2 = require_nativeCreate();
      var objectProto2 = Object.prototype;
      var hasOwnProperty2 = objectProto2.hasOwnProperty;
      function hashHas2(key) {
        var data = this.__data__;
        return nativeCreate2 ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
      }
      _hashHas = hashHas2;
      return _hashHas;
    }
    var _hashSet;
    var hasRequired_hashSet;
    function require_hashSet() {
      if (hasRequired_hashSet) return _hashSet;
      hasRequired_hashSet = 1;
      var nativeCreate2 = require_nativeCreate();
      var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
      function hashSet2(key, value2) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate2 && value2 === void 0 ? HASH_UNDEFINED2 : value2;
        return this;
      }
      _hashSet = hashSet2;
      return _hashSet;
    }
    var _Hash;
    var hasRequired_Hash;
    function require_Hash() {
      if (hasRequired_Hash) return _Hash;
      hasRequired_Hash = 1;
      var hashClear2 = require_hashClear(), hashDelete2 = require_hashDelete(), hashGet2 = require_hashGet(), hashHas2 = require_hashHas(), hashSet2 = require_hashSet();
      function Hash2(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      Hash2.prototype.clear = hashClear2;
      Hash2.prototype["delete"] = hashDelete2;
      Hash2.prototype.get = hashGet2;
      Hash2.prototype.has = hashHas2;
      Hash2.prototype.set = hashSet2;
      _Hash = Hash2;
      return _Hash;
    }
    var _mapCacheClear;
    var hasRequired_mapCacheClear;
    function require_mapCacheClear() {
      if (hasRequired_mapCacheClear) return _mapCacheClear;
      hasRequired_mapCacheClear = 1;
      var Hash2 = require_Hash(), ListCache2 = require_ListCache(), Map2 = require_Map();
      function mapCacheClear2() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash2(),
          "map": new (Map2 || ListCache2)(),
          "string": new Hash2()
        };
      }
      _mapCacheClear = mapCacheClear2;
      return _mapCacheClear;
    }
    var _isKeyable;
    var hasRequired_isKeyable;
    function require_isKeyable() {
      if (hasRequired_isKeyable) return _isKeyable;
      hasRequired_isKeyable = 1;
      function isKeyable2(value2) {
        var type = typeof value2;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value2 !== "__proto__" : value2 === null;
      }
      _isKeyable = isKeyable2;
      return _isKeyable;
    }
    var _getMapData;
    var hasRequired_getMapData;
    function require_getMapData() {
      if (hasRequired_getMapData) return _getMapData;
      hasRequired_getMapData = 1;
      var isKeyable2 = require_isKeyable();
      function getMapData2(map2, key) {
        var data = map2.__data__;
        return isKeyable2(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      _getMapData = getMapData2;
      return _getMapData;
    }
    var _mapCacheDelete;
    var hasRequired_mapCacheDelete;
    function require_mapCacheDelete() {
      if (hasRequired_mapCacheDelete) return _mapCacheDelete;
      hasRequired_mapCacheDelete = 1;
      var getMapData2 = require_getMapData();
      function mapCacheDelete2(key) {
        var result = getMapData2(this, key)["delete"](key);
        this.size -= result ? 1 : 0;
        return result;
      }
      _mapCacheDelete = mapCacheDelete2;
      return _mapCacheDelete;
    }
    var _mapCacheGet;
    var hasRequired_mapCacheGet;
    function require_mapCacheGet() {
      if (hasRequired_mapCacheGet) return _mapCacheGet;
      hasRequired_mapCacheGet = 1;
      var getMapData2 = require_getMapData();
      function mapCacheGet2(key) {
        return getMapData2(this, key).get(key);
      }
      _mapCacheGet = mapCacheGet2;
      return _mapCacheGet;
    }
    var _mapCacheHas;
    var hasRequired_mapCacheHas;
    function require_mapCacheHas() {
      if (hasRequired_mapCacheHas) return _mapCacheHas;
      hasRequired_mapCacheHas = 1;
      var getMapData2 = require_getMapData();
      function mapCacheHas2(key) {
        return getMapData2(this, key).has(key);
      }
      _mapCacheHas = mapCacheHas2;
      return _mapCacheHas;
    }
    var _mapCacheSet;
    var hasRequired_mapCacheSet;
    function require_mapCacheSet() {
      if (hasRequired_mapCacheSet) return _mapCacheSet;
      hasRequired_mapCacheSet = 1;
      var getMapData2 = require_getMapData();
      function mapCacheSet2(key, value2) {
        var data = getMapData2(this, key), size = data.size;
        data.set(key, value2);
        this.size += data.size == size ? 0 : 1;
        return this;
      }
      _mapCacheSet = mapCacheSet2;
      return _mapCacheSet;
    }
    var _MapCache;
    var hasRequired_MapCache;
    function require_MapCache() {
      if (hasRequired_MapCache) return _MapCache;
      hasRequired_MapCache = 1;
      var mapCacheClear2 = require_mapCacheClear(), mapCacheDelete2 = require_mapCacheDelete(), mapCacheGet2 = require_mapCacheGet(), mapCacheHas2 = require_mapCacheHas(), mapCacheSet2 = require_mapCacheSet();
      function MapCache2(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      MapCache2.prototype.clear = mapCacheClear2;
      MapCache2.prototype["delete"] = mapCacheDelete2;
      MapCache2.prototype.get = mapCacheGet2;
      MapCache2.prototype.has = mapCacheHas2;
      MapCache2.prototype.set = mapCacheSet2;
      _MapCache = MapCache2;
      return _MapCache;
    }
    var _stackSet;
    var hasRequired_stackSet;
    function require_stackSet() {
      if (hasRequired_stackSet) return _stackSet;
      hasRequired_stackSet = 1;
      var ListCache2 = require_ListCache(), Map2 = require_Map(), MapCache2 = require_MapCache();
      var LARGE_ARRAY_SIZE2 = 200;
      function stackSet2(key, value2) {
        var data = this.__data__;
        if (data instanceof ListCache2) {
          var pairs = data.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE2 - 1) {
            pairs.push([key, value2]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache2(pairs);
        }
        data.set(key, value2);
        this.size = data.size;
        return this;
      }
      _stackSet = stackSet2;
      return _stackSet;
    }
    var _Stack;
    var hasRequired_Stack;
    function require_Stack() {
      if (hasRequired_Stack) return _Stack;
      hasRequired_Stack = 1;
      var ListCache2 = require_ListCache(), stackClear2 = require_stackClear(), stackDelete2 = require_stackDelete(), stackGet2 = require_stackGet(), stackHas2 = require_stackHas(), stackSet2 = require_stackSet();
      function Stack2(entries) {
        var data = this.__data__ = new ListCache2(entries);
        this.size = data.size;
      }
      Stack2.prototype.clear = stackClear2;
      Stack2.prototype["delete"] = stackDelete2;
      Stack2.prototype.get = stackGet2;
      Stack2.prototype.has = stackHas2;
      Stack2.prototype.set = stackSet2;
      _Stack = Stack2;
      return _Stack;
    }
    var _setCacheAdd;
    var hasRequired_setCacheAdd;
    function require_setCacheAdd() {
      if (hasRequired_setCacheAdd) return _setCacheAdd;
      hasRequired_setCacheAdd = 1;
      var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
      function setCacheAdd2(value2) {
        this.__data__.set(value2, HASH_UNDEFINED2);
        return this;
      }
      _setCacheAdd = setCacheAdd2;
      return _setCacheAdd;
    }
    var _setCacheHas;
    var hasRequired_setCacheHas;
    function require_setCacheHas() {
      if (hasRequired_setCacheHas) return _setCacheHas;
      hasRequired_setCacheHas = 1;
      function setCacheHas2(value2) {
        return this.__data__.has(value2);
      }
      _setCacheHas = setCacheHas2;
      return _setCacheHas;
    }
    var _SetCache;
    var hasRequired_SetCache;
    function require_SetCache() {
      if (hasRequired_SetCache) return _SetCache;
      hasRequired_SetCache = 1;
      var MapCache2 = require_MapCache(), setCacheAdd2 = require_setCacheAdd(), setCacheHas2 = require_setCacheHas();
      function SetCache2(values) {
        var index = -1, length = values == null ? 0 : values.length;
        this.__data__ = new MapCache2();
        while (++index < length) {
          this.add(values[index]);
        }
      }
      SetCache2.prototype.add = SetCache2.prototype.push = setCacheAdd2;
      SetCache2.prototype.has = setCacheHas2;
      _SetCache = SetCache2;
      return _SetCache;
    }
    var _arraySome;
    var hasRequired_arraySome;
    function require_arraySome() {
      if (hasRequired_arraySome) return _arraySome;
      hasRequired_arraySome = 1;
      function arraySome2(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      _arraySome = arraySome2;
      return _arraySome;
    }
    var _cacheHas;
    var hasRequired_cacheHas;
    function require_cacheHas() {
      if (hasRequired_cacheHas) return _cacheHas;
      hasRequired_cacheHas = 1;
      function cacheHas2(cache, key) {
        return cache.has(key);
      }
      _cacheHas = cacheHas2;
      return _cacheHas;
    }
    var _equalArrays;
    var hasRequired_equalArrays;
    function require_equalArrays() {
      if (hasRequired_equalArrays) return _equalArrays;
      hasRequired_equalArrays = 1;
      var SetCache2 = require_SetCache(), arraySome2 = require_arraySome(), cacheHas2 = require_cacheHas();
      var COMPARE_PARTIAL_FLAG2 = 1, COMPARE_UNORDERED_FLAG2 = 2;
      function equalArrays2(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG2, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG2 ? new SetCache2() : void 0;
        stack.set(array, other);
        stack.set(other, array);
        while (++index < arrLength) {
          var arrValue = array[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
          }
          if (compared !== void 0) {
            if (compared) {
              continue;
            }
            result = false;
            break;
          }
          if (seen) {
            if (!arraySome2(other, function(othValue2, othIndex) {
              if (!cacheHas2(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result;
      }
      _equalArrays = equalArrays2;
      return _equalArrays;
    }
    var _Uint8Array;
    var hasRequired_Uint8Array;
    function require_Uint8Array() {
      if (hasRequired_Uint8Array) return _Uint8Array;
      hasRequired_Uint8Array = 1;
      var root2 = require_root();
      var Uint8Array3 = root2.Uint8Array;
      _Uint8Array = Uint8Array3;
      return _Uint8Array;
    }
    var _mapToArray;
    var hasRequired_mapToArray;
    function require_mapToArray() {
      if (hasRequired_mapToArray) return _mapToArray;
      hasRequired_mapToArray = 1;
      function mapToArray2(map2) {
        var index = -1, result = Array(map2.size);
        map2.forEach(function(value2, key) {
          result[++index] = [key, value2];
        });
        return result;
      }
      _mapToArray = mapToArray2;
      return _mapToArray;
    }
    var _setToArray;
    var hasRequired_setToArray;
    function require_setToArray() {
      if (hasRequired_setToArray) return _setToArray;
      hasRequired_setToArray = 1;
      function setToArray2(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value2) {
          result[++index] = value2;
        });
        return result;
      }
      _setToArray = setToArray2;
      return _setToArray;
    }
    var _equalByTag;
    var hasRequired_equalByTag;
    function require_equalByTag() {
      if (hasRequired_equalByTag) return _equalByTag;
      hasRequired_equalByTag = 1;
      var Symbol2 = require_Symbol(), Uint8Array3 = require_Uint8Array(), eq2 = requireEq(), equalArrays2 = require_equalArrays(), mapToArray2 = require_mapToArray(), setToArray2 = require_setToArray();
      var COMPARE_PARTIAL_FLAG2 = 1, COMPARE_UNORDERED_FLAG2 = 2;
      var boolTag2 = "[object Boolean]", dateTag2 = "[object Date]", errorTag2 = "[object Error]", mapTag2 = "[object Map]", numberTag2 = "[object Number]", regexpTag2 = "[object RegExp]", setTag2 = "[object Set]", stringTag2 = "[object String]", symbolTag2 = "[object Symbol]";
      var arrayBufferTag2 = "[object ArrayBuffer]", dataViewTag2 = "[object DataView]";
      var symbolProto2 = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf2 = symbolProto2 ? symbolProto2.valueOf : void 0;
      function equalByTag2(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag2:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag2:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array3(object), new Uint8Array3(other))) {
              return false;
            }
            return true;
          case boolTag2:
          case dateTag2:
          case numberTag2:
            return eq2(+object, +other);
          case errorTag2:
            return object.name == other.name && object.message == other.message;
          case regexpTag2:
          case stringTag2:
            return object == other + "";
          case mapTag2:
            var convert = mapToArray2;
          case setTag2:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG2;
            convert || (convert = setToArray2);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG2;
            stack.set(object, other);
            var result = equalArrays2(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result;
          case symbolTag2:
            if (symbolValueOf2) {
              return symbolValueOf2.call(object) == symbolValueOf2.call(other);
            }
        }
        return false;
      }
      _equalByTag = equalByTag2;
      return _equalByTag;
    }
    var _arrayPush;
    var hasRequired_arrayPush;
    function require_arrayPush() {
      if (hasRequired_arrayPush) return _arrayPush;
      hasRequired_arrayPush = 1;
      function arrayPush2(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      _arrayPush = arrayPush2;
      return _arrayPush;
    }
    var _baseGetAllKeys;
    var hasRequired_baseGetAllKeys;
    function require_baseGetAllKeys() {
      if (hasRequired_baseGetAllKeys) return _baseGetAllKeys;
      hasRequired_baseGetAllKeys = 1;
      var arrayPush2 = require_arrayPush(), isArray2 = requireIsArray();
      function baseGetAllKeys2(object, keysFunc, symbolsFunc) {
        var result = keysFunc(object);
        return isArray2(object) ? result : arrayPush2(result, symbolsFunc(object));
      }
      _baseGetAllKeys = baseGetAllKeys2;
      return _baseGetAllKeys;
    }
    var _arrayFilter;
    var hasRequired_arrayFilter;
    function require_arrayFilter() {
      if (hasRequired_arrayFilter) return _arrayFilter;
      hasRequired_arrayFilter = 1;
      function arrayFilter2(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value2 = array[index];
          if (predicate(value2, index, array)) {
            result[resIndex++] = value2;
          }
        }
        return result;
      }
      _arrayFilter = arrayFilter2;
      return _arrayFilter;
    }
    var stubArray_1;
    var hasRequiredStubArray;
    function requireStubArray() {
      if (hasRequiredStubArray) return stubArray_1;
      hasRequiredStubArray = 1;
      function stubArray2() {
        return [];
      }
      stubArray_1 = stubArray2;
      return stubArray_1;
    }
    var _getSymbols;
    var hasRequired_getSymbols;
    function require_getSymbols() {
      if (hasRequired_getSymbols) return _getSymbols;
      hasRequired_getSymbols = 1;
      var arrayFilter2 = require_arrayFilter(), stubArray2 = requireStubArray();
      var objectProto2 = Object.prototype;
      var propertyIsEnumerable2 = objectProto2.propertyIsEnumerable;
      var nativeGetSymbols2 = Object.getOwnPropertySymbols;
      var getSymbols2 = !nativeGetSymbols2 ? stubArray2 : function(object) {
        if (object == null) {
          return [];
        }
        object = Object(object);
        return arrayFilter2(nativeGetSymbols2(object), function(symbol) {
          return propertyIsEnumerable2.call(object, symbol);
        });
      };
      _getSymbols = getSymbols2;
      return _getSymbols;
    }
    var _getAllKeys;
    var hasRequired_getAllKeys;
    function require_getAllKeys() {
      if (hasRequired_getAllKeys) return _getAllKeys;
      hasRequired_getAllKeys = 1;
      var baseGetAllKeys2 = require_baseGetAllKeys(), getSymbols2 = require_getSymbols(), keys2 = requireKeys();
      function getAllKeys2(object) {
        return baseGetAllKeys2(object, keys2, getSymbols2);
      }
      _getAllKeys = getAllKeys2;
      return _getAllKeys;
    }
    var _equalObjects;
    var hasRequired_equalObjects;
    function require_equalObjects() {
      if (hasRequired_equalObjects) return _equalObjects;
      hasRequired_equalObjects = 1;
      var getAllKeys2 = require_getAllKeys();
      var COMPARE_PARTIAL_FLAG2 = 1;
      var objectProto2 = Object.prototype;
      var hasOwnProperty2 = objectProto2.hasOwnProperty;
      function equalObjects2(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG2, objProps = getAllKeys2(object), objLength = objProps.length, othProps = getAllKeys2(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result;
      }
      _equalObjects = equalObjects2;
      return _equalObjects;
    }
    var _DataView;
    var hasRequired_DataView;
    function require_DataView() {
      if (hasRequired_DataView) return _DataView;
      hasRequired_DataView = 1;
      var getNative2 = require_getNative(), root2 = require_root();
      var DataView2 = getNative2(root2, "DataView");
      _DataView = DataView2;
      return _DataView;
    }
    var _Promise;
    var hasRequired_Promise;
    function require_Promise() {
      if (hasRequired_Promise) return _Promise;
      hasRequired_Promise = 1;
      var getNative2 = require_getNative(), root2 = require_root();
      var Promise2 = getNative2(root2, "Promise");
      _Promise = Promise2;
      return _Promise;
    }
    var _Set;
    var hasRequired_Set;
    function require_Set() {
      if (hasRequired_Set) return _Set;
      hasRequired_Set = 1;
      var getNative2 = require_getNative(), root2 = require_root();
      var Set2 = getNative2(root2, "Set");
      _Set = Set2;
      return _Set;
    }
    var _WeakMap;
    var hasRequired_WeakMap;
    function require_WeakMap() {
      if (hasRequired_WeakMap) return _WeakMap;
      hasRequired_WeakMap = 1;
      var getNative2 = require_getNative(), root2 = require_root();
      var WeakMap2 = getNative2(root2, "WeakMap");
      _WeakMap = WeakMap2;
      return _WeakMap;
    }
    var _getTag;
    var hasRequired_getTag;
    function require_getTag() {
      if (hasRequired_getTag) return _getTag;
      hasRequired_getTag = 1;
      var DataView2 = require_DataView(), Map2 = require_Map(), Promise2 = require_Promise(), Set2 = require_Set(), WeakMap2 = require_WeakMap(), baseGetTag2 = require_baseGetTag(), toSource2 = require_toSource();
      var mapTag2 = "[object Map]", objectTag2 = "[object Object]", promiseTag2 = "[object Promise]", setTag2 = "[object Set]", weakMapTag2 = "[object WeakMap]";
      var dataViewTag2 = "[object DataView]";
      var dataViewCtorString2 = toSource2(DataView2), mapCtorString2 = toSource2(Map2), promiseCtorString2 = toSource2(Promise2), setCtorString2 = toSource2(Set2), weakMapCtorString2 = toSource2(WeakMap2);
      var getTag2 = baseGetTag2;
      if (DataView2 && getTag2(new DataView2(new ArrayBuffer(1))) != dataViewTag2 || Map2 && getTag2(new Map2()) != mapTag2 || Promise2 && getTag2(Promise2.resolve()) != promiseTag2 || Set2 && getTag2(new Set2()) != setTag2 || WeakMap2 && getTag2(new WeakMap2()) != weakMapTag2) {
        getTag2 = function(value2) {
          var result = baseGetTag2(value2), Ctor = result == objectTag2 ? value2.constructor : void 0, ctorString = Ctor ? toSource2(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString2:
                return dataViewTag2;
              case mapCtorString2:
                return mapTag2;
              case promiseCtorString2:
                return promiseTag2;
              case setCtorString2:
                return setTag2;
              case weakMapCtorString2:
                return weakMapTag2;
            }
          }
          return result;
        };
      }
      _getTag = getTag2;
      return _getTag;
    }
    var _baseIsEqualDeep;
    var hasRequired_baseIsEqualDeep;
    function require_baseIsEqualDeep() {
      if (hasRequired_baseIsEqualDeep) return _baseIsEqualDeep;
      hasRequired_baseIsEqualDeep = 1;
      var Stack2 = require_Stack(), equalArrays2 = require_equalArrays(), equalByTag2 = require_equalByTag(), equalObjects2 = require_equalObjects(), getTag2 = require_getTag(), isArray2 = requireIsArray(), isBuffer2 = requireIsBuffer(), isTypedArray2 = requireIsTypedArray();
      var COMPARE_PARTIAL_FLAG2 = 1;
      var argsTag2 = "[object Arguments]", arrayTag2 = "[object Array]", objectTag2 = "[object Object]";
      var objectProto2 = Object.prototype;
      var hasOwnProperty2 = objectProto2.hasOwnProperty;
      function baseIsEqualDeep2(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag2 : getTag2(object), othTag = othIsArr ? arrayTag2 : getTag2(other);
        objTag = objTag == argsTag2 ? objectTag2 : objTag;
        othTag = othTag == argsTag2 ? objectTag2 : othTag;
        var objIsObj = objTag == objectTag2, othIsObj = othTag == objectTag2, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer2(object)) {
          if (!isBuffer2(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack2());
          return objIsArr || isTypedArray2(object) ? equalArrays2(object, other, bitmask, customizer, equalFunc, stack) : equalByTag2(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG2)) {
          var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack2());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack2());
        return equalObjects2(object, other, bitmask, customizer, equalFunc, stack);
      }
      _baseIsEqualDeep = baseIsEqualDeep2;
      return _baseIsEqualDeep;
    }
    var _baseIsEqual;
    var hasRequired_baseIsEqual;
    function require_baseIsEqual() {
      if (hasRequired_baseIsEqual) return _baseIsEqual;
      hasRequired_baseIsEqual = 1;
      var baseIsEqualDeep2 = require_baseIsEqualDeep(), isObjectLike2 = requireIsObjectLike();
      function baseIsEqual2(value2, other, bitmask, customizer, stack) {
        if (value2 === other) {
          return true;
        }
        if (value2 == null || other == null || !isObjectLike2(value2) && !isObjectLike2(other)) {
          return value2 !== value2 && other !== other;
        }
        return baseIsEqualDeep2(value2, other, bitmask, customizer, baseIsEqual2, stack);
      }
      _baseIsEqual = baseIsEqual2;
      return _baseIsEqual;
    }
    var _baseIsMatch;
    var hasRequired_baseIsMatch;
    function require_baseIsMatch() {
      if (hasRequired_baseIsMatch) return _baseIsMatch;
      hasRequired_baseIsMatch = 1;
      var Stack2 = require_Stack(), baseIsEqual2 = require_baseIsEqual();
      var COMPARE_PARTIAL_FLAG2 = 1, COMPARE_UNORDERED_FLAG2 = 2;
      function baseIsMatch2(object, source, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object(object);
        while (index--) {
          var data = matchData[index];
          if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
          }
        }
        while (++index < length) {
          data = matchData[index];
          var key = data[0], objValue = object[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === void 0 && !(key in object)) {
              return false;
            }
          } else {
            var stack = new Stack2();
            if (customizer) {
              var result = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result === void 0 ? baseIsEqual2(srcValue, objValue, COMPARE_PARTIAL_FLAG2 | COMPARE_UNORDERED_FLAG2, customizer, stack) : result)) {
              return false;
            }
          }
        }
        return true;
      }
      _baseIsMatch = baseIsMatch2;
      return _baseIsMatch;
    }
    var _isStrictComparable;
    var hasRequired_isStrictComparable;
    function require_isStrictComparable() {
      if (hasRequired_isStrictComparable) return _isStrictComparable;
      hasRequired_isStrictComparable = 1;
      var isObject2 = requireIsObject();
      function isStrictComparable2(value2) {
        return value2 === value2 && !isObject2(value2);
      }
      _isStrictComparable = isStrictComparable2;
      return _isStrictComparable;
    }
    var _getMatchData;
    var hasRequired_getMatchData;
    function require_getMatchData() {
      if (hasRequired_getMatchData) return _getMatchData;
      hasRequired_getMatchData = 1;
      var isStrictComparable2 = require_isStrictComparable(), keys2 = requireKeys();
      function getMatchData2(object) {
        var result = keys2(object), length = result.length;
        while (length--) {
          var key = result[length], value2 = object[key];
          result[length] = [key, value2, isStrictComparable2(value2)];
        }
        return result;
      }
      _getMatchData = getMatchData2;
      return _getMatchData;
    }
    var _matchesStrictComparable;
    var hasRequired_matchesStrictComparable;
    function require_matchesStrictComparable() {
      if (hasRequired_matchesStrictComparable) return _matchesStrictComparable;
      hasRequired_matchesStrictComparable = 1;
      function matchesStrictComparable2(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
        };
      }
      _matchesStrictComparable = matchesStrictComparable2;
      return _matchesStrictComparable;
    }
    var _baseMatches;
    var hasRequired_baseMatches;
    function require_baseMatches() {
      if (hasRequired_baseMatches) return _baseMatches;
      hasRequired_baseMatches = 1;
      var baseIsMatch2 = require_baseIsMatch(), getMatchData2 = require_getMatchData(), matchesStrictComparable2 = require_matchesStrictComparable();
      function baseMatches2(source) {
        var matchData = getMatchData2(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable2(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch2(object, source, matchData);
        };
      }
      _baseMatches = baseMatches2;
      return _baseMatches;
    }
    var isSymbol_1;
    var hasRequiredIsSymbol;
    function requireIsSymbol() {
      if (hasRequiredIsSymbol) return isSymbol_1;
      hasRequiredIsSymbol = 1;
      var baseGetTag2 = require_baseGetTag(), isObjectLike2 = requireIsObjectLike();
      var symbolTag2 = "[object Symbol]";
      function isSymbol2(value2) {
        return typeof value2 == "symbol" || isObjectLike2(value2) && baseGetTag2(value2) == symbolTag2;
      }
      isSymbol_1 = isSymbol2;
      return isSymbol_1;
    }
    var _isKey;
    var hasRequired_isKey;
    function require_isKey() {
      if (hasRequired_isKey) return _isKey;
      hasRequired_isKey = 1;
      var isArray2 = requireIsArray(), isSymbol2 = requireIsSymbol();
      var reIsDeepProp2 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp2 = /^\w*$/;
      function isKey2(value2, object) {
        if (isArray2(value2)) {
          return false;
        }
        var type = typeof value2;
        if (type == "number" || type == "symbol" || type == "boolean" || value2 == null || isSymbol2(value2)) {
          return true;
        }
        return reIsPlainProp2.test(value2) || !reIsDeepProp2.test(value2) || object != null && value2 in Object(object);
      }
      _isKey = isKey2;
      return _isKey;
    }
    var memoize_1;
    var hasRequiredMemoize;
    function requireMemoize() {
      if (hasRequiredMemoize) return memoize_1;
      hasRequiredMemoize = 1;
      var MapCache2 = require_MapCache();
      var FUNC_ERROR_TEXT2 = "Expected a function";
      function memoize2(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError(FUNC_ERROR_TEXT2);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result = func.apply(this, args);
          memoized.cache = cache.set(key, result) || cache;
          return result;
        };
        memoized.cache = new (memoize2.Cache || MapCache2)();
        return memoized;
      }
      memoize2.Cache = MapCache2;
      memoize_1 = memoize2;
      return memoize_1;
    }
    var _memoizeCapped;
    var hasRequired_memoizeCapped;
    function require_memoizeCapped() {
      if (hasRequired_memoizeCapped) return _memoizeCapped;
      hasRequired_memoizeCapped = 1;
      var memoize2 = requireMemoize();
      var MAX_MEMOIZE_SIZE2 = 500;
      function memoizeCapped2(func) {
        var result = memoize2(func, function(key) {
          if (cache.size === MAX_MEMOIZE_SIZE2) {
            cache.clear();
          }
          return key;
        });
        var cache = result.cache;
        return result;
      }
      _memoizeCapped = memoizeCapped2;
      return _memoizeCapped;
    }
    var _stringToPath;
    var hasRequired_stringToPath;
    function require_stringToPath() {
      if (hasRequired_stringToPath) return _stringToPath;
      hasRequired_stringToPath = 1;
      var memoizeCapped2 = require_memoizeCapped();
      var rePropName2 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reEscapeChar2 = /\\(\\)?/g;
      var stringToPath2 = memoizeCapped2(function(string) {
        var result = [];
        if (string.charCodeAt(0) === 46) {
          result.push("");
        }
        string.replace(rePropName2, function(match2, number, quote, subString) {
          result.push(quote ? subString.replace(reEscapeChar2, "$1") : number || match2);
        });
        return result;
      });
      _stringToPath = stringToPath2;
      return _stringToPath;
    }
    var _baseToString;
    var hasRequired_baseToString;
    function require_baseToString() {
      if (hasRequired_baseToString) return _baseToString;
      hasRequired_baseToString = 1;
      var Symbol2 = require_Symbol(), arrayMap2 = require_arrayMap(), isArray2 = requireIsArray(), isSymbol2 = requireIsSymbol();
      var INFINITY2 = 1 / 0;
      var symbolProto2 = Symbol2 ? Symbol2.prototype : void 0, symbolToString2 = symbolProto2 ? symbolProto2.toString : void 0;
      function baseToString2(value2) {
        if (typeof value2 == "string") {
          return value2;
        }
        if (isArray2(value2)) {
          return arrayMap2(value2, baseToString2) + "";
        }
        if (isSymbol2(value2)) {
          return symbolToString2 ? symbolToString2.call(value2) : "";
        }
        var result = value2 + "";
        return result == "0" && 1 / value2 == -INFINITY2 ? "-0" : result;
      }
      _baseToString = baseToString2;
      return _baseToString;
    }
    var toString_1;
    var hasRequiredToString;
    function requireToString() {
      if (hasRequiredToString) return toString_1;
      hasRequiredToString = 1;
      var baseToString2 = require_baseToString();
      function toString2(value2) {
        return value2 == null ? "" : baseToString2(value2);
      }
      toString_1 = toString2;
      return toString_1;
    }
    var _castPath;
    var hasRequired_castPath;
    function require_castPath() {
      if (hasRequired_castPath) return _castPath;
      hasRequired_castPath = 1;
      var isArray2 = requireIsArray(), isKey2 = require_isKey(), stringToPath2 = require_stringToPath(), toString2 = requireToString();
      function castPath2(value2, object) {
        if (isArray2(value2)) {
          return value2;
        }
        return isKey2(value2, object) ? [value2] : stringToPath2(toString2(value2));
      }
      _castPath = castPath2;
      return _castPath;
    }
    var _toKey;
    var hasRequired_toKey;
    function require_toKey() {
      if (hasRequired_toKey) return _toKey;
      hasRequired_toKey = 1;
      var isSymbol2 = requireIsSymbol();
      var INFINITY2 = 1 / 0;
      function toKey2(value2) {
        if (typeof value2 == "string" || isSymbol2(value2)) {
          return value2;
        }
        var result = value2 + "";
        return result == "0" && 1 / value2 == -INFINITY2 ? "-0" : result;
      }
      _toKey = toKey2;
      return _toKey;
    }
    var _baseGet;
    var hasRequired_baseGet;
    function require_baseGet() {
      if (hasRequired_baseGet) return _baseGet;
      hasRequired_baseGet = 1;
      var castPath2 = require_castPath(), toKey2 = require_toKey();
      function baseGet2(object, path) {
        path = castPath2(path, object);
        var index = 0, length = path.length;
        while (object != null && index < length) {
          object = object[toKey2(path[index++])];
        }
        return index && index == length ? object : void 0;
      }
      _baseGet = baseGet2;
      return _baseGet;
    }
    var get_1;
    var hasRequiredGet;
    function requireGet() {
      if (hasRequiredGet) return get_1;
      hasRequiredGet = 1;
      var baseGet2 = require_baseGet();
      function get2(object, path, defaultValue2) {
        var result = object == null ? void 0 : baseGet2(object, path);
        return result === void 0 ? defaultValue2 : result;
      }
      get_1 = get2;
      return get_1;
    }
    var _baseHasIn;
    var hasRequired_baseHasIn;
    function require_baseHasIn() {
      if (hasRequired_baseHasIn) return _baseHasIn;
      hasRequired_baseHasIn = 1;
      function baseHasIn2(object, key) {
        return object != null && key in Object(object);
      }
      _baseHasIn = baseHasIn2;
      return _baseHasIn;
    }
    var _hasPath;
    var hasRequired_hasPath;
    function require_hasPath() {
      if (hasRequired_hasPath) return _hasPath;
      hasRequired_hasPath = 1;
      var castPath2 = require_castPath(), isArguments2 = requireIsArguments(), isArray2 = requireIsArray(), isIndex2 = require_isIndex(), isLength2 = requireIsLength(), toKey2 = require_toKey();
      function hasPath2(object, path, hasFunc) {
        path = castPath2(path, object);
        var index = -1, length = path.length, result = false;
        while (++index < length) {
          var key = toKey2(path[index]);
          if (!(result = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result || ++index != length) {
          return result;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength2(length) && isIndex2(key, length) && (isArray2(object) || isArguments2(object));
      }
      _hasPath = hasPath2;
      return _hasPath;
    }
    var hasIn_1;
    var hasRequiredHasIn;
    function requireHasIn() {
      if (hasRequiredHasIn) return hasIn_1;
      hasRequiredHasIn = 1;
      var baseHasIn2 = require_baseHasIn(), hasPath2 = require_hasPath();
      function hasIn2(object, path) {
        return object != null && hasPath2(object, path, baseHasIn2);
      }
      hasIn_1 = hasIn2;
      return hasIn_1;
    }
    var _baseMatchesProperty;
    var hasRequired_baseMatchesProperty;
    function require_baseMatchesProperty() {
      if (hasRequired_baseMatchesProperty) return _baseMatchesProperty;
      hasRequired_baseMatchesProperty = 1;
      var baseIsEqual2 = require_baseIsEqual(), get2 = requireGet(), hasIn2 = requireHasIn(), isKey2 = require_isKey(), isStrictComparable2 = require_isStrictComparable(), matchesStrictComparable2 = require_matchesStrictComparable(), toKey2 = require_toKey();
      var COMPARE_PARTIAL_FLAG2 = 1, COMPARE_UNORDERED_FLAG2 = 2;
      function baseMatchesProperty2(path, srcValue) {
        if (isKey2(path) && isStrictComparable2(srcValue)) {
          return matchesStrictComparable2(toKey2(path), srcValue);
        }
        return function(object) {
          var objValue = get2(object, path);
          return objValue === void 0 && objValue === srcValue ? hasIn2(object, path) : baseIsEqual2(srcValue, objValue, COMPARE_PARTIAL_FLAG2 | COMPARE_UNORDERED_FLAG2);
        };
      }
      _baseMatchesProperty = baseMatchesProperty2;
      return _baseMatchesProperty;
    }
    var _baseProperty;
    var hasRequired_baseProperty;
    function require_baseProperty() {
      if (hasRequired_baseProperty) return _baseProperty;
      hasRequired_baseProperty = 1;
      function baseProperty2(key) {
        return function(object) {
          return object == null ? void 0 : object[key];
        };
      }
      _baseProperty = baseProperty2;
      return _baseProperty;
    }
    var _basePropertyDeep;
    var hasRequired_basePropertyDeep;
    function require_basePropertyDeep() {
      if (hasRequired_basePropertyDeep) return _basePropertyDeep;
      hasRequired_basePropertyDeep = 1;
      var baseGet2 = require_baseGet();
      function basePropertyDeep2(path) {
        return function(object) {
          return baseGet2(object, path);
        };
      }
      _basePropertyDeep = basePropertyDeep2;
      return _basePropertyDeep;
    }
    var property_1;
    var hasRequiredProperty;
    function requireProperty() {
      if (hasRequiredProperty) return property_1;
      hasRequiredProperty = 1;
      var baseProperty2 = require_baseProperty(), basePropertyDeep2 = require_basePropertyDeep(), isKey2 = require_isKey(), toKey2 = require_toKey();
      function property2(path) {
        return isKey2(path) ? baseProperty2(toKey2(path)) : basePropertyDeep2(path);
      }
      property_1 = property2;
      return property_1;
    }
    var _baseIteratee;
    var hasRequired_baseIteratee;
    function require_baseIteratee() {
      if (hasRequired_baseIteratee) return _baseIteratee;
      hasRequired_baseIteratee = 1;
      var baseMatches2 = require_baseMatches(), baseMatchesProperty2 = require_baseMatchesProperty(), identity2 = requireIdentity(), isArray2 = requireIsArray(), property2 = requireProperty();
      function baseIteratee2(value2) {
        if (typeof value2 == "function") {
          return value2;
        }
        if (value2 == null) {
          return identity2;
        }
        if (typeof value2 == "object") {
          return isArray2(value2) ? baseMatchesProperty2(value2[0], value2[1]) : baseMatches2(value2);
        }
        return property2(value2);
      }
      _baseIteratee = baseIteratee2;
      return _baseIteratee;
    }
    var _createBaseEach;
    var hasRequired_createBaseEach;
    function require_createBaseEach() {
      if (hasRequired_createBaseEach) return _createBaseEach;
      hasRequired_createBaseEach = 1;
      var isArrayLike2 = requireIsArrayLike();
      function createBaseEach2(eachFunc, fromRight) {
        return function(collection, iteratee) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike2(collection)) {
            return eachFunc(collection, iteratee);
          }
          var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
          while (fromRight ? index-- : ++index < length) {
            if (iteratee(iterable[index], index, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      _createBaseEach = createBaseEach2;
      return _createBaseEach;
    }
    var _baseEach;
    var hasRequired_baseEach;
    function require_baseEach() {
      if (hasRequired_baseEach) return _baseEach;
      hasRequired_baseEach = 1;
      var baseForOwn2 = require_baseForOwn(), createBaseEach2 = require_createBaseEach();
      var baseEach2 = createBaseEach2(baseForOwn2);
      _baseEach = baseEach2;
      return _baseEach;
    }
    var _baseMap;
    var hasRequired_baseMap;
    function require_baseMap() {
      if (hasRequired_baseMap) return _baseMap;
      hasRequired_baseMap = 1;
      var baseEach2 = require_baseEach(), isArrayLike2 = requireIsArrayLike();
      function baseMap2(collection, iteratee) {
        var index = -1, result = isArrayLike2(collection) ? Array(collection.length) : [];
        baseEach2(collection, function(value2, key, collection2) {
          result[++index] = iteratee(value2, key, collection2);
        });
        return result;
      }
      _baseMap = baseMap2;
      return _baseMap;
    }
    var map_1;
    var hasRequiredMap;
    function requireMap() {
      if (hasRequiredMap) return map_1;
      hasRequiredMap = 1;
      var arrayMap2 = require_arrayMap(), baseIteratee2 = require_baseIteratee(), baseMap2 = require_baseMap(), isArray2 = requireIsArray();
      function map2(collection, iteratee) {
        var func = isArray2(collection) ? arrayMap2 : baseMap2;
        return func(collection, baseIteratee2(iteratee, 3));
      }
      map_1 = map2;
      return map_1;
    }
    var hasRequiredFlattenNames;
    function requireFlattenNames() {
      if (hasRequiredFlattenNames) return flattenNames;
      hasRequiredFlattenNames = 1;
      Object.defineProperty(flattenNames, "__esModule", {
        value: true
      });
      flattenNames.flattenNames = void 0;
      var _isString2 = requireIsString();
      var _isString3 = _interopRequireDefault(_isString2);
      var _forOwn2 = requireForOwn();
      var _forOwn3 = _interopRequireDefault(_forOwn2);
      var _isPlainObject2 = requireIsPlainObject();
      var _isPlainObject3 = _interopRequireDefault(_isPlainObject2);
      var _map2 = requireMap();
      var _map3 = _interopRequireDefault(_map2);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var flattenNames$1 = flattenNames.flattenNames = function flattenNames2() {
        var things = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        var names2 = [];
        (0, _map3.default)(things, function(thing) {
          if (Array.isArray(thing)) {
            flattenNames2(thing).map(function(name2) {
              return names2.push(name2);
            });
          } else if ((0, _isPlainObject3.default)(thing)) {
            (0, _forOwn3.default)(thing, function(value2, key) {
              value2 === true && names2.push(key);
              names2.push(key + "-" + value2);
            });
          } else if ((0, _isString3.default)(thing)) {
            names2.push(thing);
          }
        });
        return names2;
      };
      flattenNames.default = flattenNames$1;
      return flattenNames;
    }
    var mergeClasses = {};
    var _arrayEach;
    var hasRequired_arrayEach;
    function require_arrayEach() {
      if (hasRequired_arrayEach) return _arrayEach;
      hasRequired_arrayEach = 1;
      function arrayEach2(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      _arrayEach = arrayEach2;
      return _arrayEach;
    }
    var _defineProperty$1;
    var hasRequired_defineProperty;
    function require_defineProperty() {
      if (hasRequired_defineProperty) return _defineProperty$1;
      hasRequired_defineProperty = 1;
      var getNative2 = require_getNative();
      var defineProperty2 = function() {
        try {
          var func = getNative2(Object, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }();
      _defineProperty$1 = defineProperty2;
      return _defineProperty$1;
    }
    var _baseAssignValue;
    var hasRequired_baseAssignValue;
    function require_baseAssignValue() {
      if (hasRequired_baseAssignValue) return _baseAssignValue;
      hasRequired_baseAssignValue = 1;
      var defineProperty2 = require_defineProperty();
      function baseAssignValue2(object, key, value2) {
        if (key == "__proto__" && defineProperty2) {
          defineProperty2(object, key, {
            "configurable": true,
            "enumerable": true,
            "value": value2,
            "writable": true
          });
        } else {
          object[key] = value2;
        }
      }
      _baseAssignValue = baseAssignValue2;
      return _baseAssignValue;
    }
    var _assignValue;
    var hasRequired_assignValue;
    function require_assignValue() {
      if (hasRequired_assignValue) return _assignValue;
      hasRequired_assignValue = 1;
      var baseAssignValue2 = require_baseAssignValue(), eq2 = requireEq();
      var objectProto2 = Object.prototype;
      var hasOwnProperty2 = objectProto2.hasOwnProperty;
      function assignValue2(object, key, value2) {
        var objValue = object[key];
        if (!(hasOwnProperty2.call(object, key) && eq2(objValue, value2)) || value2 === void 0 && !(key in object)) {
          baseAssignValue2(object, key, value2);
        }
      }
      _assignValue = assignValue2;
      return _assignValue;
    }
    var _copyObject;
    var hasRequired_copyObject;
    function require_copyObject() {
      if (hasRequired_copyObject) return _copyObject;
      hasRequired_copyObject = 1;
      var assignValue2 = require_assignValue(), baseAssignValue2 = require_baseAssignValue();
      function copyObject2(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index = -1, length = props.length;
        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
          if (newValue === void 0) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue2(object, key, newValue);
          } else {
            assignValue2(object, key, newValue);
          }
        }
        return object;
      }
      _copyObject = copyObject2;
      return _copyObject;
    }
    var _baseAssign;
    var hasRequired_baseAssign;
    function require_baseAssign() {
      if (hasRequired_baseAssign) return _baseAssign;
      hasRequired_baseAssign = 1;
      var copyObject2 = require_copyObject(), keys2 = requireKeys();
      function baseAssign2(object, source) {
        return object && copyObject2(source, keys2(source), object);
      }
      _baseAssign = baseAssign2;
      return _baseAssign;
    }
    var _nativeKeysIn;
    var hasRequired_nativeKeysIn;
    function require_nativeKeysIn() {
      if (hasRequired_nativeKeysIn) return _nativeKeysIn;
      hasRequired_nativeKeysIn = 1;
      function nativeKeysIn2(object) {
        var result = [];
        if (object != null) {
          for (var key in Object(object)) {
            result.push(key);
          }
        }
        return result;
      }
      _nativeKeysIn = nativeKeysIn2;
      return _nativeKeysIn;
    }
    var _baseKeysIn;
    var hasRequired_baseKeysIn;
    function require_baseKeysIn() {
      if (hasRequired_baseKeysIn) return _baseKeysIn;
      hasRequired_baseKeysIn = 1;
      var isObject2 = requireIsObject(), isPrototype2 = require_isPrototype(), nativeKeysIn2 = require_nativeKeysIn();
      var objectProto2 = Object.prototype;
      var hasOwnProperty2 = objectProto2.hasOwnProperty;
      function baseKeysIn2(object) {
        if (!isObject2(object)) {
          return nativeKeysIn2(object);
        }
        var isProto = isPrototype2(object), result = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
            result.push(key);
          }
        }
        return result;
      }
      _baseKeysIn = baseKeysIn2;
      return _baseKeysIn;
    }
    var keysIn_1;
    var hasRequiredKeysIn;
    function requireKeysIn() {
      if (hasRequiredKeysIn) return keysIn_1;
      hasRequiredKeysIn = 1;
      var arrayLikeKeys2 = require_arrayLikeKeys(), baseKeysIn2 = require_baseKeysIn(), isArrayLike2 = requireIsArrayLike();
      function keysIn2(object) {
        return isArrayLike2(object) ? arrayLikeKeys2(object, true) : baseKeysIn2(object);
      }
      keysIn_1 = keysIn2;
      return keysIn_1;
    }
    var _baseAssignIn;
    var hasRequired_baseAssignIn;
    function require_baseAssignIn() {
      if (hasRequired_baseAssignIn) return _baseAssignIn;
      hasRequired_baseAssignIn = 1;
      var copyObject2 = require_copyObject(), keysIn2 = requireKeysIn();
      function baseAssignIn2(object, source) {
        return object && copyObject2(source, keysIn2(source), object);
      }
      _baseAssignIn = baseAssignIn2;
      return _baseAssignIn;
    }
    var _cloneBuffer = { exports: {} };
    _cloneBuffer.exports;
    var hasRequired_cloneBuffer;
    function require_cloneBuffer() {
      if (hasRequired_cloneBuffer) return _cloneBuffer.exports;
      hasRequired_cloneBuffer = 1;
      (function(module2, exports2) {
        var root2 = require_root();
        var freeExports2 = exports2 && !exports2.nodeType && exports2;
        var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
        var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
        var Buffer3 = moduleExports2 ? root2.Buffer : void 0, allocUnsafe2 = Buffer3 ? Buffer3.allocUnsafe : void 0;
        function cloneBuffer2(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result = allocUnsafe2 ? allocUnsafe2(length) : new buffer.constructor(length);
          buffer.copy(result);
          return result;
        }
        module2.exports = cloneBuffer2;
      })(_cloneBuffer, _cloneBuffer.exports);
      return _cloneBuffer.exports;
    }
    var _copyArray;
    var hasRequired_copyArray;
    function require_copyArray() {
      if (hasRequired_copyArray) return _copyArray;
      hasRequired_copyArray = 1;
      function copyArray2(source, array) {
        var index = -1, length = source.length;
        array || (array = Array(length));
        while (++index < length) {
          array[index] = source[index];
        }
        return array;
      }
      _copyArray = copyArray2;
      return _copyArray;
    }
    var _copySymbols;
    var hasRequired_copySymbols;
    function require_copySymbols() {
      if (hasRequired_copySymbols) return _copySymbols;
      hasRequired_copySymbols = 1;
      var copyObject2 = require_copyObject(), getSymbols2 = require_getSymbols();
      function copySymbols2(source, object) {
        return copyObject2(source, getSymbols2(source), object);
      }
      _copySymbols = copySymbols2;
      return _copySymbols;
    }
    var _getSymbolsIn;
    var hasRequired_getSymbolsIn;
    function require_getSymbolsIn() {
      if (hasRequired_getSymbolsIn) return _getSymbolsIn;
      hasRequired_getSymbolsIn = 1;
      var arrayPush2 = require_arrayPush(), getPrototype2 = require_getPrototype(), getSymbols2 = require_getSymbols(), stubArray2 = requireStubArray();
      var nativeGetSymbols2 = Object.getOwnPropertySymbols;
      var getSymbolsIn2 = !nativeGetSymbols2 ? stubArray2 : function(object) {
        var result = [];
        while (object) {
          arrayPush2(result, getSymbols2(object));
          object = getPrototype2(object);
        }
        return result;
      };
      _getSymbolsIn = getSymbolsIn2;
      return _getSymbolsIn;
    }
    var _copySymbolsIn;
    var hasRequired_copySymbolsIn;
    function require_copySymbolsIn() {
      if (hasRequired_copySymbolsIn) return _copySymbolsIn;
      hasRequired_copySymbolsIn = 1;
      var copyObject2 = require_copyObject(), getSymbolsIn2 = require_getSymbolsIn();
      function copySymbolsIn2(source, object) {
        return copyObject2(source, getSymbolsIn2(source), object);
      }
      _copySymbolsIn = copySymbolsIn2;
      return _copySymbolsIn;
    }
    var _getAllKeysIn;
    var hasRequired_getAllKeysIn;
    function require_getAllKeysIn() {
      if (hasRequired_getAllKeysIn) return _getAllKeysIn;
      hasRequired_getAllKeysIn = 1;
      var baseGetAllKeys2 = require_baseGetAllKeys(), getSymbolsIn2 = require_getSymbolsIn(), keysIn2 = requireKeysIn();
      function getAllKeysIn2(object) {
        return baseGetAllKeys2(object, keysIn2, getSymbolsIn2);
      }
      _getAllKeysIn = getAllKeysIn2;
      return _getAllKeysIn;
    }
    var _initCloneArray;
    var hasRequired_initCloneArray;
    function require_initCloneArray() {
      if (hasRequired_initCloneArray) return _initCloneArray;
      hasRequired_initCloneArray = 1;
      var objectProto2 = Object.prototype;
      var hasOwnProperty2 = objectProto2.hasOwnProperty;
      function initCloneArray2(array) {
        var length = array.length, result = new array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
          result.index = array.index;
          result.input = array.input;
        }
        return result;
      }
      _initCloneArray = initCloneArray2;
      return _initCloneArray;
    }
    var _cloneArrayBuffer;
    var hasRequired_cloneArrayBuffer;
    function require_cloneArrayBuffer() {
      if (hasRequired_cloneArrayBuffer) return _cloneArrayBuffer;
      hasRequired_cloneArrayBuffer = 1;
      var Uint8Array3 = require_Uint8Array();
      function cloneArrayBuffer2(arrayBuffer) {
        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array3(result).set(new Uint8Array3(arrayBuffer));
        return result;
      }
      _cloneArrayBuffer = cloneArrayBuffer2;
      return _cloneArrayBuffer;
    }
    var _cloneDataView;
    var hasRequired_cloneDataView;
    function require_cloneDataView() {
      if (hasRequired_cloneDataView) return _cloneDataView;
      hasRequired_cloneDataView = 1;
      var cloneArrayBuffer2 = require_cloneArrayBuffer();
      function cloneDataView2(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer2(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      _cloneDataView = cloneDataView2;
      return _cloneDataView;
    }
    var _cloneRegExp;
    var hasRequired_cloneRegExp;
    function require_cloneRegExp() {
      if (hasRequired_cloneRegExp) return _cloneRegExp;
      hasRequired_cloneRegExp = 1;
      var reFlags2 = /\w*$/;
      function cloneRegExp2(regexp) {
        var result = new regexp.constructor(regexp.source, reFlags2.exec(regexp));
        result.lastIndex = regexp.lastIndex;
        return result;
      }
      _cloneRegExp = cloneRegExp2;
      return _cloneRegExp;
    }
    var _cloneSymbol;
    var hasRequired_cloneSymbol;
    function require_cloneSymbol() {
      if (hasRequired_cloneSymbol) return _cloneSymbol;
      hasRequired_cloneSymbol = 1;
      var Symbol2 = require_Symbol();
      var symbolProto2 = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf2 = symbolProto2 ? symbolProto2.valueOf : void 0;
      function cloneSymbol2(symbol) {
        return symbolValueOf2 ? Object(symbolValueOf2.call(symbol)) : {};
      }
      _cloneSymbol = cloneSymbol2;
      return _cloneSymbol;
    }
    var _cloneTypedArray;
    var hasRequired_cloneTypedArray;
    function require_cloneTypedArray() {
      if (hasRequired_cloneTypedArray) return _cloneTypedArray;
      hasRequired_cloneTypedArray = 1;
      var cloneArrayBuffer2 = require_cloneArrayBuffer();
      function cloneTypedArray2(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer2(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      _cloneTypedArray = cloneTypedArray2;
      return _cloneTypedArray;
    }
    var _initCloneByTag;
    var hasRequired_initCloneByTag;
    function require_initCloneByTag() {
      if (hasRequired_initCloneByTag) return _initCloneByTag;
      hasRequired_initCloneByTag = 1;
      var cloneArrayBuffer2 = require_cloneArrayBuffer(), cloneDataView2 = require_cloneDataView(), cloneRegExp2 = require_cloneRegExp(), cloneSymbol2 = require_cloneSymbol(), cloneTypedArray2 = require_cloneTypedArray();
      var boolTag2 = "[object Boolean]", dateTag2 = "[object Date]", mapTag2 = "[object Map]", numberTag2 = "[object Number]", regexpTag2 = "[object RegExp]", setTag2 = "[object Set]", stringTag2 = "[object String]", symbolTag2 = "[object Symbol]";
      var arrayBufferTag2 = "[object ArrayBuffer]", dataViewTag2 = "[object DataView]", float32Tag2 = "[object Float32Array]", float64Tag2 = "[object Float64Array]", int8Tag2 = "[object Int8Array]", int16Tag2 = "[object Int16Array]", int32Tag2 = "[object Int32Array]", uint8Tag2 = "[object Uint8Array]", uint8ClampedTag2 = "[object Uint8ClampedArray]", uint16Tag2 = "[object Uint16Array]", uint32Tag2 = "[object Uint32Array]";
      function initCloneByTag2(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag2:
            return cloneArrayBuffer2(object);
          case boolTag2:
          case dateTag2:
            return new Ctor(+object);
          case dataViewTag2:
            return cloneDataView2(object, isDeep);
          case float32Tag2:
          case float64Tag2:
          case int8Tag2:
          case int16Tag2:
          case int32Tag2:
          case uint8Tag2:
          case uint8ClampedTag2:
          case uint16Tag2:
          case uint32Tag2:
            return cloneTypedArray2(object, isDeep);
          case mapTag2:
            return new Ctor();
          case numberTag2:
          case stringTag2:
            return new Ctor(object);
          case regexpTag2:
            return cloneRegExp2(object);
          case setTag2:
            return new Ctor();
          case symbolTag2:
            return cloneSymbol2(object);
        }
      }
      _initCloneByTag = initCloneByTag2;
      return _initCloneByTag;
    }
    var _baseCreate;
    var hasRequired_baseCreate;
    function require_baseCreate() {
      if (hasRequired_baseCreate) return _baseCreate;
      hasRequired_baseCreate = 1;
      var isObject2 = requireIsObject();
      var objectCreate2 = Object.create;
      var baseCreate2 = /* @__PURE__ */ function() {
        function object() {
        }
        return function(proto) {
          if (!isObject2(proto)) {
            return {};
          }
          if (objectCreate2) {
            return objectCreate2(proto);
          }
          object.prototype = proto;
          var result = new object();
          object.prototype = void 0;
          return result;
        };
      }();
      _baseCreate = baseCreate2;
      return _baseCreate;
    }
    var _initCloneObject;
    var hasRequired_initCloneObject;
    function require_initCloneObject() {
      if (hasRequired_initCloneObject) return _initCloneObject;
      hasRequired_initCloneObject = 1;
      var baseCreate2 = require_baseCreate(), getPrototype2 = require_getPrototype(), isPrototype2 = require_isPrototype();
      function initCloneObject2(object) {
        return typeof object.constructor == "function" && !isPrototype2(object) ? baseCreate2(getPrototype2(object)) : {};
      }
      _initCloneObject = initCloneObject2;
      return _initCloneObject;
    }
    var _baseIsMap;
    var hasRequired_baseIsMap;
    function require_baseIsMap() {
      if (hasRequired_baseIsMap) return _baseIsMap;
      hasRequired_baseIsMap = 1;
      var getTag2 = require_getTag(), isObjectLike2 = requireIsObjectLike();
      var mapTag2 = "[object Map]";
      function baseIsMap2(value2) {
        return isObjectLike2(value2) && getTag2(value2) == mapTag2;
      }
      _baseIsMap = baseIsMap2;
      return _baseIsMap;
    }
    var isMap_1;
    var hasRequiredIsMap;
    function requireIsMap() {
      if (hasRequiredIsMap) return isMap_1;
      hasRequiredIsMap = 1;
      var baseIsMap2 = require_baseIsMap(), baseUnary2 = require_baseUnary(), nodeUtil2 = require_nodeUtil();
      var nodeIsMap2 = nodeUtil2 && nodeUtil2.isMap;
      var isMap2 = nodeIsMap2 ? baseUnary2(nodeIsMap2) : baseIsMap2;
      isMap_1 = isMap2;
      return isMap_1;
    }
    var _baseIsSet;
    var hasRequired_baseIsSet;
    function require_baseIsSet() {
      if (hasRequired_baseIsSet) return _baseIsSet;
      hasRequired_baseIsSet = 1;
      var getTag2 = require_getTag(), isObjectLike2 = requireIsObjectLike();
      var setTag2 = "[object Set]";
      function baseIsSet2(value2) {
        return isObjectLike2(value2) && getTag2(value2) == setTag2;
      }
      _baseIsSet = baseIsSet2;
      return _baseIsSet;
    }
    var isSet_1;
    var hasRequiredIsSet;
    function requireIsSet() {
      if (hasRequiredIsSet) return isSet_1;
      hasRequiredIsSet = 1;
      var baseIsSet2 = require_baseIsSet(), baseUnary2 = require_baseUnary(), nodeUtil2 = require_nodeUtil();
      var nodeIsSet2 = nodeUtil2 && nodeUtil2.isSet;
      var isSet2 = nodeIsSet2 ? baseUnary2(nodeIsSet2) : baseIsSet2;
      isSet_1 = isSet2;
      return isSet_1;
    }
    var _baseClone;
    var hasRequired_baseClone;
    function require_baseClone() {
      if (hasRequired_baseClone) return _baseClone;
      hasRequired_baseClone = 1;
      var Stack2 = require_Stack(), arrayEach2 = require_arrayEach(), assignValue2 = require_assignValue(), baseAssign2 = require_baseAssign(), baseAssignIn2 = require_baseAssignIn(), cloneBuffer2 = require_cloneBuffer(), copyArray2 = require_copyArray(), copySymbols2 = require_copySymbols(), copySymbolsIn2 = require_copySymbolsIn(), getAllKeys2 = require_getAllKeys(), getAllKeysIn2 = require_getAllKeysIn(), getTag2 = require_getTag(), initCloneArray2 = require_initCloneArray(), initCloneByTag2 = require_initCloneByTag(), initCloneObject2 = require_initCloneObject(), isArray2 = requireIsArray(), isBuffer2 = requireIsBuffer(), isMap2 = requireIsMap(), isObject2 = requireIsObject(), isSet2 = requireIsSet(), keys2 = requireKeys(), keysIn2 = requireKeysIn();
      var CLONE_DEEP_FLAG2 = 1, CLONE_FLAT_FLAG2 = 2, CLONE_SYMBOLS_FLAG2 = 4;
      var argsTag2 = "[object Arguments]", arrayTag2 = "[object Array]", boolTag2 = "[object Boolean]", dateTag2 = "[object Date]", errorTag2 = "[object Error]", funcTag2 = "[object Function]", genTag2 = "[object GeneratorFunction]", mapTag2 = "[object Map]", numberTag2 = "[object Number]", objectTag2 = "[object Object]", regexpTag2 = "[object RegExp]", setTag2 = "[object Set]", stringTag2 = "[object String]", symbolTag2 = "[object Symbol]", weakMapTag2 = "[object WeakMap]";
      var arrayBufferTag2 = "[object ArrayBuffer]", dataViewTag2 = "[object DataView]", float32Tag2 = "[object Float32Array]", float64Tag2 = "[object Float64Array]", int8Tag2 = "[object Int8Array]", int16Tag2 = "[object Int16Array]", int32Tag2 = "[object Int32Array]", uint8Tag2 = "[object Uint8Array]", uint8ClampedTag2 = "[object Uint8ClampedArray]", uint16Tag2 = "[object Uint16Array]", uint32Tag2 = "[object Uint32Array]";
      var cloneableTags2 = {};
      cloneableTags2[argsTag2] = cloneableTags2[arrayTag2] = cloneableTags2[arrayBufferTag2] = cloneableTags2[dataViewTag2] = cloneableTags2[boolTag2] = cloneableTags2[dateTag2] = cloneableTags2[float32Tag2] = cloneableTags2[float64Tag2] = cloneableTags2[int8Tag2] = cloneableTags2[int16Tag2] = cloneableTags2[int32Tag2] = cloneableTags2[mapTag2] = cloneableTags2[numberTag2] = cloneableTags2[objectTag2] = cloneableTags2[regexpTag2] = cloneableTags2[setTag2] = cloneableTags2[stringTag2] = cloneableTags2[symbolTag2] = cloneableTags2[uint8Tag2] = cloneableTags2[uint8ClampedTag2] = cloneableTags2[uint16Tag2] = cloneableTags2[uint32Tag2] = true;
      cloneableTags2[errorTag2] = cloneableTags2[funcTag2] = cloneableTags2[weakMapTag2] = false;
      function baseClone2(value2, bitmask, customizer, key, object, stack) {
        var result, isDeep = bitmask & CLONE_DEEP_FLAG2, isFlat = bitmask & CLONE_FLAT_FLAG2, isFull = bitmask & CLONE_SYMBOLS_FLAG2;
        if (customizer) {
          result = object ? customizer(value2, key, object, stack) : customizer(value2);
        }
        if (result !== void 0) {
          return result;
        }
        if (!isObject2(value2)) {
          return value2;
        }
        var isArr = isArray2(value2);
        if (isArr) {
          result = initCloneArray2(value2);
          if (!isDeep) {
            return copyArray2(value2, result);
          }
        } else {
          var tag = getTag2(value2), isFunc = tag == funcTag2 || tag == genTag2;
          if (isBuffer2(value2)) {
            return cloneBuffer2(value2, isDeep);
          }
          if (tag == objectTag2 || tag == argsTag2 || isFunc && !object) {
            result = isFlat || isFunc ? {} : initCloneObject2(value2);
            if (!isDeep) {
              return isFlat ? copySymbolsIn2(value2, baseAssignIn2(result, value2)) : copySymbols2(value2, baseAssign2(result, value2));
            }
          } else {
            if (!cloneableTags2[tag]) {
              return object ? value2 : {};
            }
            result = initCloneByTag2(value2, tag, isDeep);
          }
        }
        stack || (stack = new Stack2());
        var stacked = stack.get(value2);
        if (stacked) {
          return stacked;
        }
        stack.set(value2, result);
        if (isSet2(value2)) {
          value2.forEach(function(subValue) {
            result.add(baseClone2(subValue, bitmask, customizer, subValue, value2, stack));
          });
        } else if (isMap2(value2)) {
          value2.forEach(function(subValue, key2) {
            result.set(key2, baseClone2(subValue, bitmask, customizer, key2, value2, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn2 : getAllKeys2 : isFlat ? keysIn2 : keys2;
        var props = isArr ? void 0 : keysFunc(value2);
        arrayEach2(props || value2, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value2[key2];
          }
          assignValue2(result, key2, baseClone2(subValue, bitmask, customizer, key2, value2, stack));
        });
        return result;
      }
      _baseClone = baseClone2;
      return _baseClone;
    }
    var cloneDeep_1;
    var hasRequiredCloneDeep;
    function requireCloneDeep() {
      if (hasRequiredCloneDeep) return cloneDeep_1;
      hasRequiredCloneDeep = 1;
      var baseClone2 = require_baseClone();
      var CLONE_DEEP_FLAG2 = 1, CLONE_SYMBOLS_FLAG2 = 4;
      function cloneDeep2(value2) {
        return baseClone2(value2, CLONE_DEEP_FLAG2 | CLONE_SYMBOLS_FLAG2);
      }
      cloneDeep_1 = cloneDeep2;
      return cloneDeep_1;
    }
    var hasRequiredMergeClasses;
    function requireMergeClasses() {
      if (hasRequiredMergeClasses) return mergeClasses;
      hasRequiredMergeClasses = 1;
      Object.defineProperty(mergeClasses, "__esModule", {
        value: true
      });
      mergeClasses.mergeClasses = void 0;
      var _forOwn2 = requireForOwn();
      var _forOwn3 = _interopRequireDefault(_forOwn2);
      var _cloneDeep2 = requireCloneDeep();
      var _cloneDeep3 = _interopRequireDefault(_cloneDeep2);
      var _extends2 = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var mergeClasses$1 = mergeClasses.mergeClasses = function mergeClasses2(classes) {
        var activeNames = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
        var styles2 = classes.default && (0, _cloneDeep3.default)(classes.default) || {};
        activeNames.map(function(name2) {
          var toMerge = classes[name2];
          if (toMerge) {
            (0, _forOwn3.default)(toMerge, function(value2, key) {
              if (!styles2[key]) {
                styles2[key] = {};
              }
              styles2[key] = _extends2({}, styles2[key], toMerge[key]);
            });
          }
          return name2;
        });
        return styles2;
      };
      mergeClasses.default = mergeClasses$1;
      return mergeClasses;
    }
    var autoprefix = {};
    var hasRequiredAutoprefix;
    function requireAutoprefix() {
      if (hasRequiredAutoprefix) return autoprefix;
      hasRequiredAutoprefix = 1;
      Object.defineProperty(autoprefix, "__esModule", {
        value: true
      });
      autoprefix.autoprefix = void 0;
      var _forOwn2 = requireForOwn();
      var _forOwn3 = _interopRequireDefault(_forOwn2);
      var _extends2 = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var transforms = {
        borderRadius: function borderRadius(value2) {
          return {
            msBorderRadius: value2,
            MozBorderRadius: value2,
            OBorderRadius: value2,
            WebkitBorderRadius: value2,
            borderRadius: value2
          };
        },
        boxShadow: function boxShadow(value2) {
          return {
            msBoxShadow: value2,
            MozBoxShadow: value2,
            OBoxShadow: value2,
            WebkitBoxShadow: value2,
            boxShadow: value2
          };
        },
        userSelect: function userSelect(value2) {
          return {
            WebkitTouchCallout: value2,
            KhtmlUserSelect: value2,
            MozUserSelect: value2,
            msUserSelect: value2,
            WebkitUserSelect: value2,
            userSelect: value2
          };
        },
        flex: function flex(value2) {
          return {
            WebkitBoxFlex: value2,
            MozBoxFlex: value2,
            WebkitFlex: value2,
            msFlex: value2,
            flex: value2
          };
        },
        flexBasis: function flexBasis(value2) {
          return {
            WebkitFlexBasis: value2,
            flexBasis: value2
          };
        },
        justifyContent: function justifyContent(value2) {
          return {
            WebkitJustifyContent: value2,
            justifyContent: value2
          };
        },
        transition: function transition(value2) {
          return {
            msTransition: value2,
            MozTransition: value2,
            OTransition: value2,
            WebkitTransition: value2,
            transition: value2
          };
        },
        transform: function transform(value2) {
          return {
            msTransform: value2,
            MozTransform: value2,
            OTransform: value2,
            WebkitTransform: value2,
            transform: value2
          };
        },
        absolute: function absolute(value2) {
          var direction = value2 && value2.split(" ");
          return {
            position: "absolute",
            top: direction && direction[0],
            right: direction && direction[1],
            bottom: direction && direction[2],
            left: direction && direction[3]
          };
        },
        extend: function extend(name2, otherElementStyles) {
          var otherStyle = otherElementStyles[name2];
          if (otherStyle) {
            return otherStyle;
          }
          return {
            "extend": name2
          };
        }
      };
      var autoprefix$1 = autoprefix.autoprefix = function autoprefix2(elements) {
        var prefixed = {};
        (0, _forOwn3.default)(elements, function(styles2, element) {
          var expanded = {};
          (0, _forOwn3.default)(styles2, function(value2, key) {
            var transform = transforms[key];
            if (transform) {
              expanded = _extends2({}, expanded, transform(value2));
            } else {
              expanded[key] = value2;
            }
          });
          prefixed[element] = expanded;
        });
        return prefixed;
      };
      autoprefix.default = autoprefix$1;
      return autoprefix;
    }
    var hover = {};
    var hasRequiredHover;
    function requireHover() {
      if (hasRequiredHover) return hover;
      hasRequiredHover = 1;
      Object.defineProperty(hover, "__esModule", {
        value: true
      });
      hover.hover = void 0;
      var _extends2 = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      var _react = requireReact();
      var _react2 = _interopRequireDefault(_react);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _possibleConstructorReturn2(self2, call) {
        if (!self2) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self2;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      }
      var hover$1 = hover.hover = function hover2(Component) {
        var Span = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "span";
        return function(_React$Component) {
          _inherits2(Hover, _React$Component);
          function Hover() {
            var _ref;
            var _temp, _this, _ret;
            _classCallCheck2(this, Hover);
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return _ret = (_temp = (_this = _possibleConstructorReturn2(this, (_ref = Hover.__proto__ || Object.getPrototypeOf(Hover)).call.apply(_ref, [this].concat(args))), _this), _this.state = { hover: false }, _this.handleMouseOver = function() {
              return _this.setState({ hover: true });
            }, _this.handleMouseOut = function() {
              return _this.setState({ hover: false });
            }, _this.render = function() {
              return _react2.default.createElement(
                Span,
                { onMouseOver: _this.handleMouseOver, onMouseOut: _this.handleMouseOut },
                _react2.default.createElement(Component, _extends2({}, _this.props, _this.state))
              );
            }, _temp), _possibleConstructorReturn2(_this, _ret);
          }
          return Hover;
        }(_react2.default.Component);
      };
      hover.default = hover$1;
      return hover;
    }
    var active = {};
    var hasRequiredActive;
    function requireActive() {
      if (hasRequiredActive) return active;
      hasRequiredActive = 1;
      Object.defineProperty(active, "__esModule", {
        value: true
      });
      active.active = void 0;
      var _extends2 = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      var _react = requireReact();
      var _react2 = _interopRequireDefault(_react);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function _classCallCheck2(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _possibleConstructorReturn2(self2, call) {
        if (!self2) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self2;
      }
      function _inherits2(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
      }
      var active$1 = active.active = function active2(Component) {
        var Span = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "span";
        return function(_React$Component) {
          _inherits2(Active, _React$Component);
          function Active() {
            var _ref;
            var _temp, _this, _ret;
            _classCallCheck2(this, Active);
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return _ret = (_temp = (_this = _possibleConstructorReturn2(this, (_ref = Active.__proto__ || Object.getPrototypeOf(Active)).call.apply(_ref, [this].concat(args))), _this), _this.state = { active: false }, _this.handleMouseDown = function() {
              return _this.setState({ active: true });
            }, _this.handleMouseUp = function() {
              return _this.setState({ active: false });
            }, _this.render = function() {
              return _react2.default.createElement(
                Span,
                { onMouseDown: _this.handleMouseDown, onMouseUp: _this.handleMouseUp },
                _react2.default.createElement(Component, _extends2({}, _this.props, _this.state))
              );
            }, _temp), _possibleConstructorReturn2(_this, _ret);
          }
          return Active;
        }(_react2.default.Component);
      };
      active.default = active$1;
      return active;
    }
    var loop = {};
    var hasRequiredLoop;
    function requireLoop() {
      if (hasRequiredLoop) return loop;
      hasRequiredLoop = 1;
      Object.defineProperty(loop, "__esModule", {
        value: true
      });
      var loopable = function loopable2(i, length) {
        var props = {};
        var setProp = function setProp2(name2) {
          var value2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          props[name2] = value2;
        };
        i === 0 && setProp("first-child");
        i === length - 1 && setProp("last-child");
        (i === 0 || i % 2 === 0) && setProp("even");
        Math.abs(i % 2) === 1 && setProp("odd");
        setProp("nth-child", i);
        return props;
      };
      loop.default = loopable;
      return loop;
    }
    var hasRequiredLib;
    function requireLib() {
      if (hasRequiredLib) return lib;
      hasRequiredLib = 1;
      Object.defineProperty(lib, "__esModule", {
        value: true
      });
      lib.ReactCSS = lib.loop = lib.handleActive = lib.handleHover = lib.hover = void 0;
      var _flattenNames = requireFlattenNames();
      var _flattenNames2 = _interopRequireDefault(_flattenNames);
      var _mergeClasses = requireMergeClasses();
      var _mergeClasses2 = _interopRequireDefault(_mergeClasses);
      var _autoprefix = requireAutoprefix();
      var _autoprefix2 = _interopRequireDefault(_autoprefix);
      var _hover2 = requireHover();
      var _hover3 = _interopRequireDefault(_hover2);
      var _active = requireActive();
      var _active2 = _interopRequireDefault(_active);
      var _loop2 = requireLoop();
      var _loop3 = _interopRequireDefault(_loop2);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      lib.hover = _hover3.default;
      lib.handleHover = _hover3.default;
      lib.handleActive = _active2.default;
      lib.loop = _loop3.default;
      var ReactCSS = lib.ReactCSS = function ReactCSS2(classes) {
        for (var _len = arguments.length, activations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          activations[_key - 1] = arguments[_key];
        }
        var activeNames = (0, _flattenNames2.default)(activations);
        var merged = (0, _mergeClasses2.default)(classes, activeNames);
        return (0, _autoprefix2.default)(merged);
      };
      lib.default = ReactCSS;
      return lib;
    }
    var libExports = requireLib();
    const reactCSS = /* @__PURE__ */ getDefaultExportFromCjs(libExports);
    var calculateChange$2 = function calculateChange2(e, hsl, direction, initialA, container) {
      var containerWidth = container.clientWidth;
      var containerHeight = container.clientHeight;
      var x = typeof e.pageX === "number" ? e.pageX : e.touches[0].pageX;
      var y = typeof e.pageY === "number" ? e.pageY : e.touches[0].pageY;
      var left2 = x - (container.getBoundingClientRect().left + window.pageXOffset);
      var top2 = y - (container.getBoundingClientRect().top + window.pageYOffset);
      if (direction === "vertical") {
        var a = void 0;
        if (top2 < 0) {
          a = 0;
        } else if (top2 > containerHeight) {
          a = 1;
        } else {
          a = Math.round(top2 * 100 / containerHeight) / 100;
        }
        if (hsl.a !== a) {
          return {
            h: hsl.h,
            s: hsl.s,
            l: hsl.l,
            a,
            source: "rgb"
          };
        }
      } else {
        var _a2 = void 0;
        if (left2 < 0) {
          _a2 = 0;
        } else if (left2 > containerWidth) {
          _a2 = 1;
        } else {
          _a2 = Math.round(left2 * 100 / containerWidth) / 100;
        }
        if (initialA !== _a2) {
          return {
            h: hsl.h,
            s: hsl.s,
            l: hsl.l,
            a: _a2,
            source: "rgb"
          };
        }
      }
      return null;
    };
    var checkboardCache = {};
    var render = function render2(c1, c2, size, serverCanvas) {
      if (typeof document === "undefined" && !serverCanvas) {
        return null;
      }
      var canvas = serverCanvas ? new serverCanvas() : document.createElement("canvas");
      canvas.width = size * 2;
      canvas.height = size * 2;
      var ctx = canvas.getContext("2d");
      if (!ctx) {
        return null;
      }
      ctx.fillStyle = c1;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = c2;
      ctx.fillRect(0, 0, size, size);
      ctx.translate(size, size);
      ctx.fillRect(0, 0, size, size);
      return canvas.toDataURL();
    };
    var get$1 = function get2(c1, c2, size, serverCanvas) {
      var key = c1 + "-" + c2 + "-" + size + (serverCanvas ? "-server" : "");
      if (checkboardCache[key]) {
        return checkboardCache[key];
      }
      var checkboard = render(c1, c2, size, serverCanvas);
      checkboardCache[key] = checkboard;
      return checkboard;
    };
    var _extends$8 = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var Checkboard = function Checkboard2(_ref) {
      var white = _ref.white, grey = _ref.grey, size = _ref.size, renderers = _ref.renderers, borderRadius = _ref.borderRadius, boxShadow = _ref.boxShadow, children = _ref.children;
      var styles2 = reactCSS({
        "default": {
          grid: {
            borderRadius,
            boxShadow,
            absolute: "0px 0px 0px 0px",
            background: "url(" + get$1(white, grey, size, renderers.canvas) + ") center left"
          }
        }
      });
      return reactExports.isValidElement(children) ? React.cloneElement(children, _extends$8({}, children.props, { style: _extends$8({}, children.props.style, styles2.grid) })) : React.createElement("div", { style: styles2.grid });
    };
    Checkboard.defaultProps = {
      size: 8,
      white: "transparent",
      grey: "rgba(0,0,0,.08)",
      renderers: {}
    };
    var _extends$7 = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var _createClass$7 = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck$7(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn$7(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits$7(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var Alpha = function(_ref) {
      _inherits$7(Alpha2, _ref);
      function Alpha2() {
        var _ref2;
        var _temp, _this, _ret;
        _classCallCheck$7(this, Alpha2);
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return _ret = (_temp = (_this = _possibleConstructorReturn$7(this, (_ref2 = Alpha2.__proto__ || Object.getPrototypeOf(Alpha2)).call.apply(_ref2, [this].concat(args))), _this), _this.handleChange = function(e) {
          var change = calculateChange$2(e, _this.props.hsl, _this.props.direction, _this.props.a, _this.container);
          change && typeof _this.props.onChange === "function" && _this.props.onChange(change, e);
        }, _this.handleMouseDown = function(e) {
          _this.handleChange(e);
          window.addEventListener("mousemove", _this.handleChange);
          window.addEventListener("mouseup", _this.handleMouseUp);
        }, _this.handleMouseUp = function() {
          _this.unbindEventListeners();
        }, _this.unbindEventListeners = function() {
          window.removeEventListener("mousemove", _this.handleChange);
          window.removeEventListener("mouseup", _this.handleMouseUp);
        }, _temp), _possibleConstructorReturn$7(_this, _ret);
      }
      _createClass$7(Alpha2, [{
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this.unbindEventListeners();
        }
      }, {
        key: "render",
        value: function render2() {
          var _this2 = this;
          var rgb = this.props.rgb;
          var styles2 = reactCSS({
            "default": {
              alpha: {
                absolute: "0px 0px 0px 0px",
                borderRadius: this.props.radius
              },
              checkboard: {
                absolute: "0px 0px 0px 0px",
                overflow: "hidden",
                borderRadius: this.props.radius
              },
              gradient: {
                absolute: "0px 0px 0px 0px",
                background: "linear-gradient(to right, rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + ", 0) 0%,\n           rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + ", 1) 100%)",
                boxShadow: this.props.shadow,
                borderRadius: this.props.radius
              },
              container: {
                position: "relative",
                height: "100%",
                margin: "0 3px"
              },
              pointer: {
                position: "absolute",
                left: rgb.a * 100 + "%"
              },
              slider: {
                width: "4px",
                borderRadius: "1px",
                height: "8px",
                boxShadow: "0 0 2px rgba(0, 0, 0, .6)",
                background: "#fff",
                marginTop: "1px",
                transform: "translateX(-2px)"
              }
            },
            "vertical": {
              gradient: {
                background: "linear-gradient(to bottom, rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + ", 0) 0%,\n           rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + ", 1) 100%)"
              },
              pointer: {
                left: 0,
                top: rgb.a * 100 + "%"
              }
            },
            "overwrite": _extends$7({}, this.props.style)
          }, {
            vertical: this.props.direction === "vertical",
            overwrite: true
          });
          return React.createElement(
            "div",
            { style: styles2.alpha },
            React.createElement(
              "div",
              { style: styles2.checkboard },
              React.createElement(Checkboard, { renderers: this.props.renderers })
            ),
            React.createElement("div", { style: styles2.gradient }),
            React.createElement(
              "div",
              {
                style: styles2.container,
                ref: function ref(container) {
                  return _this2.container = container;
                },
                onMouseDown: this.handleMouseDown,
                onTouchMove: this.handleChange,
                onTouchStart: this.handleChange
              },
              React.createElement(
                "div",
                { style: styles2.pointer },
                this.props.pointer ? React.createElement(this.props.pointer, this.props) : React.createElement("div", { style: styles2.slider })
              )
            )
          );
        }
      }]);
      return Alpha2;
    }(reactExports.PureComponent || reactExports.Component);
    var _createClass$6 = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _defineProperty(obj, key, value2) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value: value2, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value2;
      }
      return obj;
    }
    function _classCallCheck$6(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn$6(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits$6(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var DEFAULT_ARROW_OFFSET = 1;
    var UP_KEY_CODE = 38;
    var DOWN_KEY_CODE = 40;
    var VALID_KEY_CODES = [UP_KEY_CODE, DOWN_KEY_CODE];
    var isValidKeyCode = function isValidKeyCode2(keyCode) {
      return VALID_KEY_CODES.indexOf(keyCode) > -1;
    };
    var getNumberValue = function getNumberValue2(value2) {
      return Number(String(value2).replace(/%/g, ""));
    };
    var idCounter = 1;
    var EditableInput = function(_ref) {
      _inherits$6(EditableInput2, _ref);
      function EditableInput2(props) {
        _classCallCheck$6(this, EditableInput2);
        var _this = _possibleConstructorReturn$6(this, (EditableInput2.__proto__ || Object.getPrototypeOf(EditableInput2)).call(this));
        _this.handleBlur = function() {
          if (_this.state.blurValue) {
            _this.setState({ value: _this.state.blurValue, blurValue: null });
          }
        };
        _this.handleChange = function(e) {
          _this.setUpdatedValue(e.target.value, e);
        };
        _this.handleKeyDown = function(e) {
          var value2 = getNumberValue(e.target.value);
          if (!isNaN(value2) && isValidKeyCode(e.keyCode)) {
            var offset = _this.getArrowOffset();
            var updatedValue = e.keyCode === UP_KEY_CODE ? value2 + offset : value2 - offset;
            _this.setUpdatedValue(updatedValue, e);
          }
        };
        _this.handleDrag = function(e) {
          if (_this.props.dragLabel) {
            var newValue = Math.round(_this.props.value + e.movementX);
            if (newValue >= 0 && newValue <= _this.props.dragMax) {
              _this.props.onChange && _this.props.onChange(_this.getValueObjectWithLabel(newValue), e);
            }
          }
        };
        _this.handleMouseDown = function(e) {
          if (_this.props.dragLabel) {
            e.preventDefault();
            _this.handleDrag(e);
            window.addEventListener("mousemove", _this.handleDrag);
            window.addEventListener("mouseup", _this.handleMouseUp);
          }
        };
        _this.handleMouseUp = function() {
          _this.unbindEventListeners();
        };
        _this.unbindEventListeners = function() {
          window.removeEventListener("mousemove", _this.handleDrag);
          window.removeEventListener("mouseup", _this.handleMouseUp);
        };
        _this.state = {
          value: String(props.value).toUpperCase(),
          blurValue: String(props.value).toUpperCase()
        };
        _this.inputId = "rc-editable-input-" + idCounter++;
        return _this;
      }
      _createClass$6(EditableInput2, [{
        key: "componentDidUpdate",
        value: function componentDidUpdate(prevProps, prevState) {
          if (this.props.value !== this.state.value && (prevProps.value !== this.props.value || prevState.value !== this.state.value)) {
            if (this.input === document.activeElement) {
              this.setState({ blurValue: String(this.props.value).toUpperCase() });
            } else {
              this.setState({ value: String(this.props.value).toUpperCase(), blurValue: !this.state.blurValue && String(this.props.value).toUpperCase() });
            }
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this.unbindEventListeners();
        }
      }, {
        key: "getValueObjectWithLabel",
        value: function getValueObjectWithLabel(value2) {
          return _defineProperty({}, this.props.label, value2);
        }
      }, {
        key: "getArrowOffset",
        value: function getArrowOffset() {
          return this.props.arrowOffset || DEFAULT_ARROW_OFFSET;
        }
      }, {
        key: "setUpdatedValue",
        value: function setUpdatedValue(value2, e) {
          var onChangeValue = this.props.label ? this.getValueObjectWithLabel(value2) : value2;
          this.props.onChange && this.props.onChange(onChangeValue, e);
          this.setState({ value: value2 });
        }
      }, {
        key: "render",
        value: function render2() {
          var _this2 = this;
          var styles2 = reactCSS({
            "default": {
              wrap: {
                position: "relative"
              }
            },
            "user-override": {
              wrap: this.props.style && this.props.style.wrap ? this.props.style.wrap : {},
              input: this.props.style && this.props.style.input ? this.props.style.input : {},
              label: this.props.style && this.props.style.label ? this.props.style.label : {}
            },
            "dragLabel-true": {
              label: {
                cursor: "ew-resize"
              }
            }
          }, {
            "user-override": true
          }, this.props);
          return React.createElement(
            "div",
            { style: styles2.wrap },
            React.createElement("input", {
              id: this.inputId,
              style: styles2.input,
              ref: function ref(input2) {
                return _this2.input = input2;
              },
              value: this.state.value,
              onKeyDown: this.handleKeyDown,
              onChange: this.handleChange,
              onBlur: this.handleBlur,
              placeholder: this.props.placeholder,
              spellCheck: "false"
            }),
            this.props.label && !this.props.hideLabel ? React.createElement(
              "label",
              {
                htmlFor: this.inputId,
                style: styles2.label,
                onMouseDown: this.handleMouseDown
              },
              this.props.label
            ) : null
          );
        }
      }]);
      return EditableInput2;
    }(reactExports.PureComponent || reactExports.Component);
    var calculateChange$1 = function calculateChange2(e, direction, hsl, container) {
      var containerWidth = container.clientWidth;
      var containerHeight = container.clientHeight;
      var x = typeof e.pageX === "number" ? e.pageX : e.touches[0].pageX;
      var y = typeof e.pageY === "number" ? e.pageY : e.touches[0].pageY;
      var left2 = x - (container.getBoundingClientRect().left + window.pageXOffset);
      var top2 = y - (container.getBoundingClientRect().top + window.pageYOffset);
      if (direction === "vertical") {
        var h = void 0;
        if (top2 < 0) {
          h = 359;
        } else if (top2 > containerHeight) {
          h = 0;
        } else {
          var percent = -(top2 * 100 / containerHeight) + 100;
          h = 360 * percent / 100;
        }
        if (hsl.h !== h) {
          return {
            h,
            s: hsl.s,
            l: hsl.l,
            a: hsl.a,
            source: "hsl"
          };
        }
      } else {
        var _h = void 0;
        if (left2 < 0) {
          _h = 0;
        } else if (left2 > containerWidth) {
          _h = 359;
        } else {
          var _percent = left2 * 100 / containerWidth;
          _h = 360 * _percent / 100;
        }
        if (hsl.h !== _h) {
          return {
            h: _h,
            s: hsl.s,
            l: hsl.l,
            a: hsl.a,
            source: "hsl"
          };
        }
      }
      return null;
    };
    var _createClass$5 = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck$5(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn$5(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits$5(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var Hue = function(_ref) {
      _inherits$5(Hue2, _ref);
      function Hue2() {
        var _ref2;
        var _temp, _this, _ret;
        _classCallCheck$5(this, Hue2);
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return _ret = (_temp = (_this = _possibleConstructorReturn$5(this, (_ref2 = Hue2.__proto__ || Object.getPrototypeOf(Hue2)).call.apply(_ref2, [this].concat(args))), _this), _this.handleChange = function(e) {
          var change = calculateChange$1(e, _this.props.direction, _this.props.hsl, _this.container);
          change && typeof _this.props.onChange === "function" && _this.props.onChange(change, e);
        }, _this.handleMouseDown = function(e) {
          _this.handleChange(e);
          window.addEventListener("mousemove", _this.handleChange);
          window.addEventListener("mouseup", _this.handleMouseUp);
        }, _this.handleMouseUp = function() {
          _this.unbindEventListeners();
        }, _temp), _possibleConstructorReturn$5(_this, _ret);
      }
      _createClass$5(Hue2, [{
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this.unbindEventListeners();
        }
      }, {
        key: "unbindEventListeners",
        value: function unbindEventListeners() {
          window.removeEventListener("mousemove", this.handleChange);
          window.removeEventListener("mouseup", this.handleMouseUp);
        }
      }, {
        key: "render",
        value: function render2() {
          var _this2 = this;
          var _props$direction = this.props.direction, direction = _props$direction === void 0 ? "horizontal" : _props$direction;
          var styles2 = reactCSS({
            "default": {
              hue: {
                absolute: "0px 0px 0px 0px",
                borderRadius: this.props.radius,
                boxShadow: this.props.shadow
              },
              container: {
                padding: "0 2px",
                position: "relative",
                height: "100%",
                borderRadius: this.props.radius
              },
              pointer: {
                position: "absolute",
                left: this.props.hsl.h * 100 / 360 + "%"
              },
              slider: {
                marginTop: "1px",
                width: "4px",
                borderRadius: "1px",
                height: "8px",
                boxShadow: "0 0 2px rgba(0, 0, 0, .6)",
                background: "#fff",
                transform: "translateX(-2px)"
              }
            },
            "vertical": {
              pointer: {
                left: "0px",
                top: -(this.props.hsl.h * 100 / 360) + 100 + "%"
              }
            }
          }, { vertical: direction === "vertical" });
          return React.createElement(
            "div",
            { style: styles2.hue },
            React.createElement(
              "div",
              {
                className: "hue-" + direction,
                style: styles2.container,
                ref: function ref(container) {
                  return _this2.container = container;
                },
                onMouseDown: this.handleMouseDown,
                onTouchMove: this.handleChange,
                onTouchStart: this.handleChange
              },
              React.createElement(
                "style",
                null,
                "\n            .hue-horizontal {\n              background: linear-gradient(to right, #f00 0%, #ff0 17%, #0f0\n                33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n              background: -webkit-linear-gradient(to right, #f00 0%, #ff0\n                17%, #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n            }\n\n            .hue-vertical {\n              background: linear-gradient(to top, #f00 0%, #ff0 17%, #0f0 33%,\n                #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n              background: -webkit-linear-gradient(to top, #f00 0%, #ff0 17%,\n                #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n            }\n          "
              ),
              React.createElement(
                "div",
                { style: styles2.pointer },
                this.props.pointer ? React.createElement(this.props.pointer, this.props) : React.createElement("div", { style: styles2.slider })
              )
            )
          );
        }
      }]);
      return Hue2;
    }(reactExports.PureComponent || reactExports.Component);
    var propTypes = { exports: {} };
    var ReactPropTypesSecret_1;
    var hasRequiredReactPropTypesSecret;
    function requireReactPropTypesSecret() {
      if (hasRequiredReactPropTypesSecret) return ReactPropTypesSecret_1;
      hasRequiredReactPropTypesSecret = 1;
      var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
      ReactPropTypesSecret_1 = ReactPropTypesSecret;
      return ReactPropTypesSecret_1;
    }
    var factoryWithThrowingShims;
    var hasRequiredFactoryWithThrowingShims;
    function requireFactoryWithThrowingShims() {
      if (hasRequiredFactoryWithThrowingShims) return factoryWithThrowingShims;
      hasRequiredFactoryWithThrowingShims = 1;
      var ReactPropTypesSecret = /* @__PURE__ */ requireReactPropTypesSecret();
      function emptyFunction() {
      }
      function emptyFunctionWithReset() {
      }
      emptyFunctionWithReset.resetWarningCache = emptyFunction;
      factoryWithThrowingShims = function() {
        function shim(props, propName, componentName, location, propFullName, secret) {
          if (secret === ReactPropTypesSecret) {
            return;
          }
          var err = new Error(
            "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
          );
          err.name = "Invariant Violation";
          throw err;
        }
        shim.isRequired = shim;
        function getShim() {
          return shim;
        }
        var ReactPropTypes = {
          array: shim,
          bigint: shim,
          bool: shim,
          func: shim,
          number: shim,
          object: shim,
          string: shim,
          symbol: shim,
          any: shim,
          arrayOf: getShim,
          element: shim,
          elementType: shim,
          instanceOf: getShim,
          node: shim,
          objectOf: getShim,
          oneOf: getShim,
          oneOfType: getShim,
          shape: getShim,
          exact: getShim,
          checkPropTypes: emptyFunctionWithReset,
          resetWarningCache: emptyFunction
        };
        ReactPropTypes.PropTypes = ReactPropTypes;
        return ReactPropTypes;
      };
      return factoryWithThrowingShims;
    }
    var hasRequiredPropTypes;
    function requirePropTypes() {
      if (hasRequiredPropTypes) return propTypes.exports;
      hasRequiredPropTypes = 1;
      {
        propTypes.exports = /* @__PURE__ */ requireFactoryWithThrowingShims()();
      }
      return propTypes.exports;
    }
    var propTypesExports = /* @__PURE__ */ requirePropTypes();
    const PropTypes = /* @__PURE__ */ getDefaultExportFromCjs(propTypesExports);
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function eq(value2, other) {
      return value2 === other || value2 !== value2 && other !== other;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    var arrayProto = Array.prototype;
    var splice = arrayProto.splice;
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value2) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value2]);
      } else {
        data[index][1] = value2;
      }
      return this;
    }
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var Symbol$1 = root.Symbol;
    var objectProto$f = Object.prototype;
    var hasOwnProperty$c = objectProto$f.hasOwnProperty;
    var nativeObjectToString$1 = objectProto$f.toString;
    var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
    function getRawTag(value2) {
      var isOwn = hasOwnProperty$c.call(value2, symToStringTag$1), tag = value2[symToStringTag$1];
      try {
        value2[symToStringTag$1] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString$1.call(value2);
      if (unmasked) {
        if (isOwn) {
          value2[symToStringTag$1] = tag;
        } else {
          delete value2[symToStringTag$1];
        }
      }
      return result;
    }
    var objectProto$e = Object.prototype;
    var nativeObjectToString = objectProto$e.toString;
    function objectToString(value2) {
      return nativeObjectToString.call(value2);
    }
    var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
    function baseGetTag(value2) {
      if (value2 == null) {
        return value2 === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value2) ? getRawTag(value2) : objectToString(value2);
    }
    function isObject(value2) {
      var type = typeof value2;
      return value2 != null && (type == "object" || type == "function");
    }
    var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
    function isFunction(value2) {
      if (!isObject(value2)) {
        return false;
      }
      var tag = baseGetTag(value2);
      return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
    }
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    var funcProto$2 = Function.prototype;
    var funcToString$2 = funcProto$2.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString$2.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto$1 = Function.prototype, objectProto$d = Object.prototype;
    var funcToString$1 = funcProto$1.toString;
    var hasOwnProperty$b = objectProto$d.hasOwnProperty;
    var reIsNative = RegExp(
      "^" + funcToString$1.call(hasOwnProperty$b).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative(value2) {
      if (!isObject(value2) || isMasked(value2)) {
        return false;
      }
      var pattern2 = isFunction(value2) ? reIsNative : reIsHostCtor;
      return pattern2.test(toSource(value2));
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function getNative(object, key) {
      var value2 = getValue(object, key);
      return baseIsNative(value2) ? value2 : void 0;
    }
    var Map$1 = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
    var objectProto$c = Object.prototype;
    var hasOwnProperty$a = objectProto$c.hasOwnProperty;
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED$2 ? void 0 : result;
      }
      return hasOwnProperty$a.call(data, key) ? data[key] : void 0;
    }
    var objectProto$b = Object.prototype;
    var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty$9.call(data, key);
    }
    var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
    function hashSet(key, value2) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value2 === void 0 ? HASH_UNDEFINED$1 : value2;
      return this;
    }
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map$1 || ListCache)(),
        "string": new Hash()
      };
    }
    function isKeyable(value2) {
      var type = typeof value2;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value2 !== "__proto__" : value2 === null;
    }
    function getMapData(map2, key) {
      var data = map2.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value2) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value2);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    var LARGE_ARRAY_SIZE = 200;
    function stackSet(key, value2) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value2]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value2);
      this.size = data.size;
      return this;
    }
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    var defineProperty = function() {
      try {
        var func = getNative(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e) {
      }
    }();
    function baseAssignValue(object, key, value2) {
      if (key == "__proto__" && defineProperty) {
        defineProperty(object, key, {
          "configurable": true,
          "enumerable": true,
          "value": value2,
          "writable": true
        });
      } else {
        object[key] = value2;
      }
    }
    function assignMergeValue(object, key, value2) {
      if (value2 !== void 0 && !eq(object[key], value2) || value2 === void 0 && !(key in object)) {
        baseAssignValue(object, key, value2);
      }
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    var baseFor = createBaseFor();
    var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
    var Buffer$1 = moduleExports$2 ? root.Buffer : void 0, allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : void 0;
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    var Uint8Array2 = root.Uint8Array;
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    var objectCreate = Object.create;
    var baseCreate = /* @__PURE__ */ function() {
      function object() {
      }
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object();
        object.prototype = void 0;
        return result;
      };
    }();
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectProto$a = Object.prototype;
    function isPrototype(value2) {
      var Ctor = value2 && value2.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$a;
      return value2 === proto;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function isObjectLike(value2) {
      return value2 != null && typeof value2 == "object";
    }
    var argsTag$3 = "[object Arguments]";
    function baseIsArguments(value2) {
      return isObjectLike(value2) && baseGetTag(value2) == argsTag$3;
    }
    var objectProto$9 = Object.prototype;
    var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
    var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value2) {
      return isObjectLike(value2) && hasOwnProperty$8.call(value2, "callee") && !propertyIsEnumerable$1.call(value2, "callee");
    };
    var isArray = Array.isArray;
    var MAX_SAFE_INTEGER$1 = 9007199254740991;
    function isLength(value2) {
      return typeof value2 == "number" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER$1;
    }
    function isArrayLike(value2) {
      return value2 != null && isLength(value2.length) && !isFunction(value2);
    }
    function isArrayLikeObject(value2) {
      return isObjectLike(value2) && isArrayLike(value2);
    }
    function stubFalse() {
      return false;
    }
    var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
    var Buffer2 = moduleExports$1 ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    var objectTag$4 = "[object Object]";
    var funcProto = Function.prototype, objectProto$8 = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    function isPlainObject(value2) {
      if (!isObjectLike(value2) || baseGetTag(value2) != objectTag$4) {
        return false;
      }
      var proto = getPrototype(value2);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty$7.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    var argsTag$2 = "[object Arguments]", arrayTag$2 = "[object Array]", boolTag$3 = "[object Boolean]", dateTag$3 = "[object Date]", errorTag$2 = "[object Error]", funcTag$1 = "[object Function]", mapTag$5 = "[object Map]", numberTag$3 = "[object Number]", objectTag$3 = "[object Object]", regexpTag$3 = "[object RegExp]", setTag$5 = "[object Set]", stringTag$3 = "[object String]", weakMapTag$2 = "[object WeakMap]";
    var arrayBufferTag$3 = "[object ArrayBuffer]", dataViewTag$4 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
    typedArrayTags[argsTag$2] = typedArrayTags[arrayTag$2] = typedArrayTags[arrayBufferTag$3] = typedArrayTags[boolTag$3] = typedArrayTags[dataViewTag$4] = typedArrayTags[dateTag$3] = typedArrayTags[errorTag$2] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$5] = typedArrayTags[numberTag$3] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$3] = typedArrayTags[setTag$5] = typedArrayTags[stringTag$3] = typedArrayTags[weakMapTag$2] = false;
    function baseIsTypedArray(value2) {
      return isObjectLike(value2) && isLength(value2.length) && !!typedArrayTags[baseGetTag(value2)];
    }
    function baseUnary(func) {
      return function(value2) {
        return func(value2);
      };
    }
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function safeGet(object, key) {
      if (key === "constructor" && typeof object[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object[key];
    }
    var objectProto$7 = Object.prototype;
    var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
    function assignValue(object, key, value2) {
      var objValue = object[key];
      if (!(hasOwnProperty$6.call(object, key) && eq(objValue, value2)) || value2 === void 0 && !(key in object)) {
        baseAssignValue(object, key, value2);
      }
    }
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value2, length) {
      var type = typeof value2;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length);
    }
    var objectProto$6 = Object.prototype;
    var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
    function arrayLikeKeys(value2, inherited) {
      var isArr = isArray(value2), isArg = !isArr && isArguments(value2), isBuff = !isArr && !isArg && isBuffer(value2), isType = !isArr && !isArg && !isBuff && isTypedArray(value2), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value2.length, String) : [], length = result.length;
      for (var key in value2) {
        if ((inherited || hasOwnProperty$5.call(value2, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    var objectProto$5 = Object.prototype;
    var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty$4.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    function toPlainObject(value2) {
      return copyObject(value2, keysIn(value2));
    }
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack());
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    function identity(value2) {
      return value2;
    }
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    var nativeMax$1 = Math.max;
    function overRest(func, start, transform) {
      start = nativeMax$1(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax$1(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }
    function constant(value2) {
      return function() {
        return value2;
      };
    }
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, "toString", {
        "configurable": true,
        "enumerable": false,
        "value": constant(string),
        "writable": true
      });
    };
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var nativeNow = Date.now;
    function shortOut(func) {
      var count = 0, lastCalled = 0;
      return function() {
        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(void 0, arguments);
      };
    }
    var setToString = shortOut(baseSetToString);
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + "");
    }
    function isIterateeCall(value2, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value2);
      }
      return false;
    }
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });
    var Raised = function Raised2(_ref) {
      var zDepth = _ref.zDepth, radius = _ref.radius, background = _ref.background, children = _ref.children, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles;
      var styles2 = reactCSS(merge({
        "default": {
          wrap: {
            position: "relative",
            display: "inline-block"
          },
          content: {
            position: "relative"
          },
          bg: {
            absolute: "0px 0px 0px 0px",
            boxShadow: "0 " + zDepth + "px " + zDepth * 4 + "px rgba(0,0,0,.24)",
            borderRadius: radius,
            background
          }
        },
        "zDepth-0": {
          bg: {
            boxShadow: "none"
          }
        },
        "zDepth-1": {
          bg: {
            boxShadow: "0 2px 10px rgba(0,0,0,.12), 0 2px 5px rgba(0,0,0,.16)"
          }
        },
        "zDepth-2": {
          bg: {
            boxShadow: "0 6px 20px rgba(0,0,0,.19), 0 8px 17px rgba(0,0,0,.2)"
          }
        },
        "zDepth-3": {
          bg: {
            boxShadow: "0 17px 50px rgba(0,0,0,.19), 0 12px 15px rgba(0,0,0,.24)"
          }
        },
        "zDepth-4": {
          bg: {
            boxShadow: "0 25px 55px rgba(0,0,0,.21), 0 16px 28px rgba(0,0,0,.22)"
          }
        },
        "zDepth-5": {
          bg: {
            boxShadow: "0 40px 77px rgba(0,0,0,.22), 0 27px 24px rgba(0,0,0,.2)"
          }
        },
        "square": {
          bg: {
            borderRadius: "0"
          }
        },
        "circle": {
          bg: {
            borderRadius: "50%"
          }
        }
      }, passedStyles), { "zDepth-1": zDepth === 1 });
      return React.createElement(
        "div",
        { style: styles2.wrap },
        React.createElement("div", { style: styles2.bg }),
        React.createElement(
          "div",
          { style: styles2.content },
          children
        )
      );
    };
    Raised.propTypes = {
      background: PropTypes.string,
      zDepth: PropTypes.oneOf([0, 1, 2, 3, 4, 5]),
      radius: PropTypes.number,
      styles: PropTypes.object
    };
    Raised.defaultProps = {
      background: "#fff",
      zDepth: 1,
      radius: 2,
      styles: {}
    };
    var now = function() {
      return root.Date.now();
    };
    var reWhitespace = /\s/;
    function trimmedEndIndex(string) {
      var index = string.length;
      while (index-- && reWhitespace.test(string.charAt(index))) {
      }
      return index;
    }
    var reTrimStart = /^\s+/;
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    var symbolTag$3 = "[object Symbol]";
    function isSymbol(value2) {
      return typeof value2 == "symbol" || isObjectLike(value2) && baseGetTag(value2) == symbolTag$3;
    }
    var NAN = 0 / 0;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    function toNumber(value2) {
      if (typeof value2 == "number") {
        return value2;
      }
      if (isSymbol(value2)) {
        return NAN;
      }
      if (isObject(value2)) {
        var other = typeof value2.valueOf == "function" ? value2.valueOf() : value2;
        value2 = isObject(other) ? other + "" : other;
      }
      if (typeof value2 != "string") {
        return value2 === 0 ? value2 : +value2;
      }
      value2 = baseTrim(value2);
      var isBinary = reIsBinary.test(value2);
      return isBinary || reIsOctal.test(value2) ? freeParseInt(value2.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value2) ? NAN : +value2;
    }
    var FUNC_ERROR_TEXT$2 = "Expected a function";
    var nativeMax = Math.max, nativeMin = Math.min;
    function debounce(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT$2);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
        return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    var FUNC_ERROR_TEXT$1 = "Expected a function";
    function throttle(func, wait, options) {
      var leading = true, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT$1);
      }
      if (isObject(options)) {
        leading = "leading" in options ? !!options.leading : leading;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
      });
    }
    var calculateChange = function calculateChange2(e, hsl, container) {
      var _container$getBoundin = container.getBoundingClientRect(), containerWidth = _container$getBoundin.width, containerHeight = _container$getBoundin.height;
      var x = typeof e.pageX === "number" ? e.pageX : e.touches[0].pageX;
      var y = typeof e.pageY === "number" ? e.pageY : e.touches[0].pageY;
      var left2 = x - (container.getBoundingClientRect().left + window.pageXOffset);
      var top2 = y - (container.getBoundingClientRect().top + window.pageYOffset);
      if (left2 < 0) {
        left2 = 0;
      } else if (left2 > containerWidth) {
        left2 = containerWidth;
      }
      if (top2 < 0) {
        top2 = 0;
      } else if (top2 > containerHeight) {
        top2 = containerHeight;
      }
      var saturation = left2 / containerWidth;
      var bright = 1 - top2 / containerHeight;
      return {
        h: hsl.h,
        s: saturation,
        v: bright,
        a: hsl.a,
        source: "hsv"
      };
    };
    var _createClass$4 = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck$4(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn$4(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits$4(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var Saturation = function(_ref) {
      _inherits$4(Saturation2, _ref);
      function Saturation2(props) {
        _classCallCheck$4(this, Saturation2);
        var _this = _possibleConstructorReturn$4(this, (Saturation2.__proto__ || Object.getPrototypeOf(Saturation2)).call(this, props));
        _this.handleChange = function(e) {
          typeof _this.props.onChange === "function" && _this.throttle(_this.props.onChange, calculateChange(e, _this.props.hsl, _this.container), e);
        };
        _this.handleMouseDown = function(e) {
          _this.handleChange(e);
          var renderWindow = _this.getContainerRenderWindow();
          renderWindow.addEventListener("mousemove", _this.handleChange);
          renderWindow.addEventListener("mouseup", _this.handleMouseUp);
        };
        _this.handleMouseUp = function() {
          _this.unbindEventListeners();
        };
        _this.throttle = throttle(function(fn, data, e) {
          fn(data, e);
        }, 50);
        return _this;
      }
      _createClass$4(Saturation2, [{
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this.throttle.cancel();
          this.unbindEventListeners();
        }
      }, {
        key: "getContainerRenderWindow",
        value: function getContainerRenderWindow() {
          var container = this.container;
          var renderWindow = window;
          while (!renderWindow.document.contains(container) && renderWindow.parent !== renderWindow) {
            renderWindow = renderWindow.parent;
          }
          return renderWindow;
        }
      }, {
        key: "unbindEventListeners",
        value: function unbindEventListeners() {
          var renderWindow = this.getContainerRenderWindow();
          renderWindow.removeEventListener("mousemove", this.handleChange);
          renderWindow.removeEventListener("mouseup", this.handleMouseUp);
        }
      }, {
        key: "render",
        value: function render2() {
          var _this2 = this;
          var _ref2 = this.props.style || {}, color = _ref2.color, white = _ref2.white, black2 = _ref2.black, pointer = _ref2.pointer, circle = _ref2.circle;
          var styles2 = reactCSS({
            "default": {
              color: {
                absolute: "0px 0px 0px 0px",
                background: "hsl(" + this.props.hsl.h + ",100%, 50%)",
                borderRadius: this.props.radius
              },
              white: {
                absolute: "0px 0px 0px 0px",
                borderRadius: this.props.radius
              },
              black: {
                absolute: "0px 0px 0px 0px",
                boxShadow: this.props.shadow,
                borderRadius: this.props.radius
              },
              pointer: {
                position: "absolute",
                top: -(this.props.hsv.v * 100) + 100 + "%",
                left: this.props.hsv.s * 100 + "%",
                cursor: "default"
              },
              circle: {
                width: "4px",
                height: "4px",
                boxShadow: "0 0 0 1.5px #fff, inset 0 0 1px 1px rgba(0,0,0,.3),\n            0 0 1px 2px rgba(0,0,0,.4)",
                borderRadius: "50%",
                cursor: "hand",
                transform: "translate(-2px, -2px)"
              }
            },
            "custom": {
              color,
              white,
              black: black2,
              pointer,
              circle
            }
          }, { "custom": !!this.props.style });
          return React.createElement(
            "div",
            {
              style: styles2.color,
              ref: function ref(container) {
                return _this2.container = container;
              },
              onMouseDown: this.handleMouseDown,
              onTouchMove: this.handleChange,
              onTouchStart: this.handleChange
            },
            React.createElement(
              "style",
              null,
              "\n          .saturation-white {\n            background: -webkit-linear-gradient(to right, #fff, rgba(255,255,255,0));\n            background: linear-gradient(to right, #fff, rgba(255,255,255,0));\n          }\n          .saturation-black {\n            background: -webkit-linear-gradient(to top, #000, rgba(0,0,0,0));\n            background: linear-gradient(to top, #000, rgba(0,0,0,0));\n          }\n        "
            ),
            React.createElement(
              "div",
              { style: styles2.white, className: "saturation-white" },
              React.createElement("div", { style: styles2.black, className: "saturation-black" }),
              React.createElement(
                "div",
                { style: styles2.pointer },
                this.props.pointer ? React.createElement(this.props.pointer, this.props) : React.createElement("div", { style: styles2.circle })
              )
            )
          );
        }
      }]);
      return Saturation2;
    }(reactExports.PureComponent || reactExports.Component);
    function arrayEach(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    var nativeKeys = overArg(Object.keys, Object);
    var objectProto$4 = Object.prototype;
    var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty$3.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = -1, iterable = Object(collection);
        while (++index < length) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    var baseEach = createBaseEach(baseForOwn);
    function castFunction(value2) {
      return typeof value2 == "function" ? value2 : identity;
    }
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, castFunction(iteratee));
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    var trimLeft = /^\s+/;
    var trimRight = /\s+$/;
    function tinycolor(color, opts) {
      color = color ? color : "";
      opts = opts || {};
      if (color instanceof tinycolor) {
        return color;
      }
      if (!(this instanceof tinycolor)) {
        return new tinycolor(color, opts);
      }
      var rgb = inputToRGB(color);
      this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = Math.round(100 * this._a) / 100, this._format = opts.format || rgb.format;
      this._gradientType = opts.gradientType;
      if (this._r < 1) this._r = Math.round(this._r);
      if (this._g < 1) this._g = Math.round(this._g);
      if (this._b < 1) this._b = Math.round(this._b);
      this._ok = rgb.ok;
    }
    tinycolor.prototype = {
      isDark: function isDark() {
        return this.getBrightness() < 128;
      },
      isLight: function isLight() {
        return !this.isDark();
      },
      isValid: function isValid() {
        return this._ok;
      },
      getOriginalInput: function getOriginalInput() {
        return this._originalInput;
      },
      getFormat: function getFormat() {
        return this._format;
      },
      getAlpha: function getAlpha() {
        return this._a;
      },
      getBrightness: function getBrightness() {
        var rgb = this.toRgb();
        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
      },
      getLuminance: function getLuminance() {
        var rgb = this.toRgb();
        var RsRGB, GsRGB, BsRGB, R, G, B;
        RsRGB = rgb.r / 255;
        GsRGB = rgb.g / 255;
        BsRGB = rgb.b / 255;
        if (RsRGB <= 0.03928) R = RsRGB / 12.92;
        else R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
        if (GsRGB <= 0.03928) G = GsRGB / 12.92;
        else G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
        if (BsRGB <= 0.03928) B = BsRGB / 12.92;
        else B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
        return 0.2126 * R + 0.7152 * G + 0.0722 * B;
      },
      setAlpha: function setAlpha(value2) {
        this._a = boundAlpha(value2);
        this._roundA = Math.round(100 * this._a) / 100;
        return this;
      },
      toHsv: function toHsv() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        return {
          h: hsv.h * 360,
          s: hsv.s,
          v: hsv.v,
          a: this._a
        };
      },
      toHsvString: function toHsvString() {
        var hsv = rgbToHsv(this._r, this._g, this._b);
        var h = Math.round(hsv.h * 360), s = Math.round(hsv.s * 100), v = Math.round(hsv.v * 100);
        return this._a == 1 ? "hsv(" + h + ", " + s + "%, " + v + "%)" : "hsva(" + h + ", " + s + "%, " + v + "%, " + this._roundA + ")";
      },
      toHsl: function toHsl() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        return {
          h: hsl.h * 360,
          s: hsl.s,
          l: hsl.l,
          a: this._a
        };
      },
      toHslString: function toHslString() {
        var hsl = rgbToHsl(this._r, this._g, this._b);
        var h = Math.round(hsl.h * 360), s = Math.round(hsl.s * 100), l = Math.round(hsl.l * 100);
        return this._a == 1 ? "hsl(" + h + ", " + s + "%, " + l + "%)" : "hsla(" + h + ", " + s + "%, " + l + "%, " + this._roundA + ")";
      },
      toHex: function toHex(allow3Char) {
        return rgbToHex(this._r, this._g, this._b, allow3Char);
      },
      toHexString: function toHexString(allow3Char) {
        return "#" + this.toHex(allow3Char);
      },
      toHex8: function toHex8(allow4Char) {
        return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
      },
      toHex8String: function toHex8String(allow4Char) {
        return "#" + this.toHex8(allow4Char);
      },
      toRgb: function toRgb() {
        return {
          r: Math.round(this._r),
          g: Math.round(this._g),
          b: Math.round(this._b),
          a: this._a
        };
      },
      toRgbString: function toRgbString() {
        return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
      },
      toPercentageRgb: function toPercentageRgb() {
        return {
          r: Math.round(bound01(this._r, 255) * 100) + "%",
          g: Math.round(bound01(this._g, 255) * 100) + "%",
          b: Math.round(bound01(this._b, 255) * 100) + "%",
          a: this._a
        };
      },
      toPercentageRgbString: function toPercentageRgbString() {
        return this._a == 1 ? "rgb(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
      },
      toName: function toName() {
        if (this._a === 0) {
          return "transparent";
        }
        if (this._a < 1) {
          return false;
        }
        return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
      },
      toFilter: function toFilter(secondColor) {
        var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
        var secondHex8String = hex8String;
        var gradientType = this._gradientType ? "GradientType = 1, " : "";
        if (secondColor) {
          var s = tinycolor(secondColor);
          secondHex8String = "#" + rgbaToArgbHex(s._r, s._g, s._b, s._a);
        }
        return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
      },
      toString: function toString2(format) {
        var formatSet = !!format;
        format = format || this._format;
        var formattedString = false;
        var hasAlpha = this._a < 1 && this._a >= 0;
        var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "hex4" || format === "hex8" || format === "name");
        if (needsAlphaFormat) {
          if (format === "name" && this._a === 0) {
            return this.toName();
          }
          return this.toRgbString();
        }
        if (format === "rgb") {
          formattedString = this.toRgbString();
        }
        if (format === "prgb") {
          formattedString = this.toPercentageRgbString();
        }
        if (format === "hex" || format === "hex6") {
          formattedString = this.toHexString();
        }
        if (format === "hex3") {
          formattedString = this.toHexString(true);
        }
        if (format === "hex4") {
          formattedString = this.toHex8String(true);
        }
        if (format === "hex8") {
          formattedString = this.toHex8String();
        }
        if (format === "name") {
          formattedString = this.toName();
        }
        if (format === "hsl") {
          formattedString = this.toHslString();
        }
        if (format === "hsv") {
          formattedString = this.toHsvString();
        }
        return formattedString || this.toHexString();
      },
      clone: function clone() {
        return tinycolor(this.toString());
      },
      _applyModification: function _applyModification(fn, args) {
        var color = fn.apply(null, [this].concat([].slice.call(args)));
        this._r = color._r;
        this._g = color._g;
        this._b = color._b;
        this.setAlpha(color._a);
        return this;
      },
      lighten: function lighten() {
        return this._applyModification(_lighten, arguments);
      },
      brighten: function brighten() {
        return this._applyModification(_brighten, arguments);
      },
      darken: function darken() {
        return this._applyModification(_darken, arguments);
      },
      desaturate: function desaturate() {
        return this._applyModification(_desaturate, arguments);
      },
      saturate: function saturate() {
        return this._applyModification(_saturate, arguments);
      },
      greyscale: function greyscale() {
        return this._applyModification(_greyscale, arguments);
      },
      spin: function spin() {
        return this._applyModification(_spin, arguments);
      },
      _applyCombination: function _applyCombination(fn, args) {
        return fn.apply(null, [this].concat([].slice.call(args)));
      },
      analogous: function analogous() {
        return this._applyCombination(_analogous, arguments);
      },
      complement: function complement() {
        return this._applyCombination(_complement, arguments);
      },
      monochromatic: function monochromatic() {
        return this._applyCombination(_monochromatic, arguments);
      },
      splitcomplement: function splitcomplement() {
        return this._applyCombination(_splitcomplement, arguments);
      },
      // Disabled until https://github.com/bgrins/TinyColor/issues/254
      // polyad: function (number) {
      //   return this._applyCombination(polyad, [number]);
      // },
      triad: function triad() {
        return this._applyCombination(polyad, [3]);
      },
      tetrad: function tetrad() {
        return this._applyCombination(polyad, [4]);
      }
    };
    tinycolor.fromRatio = function(color, opts) {
      if (_typeof(color) == "object") {
        var newColor = {};
        for (var i in color) {
          if (color.hasOwnProperty(i)) {
            if (i === "a") {
              newColor[i] = color[i];
            } else {
              newColor[i] = convertToPercentage(color[i]);
            }
          }
        }
        color = newColor;
      }
      return tinycolor(color, opts);
    };
    function inputToRGB(color) {
      var rgb = {
        r: 0,
        g: 0,
        b: 0
      };
      var a = 1;
      var s = null;
      var v = null;
      var l = null;
      var ok = false;
      var format = false;
      if (typeof color == "string") {
        color = stringInputToObject(color);
      }
      if (_typeof(color) == "object") {
        if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
          rgb = rgbToRgb(color.r, color.g, color.b);
          ok = true;
          format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
        } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
          s = convertToPercentage(color.s);
          v = convertToPercentage(color.v);
          rgb = hsvToRgb(color.h, s, v);
          ok = true;
          format = "hsv";
        } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
          s = convertToPercentage(color.s);
          l = convertToPercentage(color.l);
          rgb = hslToRgb(color.h, s, l);
          ok = true;
          format = "hsl";
        }
        if (color.hasOwnProperty("a")) {
          a = color.a;
        }
      }
      a = boundAlpha(a);
      return {
        ok,
        format: color.format || format,
        r: Math.min(255, Math.max(rgb.r, 0)),
        g: Math.min(255, Math.max(rgb.g, 0)),
        b: Math.min(255, Math.max(rgb.b, 0)),
        a
      };
    }
    function rgbToRgb(r, g, b) {
      return {
        r: bound01(r, 255) * 255,
        g: bound01(g, 255) * 255,
        b: bound01(b, 255) * 255
      };
    }
    function rgbToHsl(r, g, b) {
      r = bound01(r, 255);
      g = bound01(g, 255);
      b = bound01(b, 255);
      var max2 = Math.max(r, g, b), min2 = Math.min(r, g, b);
      var h, s, l = (max2 + min2) / 2;
      if (max2 == min2) {
        h = s = 0;
      } else {
        var d = max2 - min2;
        s = l > 0.5 ? d / (2 - max2 - min2) : d / (max2 + min2);
        switch (max2) {
          case r:
            h = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h = (b - r) / d + 2;
            break;
          case b:
            h = (r - g) / d + 4;
            break;
        }
        h /= 6;
      }
      return {
        h,
        s,
        l
      };
    }
    function hslToRgb(h, s, l) {
      var r, g, b;
      h = bound01(h, 360);
      s = bound01(s, 100);
      l = bound01(l, 100);
      function hue2rgb(p2, q2, t) {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1 / 6) return p2 + (q2 - p2) * 6 * t;
        if (t < 1 / 2) return q2;
        if (t < 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t) * 6;
        return p2;
      }
      if (s === 0) {
        r = g = b = l;
      } else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hue2rgb(p, q, h + 1 / 3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1 / 3);
      }
      return {
        r: r * 255,
        g: g * 255,
        b: b * 255
      };
    }
    function rgbToHsv(r, g, b) {
      r = bound01(r, 255);
      g = bound01(g, 255);
      b = bound01(b, 255);
      var max2 = Math.max(r, g, b), min2 = Math.min(r, g, b);
      var h, s, v = max2;
      var d = max2 - min2;
      s = max2 === 0 ? 0 : d / max2;
      if (max2 == min2) {
        h = 0;
      } else {
        switch (max2) {
          case r:
            h = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h = (b - r) / d + 2;
            break;
          case b:
            h = (r - g) / d + 4;
            break;
        }
        h /= 6;
      }
      return {
        h,
        s,
        v
      };
    }
    function hsvToRgb(h, s, v) {
      h = bound01(h, 360) * 6;
      s = bound01(s, 100);
      v = bound01(v, 100);
      var i = Math.floor(h), f = h - i, p = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s), mod = i % 6, r = [v, q, p, p, t, v][mod], g = [t, v, v, q, p, p][mod], b = [p, p, t, v, v, q][mod];
      return {
        r: r * 255,
        g: g * 255,
        b: b * 255
      };
    }
    function rgbToHex(r, g, b, allow3Char) {
      var hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];
      if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
      }
      return hex.join("");
    }
    function rgbaToHex(r, g, b, a, allow4Char) {
      var hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16)), pad2(convertDecimalToHex(a))];
      if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
      }
      return hex.join("");
    }
    function rgbaToArgbHex(r, g, b, a) {
      var hex = [pad2(convertDecimalToHex(a)), pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];
      return hex.join("");
    }
    tinycolor.equals = function(color1, color2) {
      if (!color1 || !color2) return false;
      return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
    };
    tinycolor.random = function() {
      return tinycolor.fromRatio({
        r: Math.random(),
        g: Math.random(),
        b: Math.random()
      });
    };
    function _desaturate(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl = tinycolor(color).toHsl();
      hsl.s -= amount / 100;
      hsl.s = clamp01(hsl.s);
      return tinycolor(hsl);
    }
    function _saturate(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl = tinycolor(color).toHsl();
      hsl.s += amount / 100;
      hsl.s = clamp01(hsl.s);
      return tinycolor(hsl);
    }
    function _greyscale(color) {
      return tinycolor(color).desaturate(100);
    }
    function _lighten(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl = tinycolor(color).toHsl();
      hsl.l += amount / 100;
      hsl.l = clamp01(hsl.l);
      return tinycolor(hsl);
    }
    function _brighten(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var rgb = tinycolor(color).toRgb();
      rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
      rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
      rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
      return tinycolor(rgb);
    }
    function _darken(color, amount) {
      amount = amount === 0 ? 0 : amount || 10;
      var hsl = tinycolor(color).toHsl();
      hsl.l -= amount / 100;
      hsl.l = clamp01(hsl.l);
      return tinycolor(hsl);
    }
    function _spin(color, amount) {
      var hsl = tinycolor(color).toHsl();
      var hue = (hsl.h + amount) % 360;
      hsl.h = hue < 0 ? 360 + hue : hue;
      return tinycolor(hsl);
    }
    function _complement(color) {
      var hsl = tinycolor(color).toHsl();
      hsl.h = (hsl.h + 180) % 360;
      return tinycolor(hsl);
    }
    function polyad(color, number) {
      if (isNaN(number) || number <= 0) {
        throw new Error("Argument to polyad must be a positive number");
      }
      var hsl = tinycolor(color).toHsl();
      var result = [tinycolor(color)];
      var step = 360 / number;
      for (var i = 1; i < number; i++) {
        result.push(tinycolor({
          h: (hsl.h + i * step) % 360,
          s: hsl.s,
          l: hsl.l
        }));
      }
      return result;
    }
    function _splitcomplement(color) {
      var hsl = tinycolor(color).toHsl();
      var h = hsl.h;
      return [tinycolor(color), tinycolor({
        h: (h + 72) % 360,
        s: hsl.s,
        l: hsl.l
      }), tinycolor({
        h: (h + 216) % 360,
        s: hsl.s,
        l: hsl.l
      })];
    }
    function _analogous(color, results, slices) {
      results = results || 6;
      slices = slices || 30;
      var hsl = tinycolor(color).toHsl();
      var part = 360 / slices;
      var ret = [tinycolor(color)];
      for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
        hsl.h = (hsl.h + part) % 360;
        ret.push(tinycolor(hsl));
      }
      return ret;
    }
    function _monochromatic(color, results) {
      results = results || 6;
      var hsv = tinycolor(color).toHsv();
      var h = hsv.h, s = hsv.s, v = hsv.v;
      var ret = [];
      var modification = 1 / results;
      while (results--) {
        ret.push(tinycolor({
          h,
          s,
          v
        }));
        v = (v + modification) % 1;
      }
      return ret;
    }
    tinycolor.mix = function(color1, color2, amount) {
      amount = amount === 0 ? 0 : amount || 50;
      var rgb1 = tinycolor(color1).toRgb();
      var rgb2 = tinycolor(color2).toRgb();
      var p = amount / 100;
      var rgba = {
        r: (rgb2.r - rgb1.r) * p + rgb1.r,
        g: (rgb2.g - rgb1.g) * p + rgb1.g,
        b: (rgb2.b - rgb1.b) * p + rgb1.b,
        a: (rgb2.a - rgb1.a) * p + rgb1.a
      };
      return tinycolor(rgba);
    };
    tinycolor.readability = function(color1, color2) {
      var c1 = tinycolor(color1);
      var c2 = tinycolor(color2);
      return (Math.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
    };
    tinycolor.isReadable = function(color1, color2, wcag2) {
      var readability = tinycolor.readability(color1, color2);
      var wcag2Parms, out;
      out = false;
      wcag2Parms = validateWCAG2Parms(wcag2);
      switch (wcag2Parms.level + wcag2Parms.size) {
        case "AAsmall":
        case "AAAlarge":
          out = readability >= 4.5;
          break;
        case "AAlarge":
          out = readability >= 3;
          break;
        case "AAAsmall":
          out = readability >= 7;
          break;
      }
      return out;
    };
    tinycolor.mostReadable = function(baseColor, colorList, args) {
      var bestColor = null;
      var bestScore = 0;
      var readability;
      var includeFallbackColors, level2, size;
      args = args || {};
      includeFallbackColors = args.includeFallbackColors;
      level2 = args.level;
      size = args.size;
      for (var i = 0; i < colorList.length; i++) {
        readability = tinycolor.readability(baseColor, colorList[i]);
        if (readability > bestScore) {
          bestScore = readability;
          bestColor = tinycolor(colorList[i]);
        }
      }
      if (tinycolor.isReadable(baseColor, bestColor, {
        level: level2,
        size
      }) || !includeFallbackColors) {
        return bestColor;
      } else {
        args.includeFallbackColors = false;
        return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
      }
    };
    var names = tinycolor.names = {
      aliceblue: "f0f8ff",
      antiquewhite: "faebd7",
      aqua: "0ff",
      aquamarine: "7fffd4",
      azure: "f0ffff",
      beige: "f5f5dc",
      bisque: "ffe4c4",
      black: "000",
      blanchedalmond: "ffebcd",
      blue: "00f",
      blueviolet: "8a2be2",
      brown: "a52a2a",
      burlywood: "deb887",
      burntsienna: "ea7e5d",
      cadetblue: "5f9ea0",
      chartreuse: "7fff00",
      chocolate: "d2691e",
      coral: "ff7f50",
      cornflowerblue: "6495ed",
      cornsilk: "fff8dc",
      crimson: "dc143c",
      cyan: "0ff",
      darkblue: "00008b",
      darkcyan: "008b8b",
      darkgoldenrod: "b8860b",
      darkgray: "a9a9a9",
      darkgreen: "006400",
      darkgrey: "a9a9a9",
      darkkhaki: "bdb76b",
      darkmagenta: "8b008b",
      darkolivegreen: "556b2f",
      darkorange: "ff8c00",
      darkorchid: "9932cc",
      darkred: "8b0000",
      darksalmon: "e9967a",
      darkseagreen: "8fbc8f",
      darkslateblue: "483d8b",
      darkslategray: "2f4f4f",
      darkslategrey: "2f4f4f",
      darkturquoise: "00ced1",
      darkviolet: "9400d3",
      deeppink: "ff1493",
      deepskyblue: "00bfff",
      dimgray: "696969",
      dimgrey: "696969",
      dodgerblue: "1e90ff",
      firebrick: "b22222",
      floralwhite: "fffaf0",
      forestgreen: "228b22",
      fuchsia: "f0f",
      gainsboro: "dcdcdc",
      ghostwhite: "f8f8ff",
      gold: "ffd700",
      goldenrod: "daa520",
      gray: "808080",
      green: "008000",
      greenyellow: "adff2f",
      grey: "808080",
      honeydew: "f0fff0",
      hotpink: "ff69b4",
      indianred: "cd5c5c",
      indigo: "4b0082",
      ivory: "fffff0",
      khaki: "f0e68c",
      lavender: "e6e6fa",
      lavenderblush: "fff0f5",
      lawngreen: "7cfc00",
      lemonchiffon: "fffacd",
      lightblue: "add8e6",
      lightcoral: "f08080",
      lightcyan: "e0ffff",
      lightgoldenrodyellow: "fafad2",
      lightgray: "d3d3d3",
      lightgreen: "90ee90",
      lightgrey: "d3d3d3",
      lightpink: "ffb6c1",
      lightsalmon: "ffa07a",
      lightseagreen: "20b2aa",
      lightskyblue: "87cefa",
      lightslategray: "789",
      lightslategrey: "789",
      lightsteelblue: "b0c4de",
      lightyellow: "ffffe0",
      lime: "0f0",
      limegreen: "32cd32",
      linen: "faf0e6",
      magenta: "f0f",
      maroon: "800000",
      mediumaquamarine: "66cdaa",
      mediumblue: "0000cd",
      mediumorchid: "ba55d3",
      mediumpurple: "9370db",
      mediumseagreen: "3cb371",
      mediumslateblue: "7b68ee",
      mediumspringgreen: "00fa9a",
      mediumturquoise: "48d1cc",
      mediumvioletred: "c71585",
      midnightblue: "191970",
      mintcream: "f5fffa",
      mistyrose: "ffe4e1",
      moccasin: "ffe4b5",
      navajowhite: "ffdead",
      navy: "000080",
      oldlace: "fdf5e6",
      olive: "808000",
      olivedrab: "6b8e23",
      orange: "ffa500",
      orangered: "ff4500",
      orchid: "da70d6",
      palegoldenrod: "eee8aa",
      palegreen: "98fb98",
      paleturquoise: "afeeee",
      palevioletred: "db7093",
      papayawhip: "ffefd5",
      peachpuff: "ffdab9",
      peru: "cd853f",
      pink: "ffc0cb",
      plum: "dda0dd",
      powderblue: "b0e0e6",
      purple: "800080",
      rebeccapurple: "663399",
      red: "f00",
      rosybrown: "bc8f8f",
      royalblue: "4169e1",
      saddlebrown: "8b4513",
      salmon: "fa8072",
      sandybrown: "f4a460",
      seagreen: "2e8b57",
      seashell: "fff5ee",
      sienna: "a0522d",
      silver: "c0c0c0",
      skyblue: "87ceeb",
      slateblue: "6a5acd",
      slategray: "708090",
      slategrey: "708090",
      snow: "fffafa",
      springgreen: "00ff7f",
      steelblue: "4682b4",
      tan: "d2b48c",
      teal: "008080",
      thistle: "d8bfd8",
      tomato: "ff6347",
      turquoise: "40e0d0",
      violet: "ee82ee",
      wheat: "f5deb3",
      white: "fff",
      whitesmoke: "f5f5f5",
      yellow: "ff0",
      yellowgreen: "9acd32"
    };
    var hexNames = tinycolor.hexNames = flip(names);
    function flip(o) {
      var flipped = {};
      for (var i in o) {
        if (o.hasOwnProperty(i)) {
          flipped[o[i]] = i;
        }
      }
      return flipped;
    }
    function boundAlpha(a) {
      a = parseFloat(a);
      if (isNaN(a) || a < 0 || a > 1) {
        a = 1;
      }
      return a;
    }
    function bound01(n, max2) {
      if (isOnePointZero(n)) n = "100%";
      var processPercent = isPercentage(n);
      n = Math.min(max2, Math.max(0, parseFloat(n)));
      if (processPercent) {
        n = parseInt(n * max2, 10) / 100;
      }
      if (Math.abs(n - max2) < 1e-6) {
        return 1;
      }
      return n % max2 / parseFloat(max2);
    }
    function clamp01(val) {
      return Math.min(1, Math.max(0, val));
    }
    function parseIntFromHex(val) {
      return parseInt(val, 16);
    }
    function isOnePointZero(n) {
      return typeof n == "string" && n.indexOf(".") != -1 && parseFloat(n) === 1;
    }
    function isPercentage(n) {
      return typeof n === "string" && n.indexOf("%") != -1;
    }
    function pad2(c) {
      return c.length == 1 ? "0" + c : "" + c;
    }
    function convertToPercentage(n) {
      if (n <= 1) {
        n = n * 100 + "%";
      }
      return n;
    }
    function convertDecimalToHex(d) {
      return Math.round(parseFloat(d) * 255).toString(16);
    }
    function convertHexToDecimal(h) {
      return parseIntFromHex(h) / 255;
    }
    var matchers = function() {
      var CSS_INTEGER = "[-\\+]?\\d+%?";
      var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
      var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
      var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
      var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
      return {
        CSS_UNIT: new RegExp(CSS_UNIT),
        rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
        rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
        hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
        hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
        hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
        hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
      };
    }();
    function isValidCSSUnit(color) {
      return !!matchers.CSS_UNIT.exec(color);
    }
    function stringInputToObject(color) {
      color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
      var named = false;
      if (names[color]) {
        color = names[color];
        named = true;
      } else if (color == "transparent") {
        return {
          r: 0,
          g: 0,
          b: 0,
          a: 0,
          format: "name"
        };
      }
      var match2;
      if (match2 = matchers.rgb.exec(color)) {
        return {
          r: match2[1],
          g: match2[2],
          b: match2[3]
        };
      }
      if (match2 = matchers.rgba.exec(color)) {
        return {
          r: match2[1],
          g: match2[2],
          b: match2[3],
          a: match2[4]
        };
      }
      if (match2 = matchers.hsl.exec(color)) {
        return {
          h: match2[1],
          s: match2[2],
          l: match2[3]
        };
      }
      if (match2 = matchers.hsla.exec(color)) {
        return {
          h: match2[1],
          s: match2[2],
          l: match2[3],
          a: match2[4]
        };
      }
      if (match2 = matchers.hsv.exec(color)) {
        return {
          h: match2[1],
          s: match2[2],
          v: match2[3]
        };
      }
      if (match2 = matchers.hsva.exec(color)) {
        return {
          h: match2[1],
          s: match2[2],
          v: match2[3],
          a: match2[4]
        };
      }
      if (match2 = matchers.hex8.exec(color)) {
        return {
          r: parseIntFromHex(match2[1]),
          g: parseIntFromHex(match2[2]),
          b: parseIntFromHex(match2[3]),
          a: convertHexToDecimal(match2[4]),
          format: named ? "name" : "hex8"
        };
      }
      if (match2 = matchers.hex6.exec(color)) {
        return {
          r: parseIntFromHex(match2[1]),
          g: parseIntFromHex(match2[2]),
          b: parseIntFromHex(match2[3]),
          format: named ? "name" : "hex"
        };
      }
      if (match2 = matchers.hex4.exec(color)) {
        return {
          r: parseIntFromHex(match2[1] + "" + match2[1]),
          g: parseIntFromHex(match2[2] + "" + match2[2]),
          b: parseIntFromHex(match2[3] + "" + match2[3]),
          a: convertHexToDecimal(match2[4] + "" + match2[4]),
          format: named ? "name" : "hex8"
        };
      }
      if (match2 = matchers.hex3.exec(color)) {
        return {
          r: parseIntFromHex(match2[1] + "" + match2[1]),
          g: parseIntFromHex(match2[2] + "" + match2[2]),
          b: parseIntFromHex(match2[3] + "" + match2[3]),
          format: named ? "name" : "hex"
        };
      }
      return false;
    }
    function validateWCAG2Parms(parms) {
      var level2, size;
      parms = parms || {
        level: "AA",
        size: "small"
      };
      level2 = (parms.level || "AA").toUpperCase();
      size = (parms.size || "small").toLowerCase();
      if (level2 !== "AA" && level2 !== "AAA") {
        level2 = "AA";
      }
      if (size !== "small" && size !== "large") {
        size = "small";
      }
      return {
        level: level2,
        size
      };
    }
    var simpleCheckForValidColor = function simpleCheckForValidColor2(data) {
      var keysToCheck = ["r", "g", "b", "a", "h", "s", "l", "v"];
      var checked = 0;
      var passed = 0;
      forEach(keysToCheck, function(letter) {
        if (data[letter]) {
          checked += 1;
          if (!isNaN(data[letter])) {
            passed += 1;
          }
          if (letter === "s" || letter === "l") {
            var percentPatt = /^\d+%$/;
            if (percentPatt.test(data[letter])) {
              passed += 1;
            }
          }
        }
      });
      return checked === passed ? data : false;
    };
    var toState = function toState2(data, oldHue) {
      var color = data.hex ? tinycolor(data.hex) : tinycolor(data);
      var hsl = color.toHsl();
      var hsv = color.toHsv();
      var rgb = color.toRgb();
      var hex = color.toHex();
      if (hsl.s === 0) {
        hsl.h = oldHue || 0;
        hsv.h = oldHue || 0;
      }
      var transparent = hex === "000000" && rgb.a === 0;
      return {
        hsl,
        hex: transparent ? "transparent" : "#" + hex,
        rgb,
        hsv,
        oldHue: data.h || oldHue || hsl.h,
        source: data.source
      };
    };
    var isValidHex = function isValidHex2(hex) {
      if (hex === "transparent") {
        return true;
      }
      var lh = String(hex).charAt(0) === "#" ? 1 : 0;
      return hex.length !== 4 + lh && hex.length < 7 + lh && tinycolor(hex).isValid();
    };
    var getContrastingColor = function getContrastingColor2(data) {
      if (!data) {
        return "#fff";
      }
      var col = toState(data);
      if (col.hex === "transparent") {
        return "rgba(0,0,0,0.4)";
      }
      var yiq = (col.rgb.r * 299 + col.rgb.g * 587 + col.rgb.b * 114) / 1e3;
      return yiq >= 128 ? "#000" : "#fff";
    };
    var isvalidColorString = function isvalidColorString2(string, type) {
      var stringWithoutDegree = string.replace("°", "");
      return tinycolor(type + " (" + stringWithoutDegree + ")")._ok;
    };
    var _extends$6 = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var _createClass$3 = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck$3(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn$3(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits$3(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var ColorWrap = function ColorWrap2(Picker2) {
      var ColorPicker2 = function(_ref) {
        _inherits$3(ColorPicker3, _ref);
        function ColorPicker3(props) {
          _classCallCheck$3(this, ColorPicker3);
          var _this = _possibleConstructorReturn$3(this, (ColorPicker3.__proto__ || Object.getPrototypeOf(ColorPicker3)).call(this));
          _this.handleChange = function(data, event) {
            var isValidColor = simpleCheckForValidColor(data);
            if (isValidColor) {
              var colors = toState(data, data.h || _this.state.oldHue);
              _this.setState(colors);
              _this.props.onChangeComplete && _this.debounce(_this.props.onChangeComplete, colors, event);
              _this.props.onChange && _this.props.onChange(colors, event);
            }
          };
          _this.handleSwatchHover = function(data, event) {
            var isValidColor = simpleCheckForValidColor(data);
            if (isValidColor) {
              var colors = toState(data, data.h || _this.state.oldHue);
              _this.props.onSwatchHover && _this.props.onSwatchHover(colors, event);
            }
          };
          _this.state = _extends$6({}, toState(props.color, 0));
          _this.debounce = debounce(function(fn, data, event) {
            fn(data, event);
          }, 100);
          return _this;
        }
        _createClass$3(ColorPicker3, [{
          key: "render",
          value: function render2() {
            var optionalEvents = {};
            if (this.props.onSwatchHover) {
              optionalEvents.onSwatchHover = this.handleSwatchHover;
            }
            return React.createElement(Picker2, _extends$6({}, this.props, this.state, {
              onChange: this.handleChange
            }, optionalEvents));
          }
        }], [{
          key: "getDerivedStateFromProps",
          value: function getDerivedStateFromProps(nextProps, state) {
            return _extends$6({}, toState(nextProps.color, state.oldHue));
          }
        }]);
        return ColorPicker3;
      }(reactExports.PureComponent || reactExports.Component);
      ColorPicker2.propTypes = _extends$6({}, Picker2.propTypes);
      ColorPicker2.defaultProps = _extends$6({}, Picker2.defaultProps, {
        color: {
          h: 250,
          s: 0.5,
          l: 0.2,
          a: 1
        }
      });
      return ColorPicker2;
    };
    var _extends$5 = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var _createClass$2 = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck$2(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn$2(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits$2(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var handleFocus = function handleFocus2(Component) {
      var Span = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "span";
      return function(_React$Component) {
        _inherits$2(Focus, _React$Component);
        function Focus() {
          var _ref;
          var _temp, _this, _ret;
          _classCallCheck$2(this, Focus);
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return _ret = (_temp = (_this = _possibleConstructorReturn$2(this, (_ref = Focus.__proto__ || Object.getPrototypeOf(Focus)).call.apply(_ref, [this].concat(args))), _this), _this.state = { focus: false }, _this.handleFocus = function() {
            return _this.setState({ focus: true });
          }, _this.handleBlur = function() {
            return _this.setState({ focus: false });
          }, _temp), _possibleConstructorReturn$2(_this, _ret);
        }
        _createClass$2(Focus, [{
          key: "render",
          value: function render2() {
            return React.createElement(
              Span,
              { onFocus: this.handleFocus, onBlur: this.handleBlur },
              React.createElement(Component, _extends$5({}, this.props, this.state))
            );
          }
        }]);
        return Focus;
      }(React.Component);
    };
    var _extends$4 = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var ENTER = 13;
    var Swatch = function Swatch2(_ref) {
      var color = _ref.color, style = _ref.style, _ref$onClick = _ref.onClick, onClick = _ref$onClick === void 0 ? function() {
      } : _ref$onClick, onHover = _ref.onHover, _ref$title = _ref.title, title = _ref$title === void 0 ? color : _ref$title, children = _ref.children, focus = _ref.focus, _ref$focusStyle = _ref.focusStyle, focusStyle = _ref$focusStyle === void 0 ? {} : _ref$focusStyle;
      var transparent = color === "transparent";
      var styles2 = reactCSS({
        default: {
          swatch: _extends$4({
            background: color,
            height: "100%",
            width: "100%",
            cursor: "pointer",
            position: "relative",
            outline: "none"
          }, style, focus ? focusStyle : {})
        }
      });
      var handleClick = function handleClick2(e) {
        return onClick(color, e);
      };
      var handleKeyDown = function handleKeyDown2(e) {
        return e.keyCode === ENTER && onClick(color, e);
      };
      var handleHover = function handleHover2(e) {
        return onHover(color, e);
      };
      var optionalEvents = {};
      if (onHover) {
        optionalEvents.onMouseOver = handleHover;
      }
      return React.createElement(
        "div",
        _extends$4({
          style: styles2.swatch,
          onClick: handleClick,
          title,
          tabIndex: 0,
          onKeyDown: handleKeyDown
        }, optionalEvents),
        children,
        transparent && React.createElement(Checkboard, {
          borderRadius: styles2.swatch.borderRadius,
          boxShadow: "inset 0 0 0 1px rgba(0,0,0,0.1)"
        })
      );
    };
    const Swatch$1 = handleFocus(Swatch);
    var AlphaPointer = function AlphaPointer2(_ref) {
      var direction = _ref.direction;
      var styles2 = reactCSS({
        "default": {
          picker: {
            width: "18px",
            height: "18px",
            borderRadius: "50%",
            transform: "translate(-9px, -1px)",
            backgroundColor: "rgb(248, 248, 248)",
            boxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.37)"
          }
        },
        "vertical": {
          picker: {
            transform: "translate(-3px, -9px)"
          }
        }
      }, { vertical: direction === "vertical" });
      return React.createElement("div", { style: styles2.picker });
    };
    var _extends$3 = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var AlphaPicker = function AlphaPicker2(_ref) {
      var rgb = _ref.rgb, hsl = _ref.hsl, width = _ref.width, height = _ref.height, onChange = _ref.onChange, direction = _ref.direction, style = _ref.style, renderers = _ref.renderers, pointer = _ref.pointer, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
      var styles2 = reactCSS({
        "default": {
          picker: {
            position: "relative",
            width,
            height
          },
          alpha: {
            radius: "2px",
            style
          }
        }
      });
      return React.createElement(
        "div",
        { style: styles2.picker, className: "alpha-picker " + className },
        React.createElement(Alpha, _extends$3({}, styles2.alpha, {
          rgb,
          hsl,
          pointer,
          renderers,
          onChange,
          direction
        }))
      );
    };
    AlphaPicker.defaultProps = {
      width: "316px",
      height: "16px",
      direction: "horizontal",
      pointer: AlphaPointer
    };
    ColorWrap(AlphaPicker);
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    function setCacheAdd(value2) {
      this.__data__.set(value2, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value2) {
      return this.__data__.has(value2);
    }
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function mapToArray(map2) {
      var index = -1, result = Array(map2.size);
      map2.forEach(function(value2, key) {
        result[++index] = [key, value2];
      });
      return result;
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value2) {
        result[++index] = value2;
      });
      return result;
    }
    var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
    var boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$1 = "[object Error]", mapTag$4 = "[object Map]", numberTag$2 = "[object Number]", regexpTag$2 = "[object RegExp]", setTag$4 = "[object Set]", stringTag$2 = "[object String]", symbolTag$2 = "[object Symbol]";
    var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$3 = "[object DataView]";
    var symbolProto$2 = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : void 0;
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag$3:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag$2:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag$2:
        case dateTag$2:
        case numberTag$2:
          return eq(+object, +other);
        case errorTag$1:
          return object.name == other.name && object.message == other.message;
        case regexpTag$2:
        case stringTag$2:
          return object == other + "";
        case mapTag$4:
          var convert = mapToArray;
        case setTag$4:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG$2;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag$2:
          if (symbolValueOf$1) {
            return symbolValueOf$1.call(object) == symbolValueOf$1.call(other);
          }
      }
      return false;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value2 = array[index];
        if (predicate(value2, index, array)) {
          result[resIndex++] = value2;
        }
      }
      return result;
    }
    function stubArray() {
      return [];
    }
    var objectProto$3 = Object.prototype;
    var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
    var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
    var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    var COMPARE_PARTIAL_FLAG$3 = 1;
    var objectProto$2 = Object.prototype;
    var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty$2.call(other, key))) {
          return false;
        }
      }
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    var DataView = getNative(root, "DataView");
    var Promise$1 = getNative(root, "Promise");
    var Set$1 = getNative(root, "Set");
    var WeakMap$1 = getNative(root, "WeakMap");
    var mapTag$3 = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag$3 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
    var dataViewTag$2 = "[object DataView]";
    var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$2 || Map$1 && getTag(new Map$1()) != mapTag$3 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$3 || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag$1) {
      getTag = function(value2) {
        var result = baseGetTag(value2), Ctor = result == objectTag$2 ? value2.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag$2;
            case mapCtorString:
              return mapTag$3;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag$3;
            case weakMapCtorString:
              return weakMapTag$1;
          }
        }
        return result;
      };
    }
    var COMPARE_PARTIAL_FLAG$2 = 1;
    var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", objectTag$1 = "[object Object]";
    var objectProto$1 = Object.prototype;
    var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag$1 : getTag(object), othTag = othIsArr ? arrayTag$1 : getTag(other);
      objTag = objTag == argsTag$1 ? objectTag$1 : objTag;
      othTag = othTag == argsTag$1 ? objectTag$1 : othTag;
      var objIsObj = objTag == objectTag$1, othIsObj = othTag == objectTag$1, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
        var objIsWrapped = objIsObj && hasOwnProperty$1.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$1.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    function baseIsEqual(value2, other, bitmask, customizer, stack) {
      if (value2 === other) {
        return true;
      }
      if (value2 == null || other == null || !isObjectLike(value2) && !isObjectLike(other)) {
        return value2 !== value2 && other !== other;
      }
      return baseIsEqualDeep(value2, other, bitmask, customizer, baseIsEqual, stack);
    }
    var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length = index;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (data[2]) {
          if (objValue === void 0 && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          var result;
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    function isStrictComparable(value2) {
      return value2 === value2 && !isObject(value2);
    }
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key = result[length], value2 = object[key];
        result[length] = [key, value2, isStrictComparable(value2)];
      }
      return result;
    }
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
      };
    }
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
    function isKey(value2, object) {
      if (isArray(value2)) {
        return false;
      }
      var type = typeof value2;
      if (type == "number" || type == "symbol" || type == "boolean" || value2 == null || isSymbol(value2)) {
        return true;
      }
      return reIsPlainProp.test(value2) || !reIsDeepProp.test(value2) || object != null && value2 in Object(object);
    }
    var FUNC_ERROR_TEXT = "Expected a function";
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    var MAX_MEMOIZE_SIZE = 500;
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });
      var cache = result.cache;
      return result;
    }
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46) {
        result.push("");
      }
      string.replace(rePropName, function(match2, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match2);
      });
      return result;
    });
    var INFINITY$1 = 1 / 0;
    var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
    function baseToString(value2) {
      if (typeof value2 == "string") {
        return value2;
      }
      if (isArray(value2)) {
        return arrayMap(value2, baseToString) + "";
      }
      if (isSymbol(value2)) {
        return symbolToString ? symbolToString.call(value2) : "";
      }
      var result = value2 + "";
      return result == "0" && 1 / value2 == -INFINITY$1 ? "-0" : result;
    }
    function toString(value2) {
      return value2 == null ? "" : baseToString(value2);
    }
    function castPath(value2, object) {
      if (isArray(value2)) {
        return value2;
      }
      return isKey(value2, object) ? [value2] : stringToPath(toString(value2));
    }
    var INFINITY = 1 / 0;
    function toKey(value2) {
      if (typeof value2 == "string" || isSymbol(value2)) {
        return value2;
      }
      var result = value2 + "";
      return result == "0" && 1 / value2 == -INFINITY ? "-0" : result;
    }
    function baseGet(object, path) {
      path = castPath(path, object);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    function get(object, path, defaultValue2) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue2 : result;
    }
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);
      var index = -1, length = path.length, result = false;
      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
    }
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? void 0 : object[key];
      };
    }
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    function baseIteratee(value2) {
      if (typeof value2 == "function") {
        return value2;
      }
      if (value2 == null) {
        return identity;
      }
      if (typeof value2 == "object") {
        return isArray(value2) ? baseMatchesProperty(value2[0], value2[1]) : baseMatches(value2);
      }
      return property(value2);
    }
    function baseMap(collection, iteratee) {
      var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
      baseEach(collection, function(value2, key, collection2) {
        result[++index] = iteratee(value2, key, collection2);
      });
      return result;
    }
    function map(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, baseIteratee(iteratee));
    }
    var BlockSwatches = function BlockSwatches2(_ref) {
      var colors = _ref.colors, onClick = _ref.onClick, onSwatchHover = _ref.onSwatchHover;
      var styles2 = reactCSS({
        "default": {
          swatches: {
            marginRight: "-10px"
          },
          swatch: {
            width: "22px",
            height: "22px",
            float: "left",
            marginRight: "10px",
            marginBottom: "10px",
            borderRadius: "4px"
          },
          clear: {
            clear: "both"
          }
        }
      });
      return React.createElement(
        "div",
        { style: styles2.swatches },
        map(colors, function(c) {
          return React.createElement(Swatch$1, {
            key: c,
            color: c,
            style: styles2.swatch,
            onClick,
            onHover: onSwatchHover,
            focusStyle: {
              boxShadow: "0 0 4px " + c
            }
          });
        }),
        React.createElement("div", { style: styles2.clear })
      );
    };
    var Block$1 = function Block2(_ref) {
      var onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, hex = _ref.hex, colors = _ref.colors, width = _ref.width, triangle = _ref.triangle, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
      var transparent = hex === "transparent";
      var handleChange = function handleChange2(hexCode, e) {
        isValidHex(hexCode) && onChange({
          hex: hexCode,
          source: "hex"
        }, e);
      };
      var styles2 = reactCSS(merge({
        "default": {
          card: {
            width,
            background: "#fff",
            boxShadow: "0 1px rgba(0,0,0,.1)",
            borderRadius: "6px",
            position: "relative"
          },
          head: {
            height: "110px",
            background: hex,
            borderRadius: "6px 6px 0 0",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            position: "relative"
          },
          body: {
            padding: "10px"
          },
          label: {
            fontSize: "18px",
            color: getContrastingColor(hex),
            position: "relative"
          },
          triangle: {
            width: "0px",
            height: "0px",
            borderStyle: "solid",
            borderWidth: "0 10px 10px 10px",
            borderColor: "transparent transparent " + hex + " transparent",
            position: "absolute",
            top: "-10px",
            left: "50%",
            marginLeft: "-10px"
          },
          input: {
            width: "100%",
            fontSize: "12px",
            color: "#666",
            border: "0px",
            outline: "none",
            height: "22px",
            boxShadow: "inset 0 0 0 1px #ddd",
            borderRadius: "4px",
            padding: "0 7px",
            boxSizing: "border-box"
          }
        },
        "hide-triangle": {
          triangle: {
            display: "none"
          }
        }
      }, passedStyles), { "hide-triangle": triangle === "hide" });
      return React.createElement(
        "div",
        { style: styles2.card, className: "block-picker " + className },
        React.createElement("div", { style: styles2.triangle }),
        React.createElement(
          "div",
          { style: styles2.head },
          transparent && React.createElement(Checkboard, { borderRadius: "6px 6px 0 0" }),
          React.createElement(
            "div",
            { style: styles2.label },
            hex
          )
        ),
        React.createElement(
          "div",
          { style: styles2.body },
          React.createElement(BlockSwatches, { colors, onClick: handleChange, onSwatchHover }),
          React.createElement(EditableInput, {
            style: { input: styles2.input },
            value: hex,
            onChange: handleChange
          })
        )
      );
    };
    Block$1.propTypes = {
      width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
      colors: PropTypes.arrayOf(PropTypes.string),
      triangle: PropTypes.oneOf(["top", "hide"]),
      styles: PropTypes.object
    };
    Block$1.defaultProps = {
      width: 170,
      colors: ["#D9E3F0", "#F47373", "#697689", "#37D67A", "#2CCCE4", "#555555", "#dce775", "#ff8a65", "#ba68c8"],
      triangle: "top",
      styles: {}
    };
    ColorWrap(Block$1);
    var red = { "50": "#ffebee", "100": "#ffcdd2", "200": "#ef9a9a", "300": "#e57373", "400": "#ef5350", "500": "#f44336", "600": "#e53935", "700": "#d32f2f", "800": "#c62828", "900": "#b71c1c", "a100": "#ff8a80", "a200": "#ff5252", "a400": "#ff1744", "a700": "#d50000" };
    var pink = { "50": "#fce4ec", "100": "#f8bbd0", "200": "#f48fb1", "300": "#f06292", "400": "#ec407a", "500": "#e91e63", "600": "#d81b60", "700": "#c2185b", "800": "#ad1457", "900": "#880e4f", "a100": "#ff80ab", "a200": "#ff4081", "a400": "#f50057", "a700": "#c51162" };
    var purple = { "50": "#f3e5f5", "100": "#e1bee7", "200": "#ce93d8", "300": "#ba68c8", "400": "#ab47bc", "500": "#9c27b0", "600": "#8e24aa", "700": "#7b1fa2", "800": "#6a1b9a", "900": "#4a148c", "a100": "#ea80fc", "a200": "#e040fb", "a400": "#d500f9", "a700": "#aa00ff" };
    var deepPurple = { "50": "#ede7f6", "100": "#d1c4e9", "200": "#b39ddb", "300": "#9575cd", "400": "#7e57c2", "500": "#673ab7", "600": "#5e35b1", "700": "#512da8", "800": "#4527a0", "900": "#311b92", "a100": "#b388ff", "a200": "#7c4dff", "a400": "#651fff", "a700": "#6200ea" };
    var indigo = { "50": "#e8eaf6", "100": "#c5cae9", "200": "#9fa8da", "300": "#7986cb", "400": "#5c6bc0", "500": "#3f51b5", "600": "#3949ab", "700": "#303f9f", "800": "#283593", "900": "#1a237e", "a100": "#8c9eff", "a200": "#536dfe", "a400": "#3d5afe", "a700": "#304ffe" };
    var blue = { "50": "#e3f2fd", "100": "#bbdefb", "200": "#90caf9", "300": "#64b5f6", "400": "#42a5f5", "500": "#2196f3", "600": "#1e88e5", "700": "#1976d2", "800": "#1565c0", "900": "#0d47a1", "a100": "#82b1ff", "a200": "#448aff", "a400": "#2979ff", "a700": "#2962ff" };
    var lightBlue = { "50": "#e1f5fe", "100": "#b3e5fc", "200": "#81d4fa", "300": "#4fc3f7", "400": "#29b6f6", "500": "#03a9f4", "600": "#039be5", "700": "#0288d1", "800": "#0277bd", "900": "#01579b", "a100": "#80d8ff", "a200": "#40c4ff", "a400": "#00b0ff", "a700": "#0091ea" };
    var cyan = { "50": "#e0f7fa", "100": "#b2ebf2", "200": "#80deea", "300": "#4dd0e1", "400": "#26c6da", "500": "#00bcd4", "600": "#00acc1", "700": "#0097a7", "800": "#00838f", "900": "#006064", "a100": "#84ffff", "a200": "#18ffff", "a400": "#00e5ff", "a700": "#00b8d4" };
    var teal = { "50": "#e0f2f1", "100": "#b2dfdb", "200": "#80cbc4", "300": "#4db6ac", "400": "#26a69a", "500": "#009688", "600": "#00897b", "700": "#00796b", "800": "#00695c", "900": "#004d40", "a100": "#a7ffeb", "a200": "#64ffda", "a400": "#1de9b6", "a700": "#00bfa5" };
    var green = { "50": "#e8f5e9", "100": "#c8e6c9", "200": "#a5d6a7", "300": "#81c784", "400": "#66bb6a", "500": "#4caf50", "600": "#43a047", "700": "#388e3c", "800": "#2e7d32", "900": "#1b5e20", "a100": "#b9f6ca", "a200": "#69f0ae", "a400": "#00e676", "a700": "#00c853" };
    var lightGreen = { "50": "#f1f8e9", "100": "#dcedc8", "200": "#c5e1a5", "300": "#aed581", "400": "#9ccc65", "500": "#8bc34a", "600": "#7cb342", "700": "#689f38", "800": "#558b2f", "900": "#33691e", "a100": "#ccff90", "a200": "#b2ff59", "a400": "#76ff03", "a700": "#64dd17" };
    var lime = { "50": "#f9fbe7", "100": "#f0f4c3", "200": "#e6ee9c", "300": "#dce775", "400": "#d4e157", "500": "#cddc39", "600": "#c0ca33", "700": "#afb42b", "800": "#9e9d24", "900": "#827717", "a100": "#f4ff81", "a200": "#eeff41", "a400": "#c6ff00", "a700": "#aeea00" };
    var yellow = { "50": "#fffde7", "100": "#fff9c4", "200": "#fff59d", "300": "#fff176", "400": "#ffee58", "500": "#ffeb3b", "600": "#fdd835", "700": "#fbc02d", "800": "#f9a825", "900": "#f57f17", "a100": "#ffff8d", "a200": "#ffff00", "a400": "#ffea00", "a700": "#ffd600" };
    var amber = { "50": "#fff8e1", "100": "#ffecb3", "200": "#ffe082", "300": "#ffd54f", "400": "#ffca28", "500": "#ffc107", "600": "#ffb300", "700": "#ffa000", "800": "#ff8f00", "900": "#ff6f00", "a100": "#ffe57f", "a200": "#ffd740", "a400": "#ffc400", "a700": "#ffab00" };
    var orange = { "50": "#fff3e0", "100": "#ffe0b2", "200": "#ffcc80", "300": "#ffb74d", "400": "#ffa726", "500": "#ff9800", "600": "#fb8c00", "700": "#f57c00", "800": "#ef6c00", "900": "#e65100", "a100": "#ffd180", "a200": "#ffab40", "a400": "#ff9100", "a700": "#ff6d00" };
    var deepOrange = { "50": "#fbe9e7", "100": "#ffccbc", "200": "#ffab91", "300": "#ff8a65", "400": "#ff7043", "500": "#ff5722", "600": "#f4511e", "700": "#e64a19", "800": "#d84315", "900": "#bf360c", "a100": "#ff9e80", "a200": "#ff6e40", "a400": "#ff3d00", "a700": "#dd2c00" };
    var brown = { "50": "#efebe9", "100": "#d7ccc8", "200": "#bcaaa4", "300": "#a1887f", "400": "#8d6e63", "500": "#795548", "600": "#6d4c41", "700": "#5d4037", "800": "#4e342e", "900": "#3e2723" };
    var blueGrey = { "50": "#eceff1", "100": "#cfd8dc", "200": "#b0bec5", "300": "#90a4ae", "400": "#78909c", "500": "#607d8b", "600": "#546e7a", "700": "#455a64", "800": "#37474f", "900": "#263238" };
    var CircleSwatch = function CircleSwatch2(_ref) {
      var color = _ref.color, onClick = _ref.onClick, onSwatchHover = _ref.onSwatchHover, hover2 = _ref.hover, active2 = _ref.active, circleSize = _ref.circleSize, circleSpacing = _ref.circleSpacing;
      var styles2 = reactCSS({
        "default": {
          swatch: {
            width: circleSize,
            height: circleSize,
            marginRight: circleSpacing,
            marginBottom: circleSpacing,
            transform: "scale(1)",
            transition: "100ms transform ease"
          },
          Swatch: {
            borderRadius: "50%",
            background: "transparent",
            boxShadow: "inset 0 0 0 " + (circleSize / 2 + 1) + "px " + color,
            transition: "100ms box-shadow ease"
          }
        },
        "hover": {
          swatch: {
            transform: "scale(1.2)"
          }
        },
        "active": {
          Swatch: {
            boxShadow: "inset 0 0 0 3px " + color
          }
        }
      }, { hover: hover2, active: active2 });
      return React.createElement(
        "div",
        { style: styles2.swatch },
        React.createElement(Swatch$1, {
          style: styles2.Swatch,
          color,
          onClick,
          onHover: onSwatchHover,
          focusStyle: { boxShadow: styles2.Swatch.boxShadow + ", 0 0 5px " + color }
        })
      );
    };
    CircleSwatch.defaultProps = {
      circleSize: 28,
      circleSpacing: 14
    };
    const CircleSwatch$1 = libExports.handleHover(CircleSwatch);
    var Circle = function Circle2(_ref) {
      var width = _ref.width, onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, colors = _ref.colors, hex = _ref.hex, circleSize = _ref.circleSize, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, circleSpacing = _ref.circleSpacing, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
      var styles2 = reactCSS(merge({
        "default": {
          card: {
            width,
            display: "flex",
            flexWrap: "wrap",
            marginRight: -circleSpacing,
            marginBottom: -circleSpacing
          }
        }
      }, passedStyles));
      var handleChange = function handleChange2(hexCode, e) {
        return onChange({ hex: hexCode, source: "hex" }, e);
      };
      return React.createElement(
        "div",
        { style: styles2.card, className: "circle-picker " + className },
        map(colors, function(c) {
          return React.createElement(CircleSwatch$1, {
            key: c,
            color: c,
            onClick: handleChange,
            onSwatchHover,
            active: hex === c.toLowerCase(),
            circleSize,
            circleSpacing
          });
        })
      );
    };
    Circle.propTypes = {
      width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
      circleSize: PropTypes.number,
      circleSpacing: PropTypes.number,
      styles: PropTypes.object
    };
    Circle.defaultProps = {
      width: 252,
      circleSize: 28,
      circleSpacing: 14,
      colors: [red["500"], pink["500"], purple["500"], deepPurple["500"], indigo["500"], blue["500"], lightBlue["500"], cyan["500"], teal["500"], green["500"], lightGreen["500"], lime["500"], yellow["500"], amber["500"], orange["500"], deepOrange["500"], brown["500"], blueGrey["500"]],
      styles: {}
    };
    ColorWrap(Circle);
    function isUndefined(value2) {
      return value2 === void 0;
    }
    var UnfoldMoreHorizontalIcon$1 = {};
    var hasRequiredUnfoldMoreHorizontalIcon;
    function requireUnfoldMoreHorizontalIcon() {
      if (hasRequiredUnfoldMoreHorizontalIcon) return UnfoldMoreHorizontalIcon$1;
      hasRequiredUnfoldMoreHorizontalIcon = 1;
      Object.defineProperty(UnfoldMoreHorizontalIcon$1, "__esModule", {
        value: true
      });
      var _extends2 = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      var _react = requireReact();
      var _react2 = _interopRequireDefault(_react);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function _objectWithoutProperties(obj, keys2) {
        var target = {};
        for (var i in obj) {
          if (keys2.indexOf(i) >= 0) continue;
          if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
          target[i] = obj[i];
        }
        return target;
      }
      var DEFAULT_SIZE = 24;
      UnfoldMoreHorizontalIcon$1.default = function(_ref) {
        var _ref$fill = _ref.fill, fill = _ref$fill === void 0 ? "currentColor" : _ref$fill, _ref$width = _ref.width, width = _ref$width === void 0 ? DEFAULT_SIZE : _ref$width, _ref$height = _ref.height, height = _ref$height === void 0 ? DEFAULT_SIZE : _ref$height, _ref$style = _ref.style, style = _ref$style === void 0 ? {} : _ref$style, props = _objectWithoutProperties(_ref, ["fill", "width", "height", "style"]);
        return _react2.default.createElement(
          "svg",
          _extends2({
            viewBox: "0 0 " + DEFAULT_SIZE + " " + DEFAULT_SIZE,
            style: _extends2({ fill, width, height }, style)
          }, props),
          _react2.default.createElement("path", { d: "M12,18.17L8.83,15L7.42,16.41L12,21L16.59,16.41L15.17,15M12,5.83L15.17,9L16.58,7.59L12,3L7.41,7.59L8.83,9L12,5.83Z" })
        );
      };
      return UnfoldMoreHorizontalIcon$1;
    }
    var UnfoldMoreHorizontalIconExports = requireUnfoldMoreHorizontalIcon();
    const UnfoldMoreHorizontalIcon = /* @__PURE__ */ getDefaultExportFromCjs(UnfoldMoreHorizontalIconExports);
    var _createClass$1 = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck$1(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn$1(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits$1(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var ChromeFields = function(_React$Component) {
      _inherits$1(ChromeFields2, _React$Component);
      function ChromeFields2(props) {
        _classCallCheck$1(this, ChromeFields2);
        var _this = _possibleConstructorReturn$1(this, (ChromeFields2.__proto__ || Object.getPrototypeOf(ChromeFields2)).call(this));
        _this.toggleViews = function() {
          if (_this.state.view === "hex") {
            _this.setState({ view: "rgb" });
          } else if (_this.state.view === "rgb") {
            _this.setState({ view: "hsl" });
          } else if (_this.state.view === "hsl") {
            if (_this.props.hsl.a === 1) {
              _this.setState({ view: "hex" });
            } else {
              _this.setState({ view: "rgb" });
            }
          }
        };
        _this.handleChange = function(data, e) {
          if (data.hex) {
            isValidHex(data.hex) && _this.props.onChange({
              hex: data.hex,
              source: "hex"
            }, e);
          } else if (data.r || data.g || data.b) {
            _this.props.onChange({
              r: data.r || _this.props.rgb.r,
              g: data.g || _this.props.rgb.g,
              b: data.b || _this.props.rgb.b,
              source: "rgb"
            }, e);
          } else if (data.a) {
            if (data.a < 0) {
              data.a = 0;
            } else if (data.a > 1) {
              data.a = 1;
            }
            _this.props.onChange({
              h: _this.props.hsl.h,
              s: _this.props.hsl.s,
              l: _this.props.hsl.l,
              a: Math.round(data.a * 100) / 100,
              source: "rgb"
            }, e);
          } else if (data.h || data.s || data.l) {
            if (typeof data.s === "string" && data.s.includes("%")) {
              data.s = data.s.replace("%", "");
            }
            if (typeof data.l === "string" && data.l.includes("%")) {
              data.l = data.l.replace("%", "");
            }
            if (data.s == 1) {
              data.s = 0.01;
            } else if (data.l == 1) {
              data.l = 0.01;
            }
            _this.props.onChange({
              h: data.h || _this.props.hsl.h,
              s: Number(!isUndefined(data.s) ? data.s : _this.props.hsl.s),
              l: Number(!isUndefined(data.l) ? data.l : _this.props.hsl.l),
              source: "hsl"
            }, e);
          }
        };
        _this.showHighlight = function(e) {
          e.currentTarget.style.background = "#eee";
        };
        _this.hideHighlight = function(e) {
          e.currentTarget.style.background = "transparent";
        };
        if (props.hsl.a !== 1 && props.view === "hex") {
          _this.state = {
            view: "rgb"
          };
        } else {
          _this.state = {
            view: props.view
          };
        }
        return _this;
      }
      _createClass$1(ChromeFields2, [{
        key: "render",
        value: function render2() {
          var _this2 = this;
          var styles2 = reactCSS({
            "default": {
              wrap: {
                paddingTop: "16px",
                display: "flex"
              },
              fields: {
                flex: "1",
                display: "flex",
                marginLeft: "-6px"
              },
              field: {
                paddingLeft: "6px",
                width: "100%"
              },
              alpha: {
                paddingLeft: "6px",
                width: "100%"
              },
              toggle: {
                width: "32px",
                textAlign: "right",
                position: "relative"
              },
              icon: {
                marginRight: "-4px",
                marginTop: "12px",
                cursor: "pointer",
                position: "relative"
              },
              iconHighlight: {
                position: "absolute",
                width: "24px",
                height: "28px",
                background: "#eee",
                borderRadius: "4px",
                top: "10px",
                left: "12px",
                display: "none"
              },
              input: {
                fontSize: "11px",
                color: "#333",
                width: "100%",
                borderRadius: "2px",
                border: "none",
                boxShadow: "inset 0 0 0 1px #dadada",
                height: "21px",
                textAlign: "center"
              },
              label: {
                textTransform: "uppercase",
                fontSize: "11px",
                lineHeight: "11px",
                color: "#969696",
                textAlign: "center",
                display: "block",
                marginTop: "12px"
              },
              svg: {
                fill: "#333",
                width: "24px",
                height: "24px",
                border: "1px transparent solid",
                borderRadius: "5px"
              }
            },
            "disableAlpha": {
              alpha: {
                display: "none"
              }
            }
          }, this.props, this.state);
          var fields = void 0;
          if (this.state.view === "hex") {
            fields = React.createElement(
              "div",
              { style: styles2.fields, className: "flexbox-fix" },
              React.createElement(
                "div",
                { style: styles2.field },
                React.createElement(EditableInput, {
                  style: { input: styles2.input, label: styles2.label },
                  label: "hex",
                  value: this.props.hex,
                  onChange: this.handleChange
                })
              )
            );
          } else if (this.state.view === "rgb") {
            fields = React.createElement(
              "div",
              { style: styles2.fields, className: "flexbox-fix" },
              React.createElement(
                "div",
                { style: styles2.field },
                React.createElement(EditableInput, {
                  style: { input: styles2.input, label: styles2.label },
                  label: "r",
                  value: this.props.rgb.r,
                  onChange: this.handleChange
                })
              ),
              React.createElement(
                "div",
                { style: styles2.field },
                React.createElement(EditableInput, {
                  style: { input: styles2.input, label: styles2.label },
                  label: "g",
                  value: this.props.rgb.g,
                  onChange: this.handleChange
                })
              ),
              React.createElement(
                "div",
                { style: styles2.field },
                React.createElement(EditableInput, {
                  style: { input: styles2.input, label: styles2.label },
                  label: "b",
                  value: this.props.rgb.b,
                  onChange: this.handleChange
                })
              ),
              React.createElement(
                "div",
                { style: styles2.alpha },
                React.createElement(EditableInput, {
                  style: { input: styles2.input, label: styles2.label },
                  label: "a",
                  value: this.props.rgb.a,
                  arrowOffset: 0.01,
                  onChange: this.handleChange
                })
              )
            );
          } else if (this.state.view === "hsl") {
            fields = React.createElement(
              "div",
              { style: styles2.fields, className: "flexbox-fix" },
              React.createElement(
                "div",
                { style: styles2.field },
                React.createElement(EditableInput, {
                  style: { input: styles2.input, label: styles2.label },
                  label: "h",
                  value: Math.round(this.props.hsl.h),
                  onChange: this.handleChange
                })
              ),
              React.createElement(
                "div",
                { style: styles2.field },
                React.createElement(EditableInput, {
                  style: { input: styles2.input, label: styles2.label },
                  label: "s",
                  value: Math.round(this.props.hsl.s * 100) + "%",
                  onChange: this.handleChange
                })
              ),
              React.createElement(
                "div",
                { style: styles2.field },
                React.createElement(EditableInput, {
                  style: { input: styles2.input, label: styles2.label },
                  label: "l",
                  value: Math.round(this.props.hsl.l * 100) + "%",
                  onChange: this.handleChange
                })
              ),
              React.createElement(
                "div",
                { style: styles2.alpha },
                React.createElement(EditableInput, {
                  style: { input: styles2.input, label: styles2.label },
                  label: "a",
                  value: this.props.hsl.a,
                  arrowOffset: 0.01,
                  onChange: this.handleChange
                })
              )
            );
          }
          return React.createElement(
            "div",
            { style: styles2.wrap, className: "flexbox-fix" },
            fields,
            React.createElement(
              "div",
              { style: styles2.toggle },
              React.createElement(
                "div",
                { style: styles2.icon, onClick: this.toggleViews, ref: function ref(icon2) {
                  return _this2.icon = icon2;
                } },
                React.createElement(UnfoldMoreHorizontalIcon, {
                  style: styles2.svg,
                  onMouseOver: this.showHighlight,
                  onMouseEnter: this.showHighlight,
                  onMouseOut: this.hideHighlight
                })
              )
            )
          );
        }
      }], [{
        key: "getDerivedStateFromProps",
        value: function getDerivedStateFromProps(nextProps, state) {
          if (nextProps.hsl.a !== 1 && state.view === "hex") {
            return { view: "rgb" };
          }
          return null;
        }
      }]);
      return ChromeFields2;
    }(React.Component);
    ChromeFields.defaultProps = {
      view: "hex"
    };
    var ChromePointer = function ChromePointer2() {
      var styles2 = reactCSS({
        "default": {
          picker: {
            width: "12px",
            height: "12px",
            borderRadius: "6px",
            transform: "translate(-6px, -1px)",
            backgroundColor: "rgb(248, 248, 248)",
            boxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.37)"
          }
        }
      });
      return React.createElement("div", { style: styles2.picker });
    };
    var ChromePointerCircle = function ChromePointerCircle2() {
      var styles2 = reactCSS({
        "default": {
          picker: {
            width: "12px",
            height: "12px",
            borderRadius: "6px",
            boxShadow: "inset 0 0 0 1px #fff",
            transform: "translate(-6px, -6px)"
          }
        }
      });
      return React.createElement("div", { style: styles2.picker });
    };
    var Chrome = function Chrome2(_ref) {
      var width = _ref.width, onChange = _ref.onChange, disableAlpha = _ref.disableAlpha, rgb = _ref.rgb, hsl = _ref.hsl, hsv = _ref.hsv, hex = _ref.hex, renderers = _ref.renderers, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className, defaultView = _ref.defaultView;
      var styles2 = reactCSS(merge({
        "default": {
          picker: {
            width,
            background: "#fff",
            borderRadius: "2px",
            boxShadow: "0 0 2px rgba(0,0,0,.3), 0 4px 8px rgba(0,0,0,.3)",
            boxSizing: "initial",
            fontFamily: "Menlo"
          },
          saturation: {
            width: "100%",
            paddingBottom: "55%",
            position: "relative",
            borderRadius: "2px 2px 0 0",
            overflow: "hidden"
          },
          Saturation: {
            radius: "2px 2px 0 0"
          },
          body: {
            padding: "16px 16px 12px"
          },
          controls: {
            display: "flex"
          },
          color: {
            width: "32px"
          },
          swatch: {
            marginTop: "6px",
            width: "16px",
            height: "16px",
            borderRadius: "8px",
            position: "relative",
            overflow: "hidden"
          },
          active: {
            absolute: "0px 0px 0px 0px",
            borderRadius: "8px",
            boxShadow: "inset 0 0 0 1px rgba(0,0,0,.1)",
            background: "rgba(" + rgb.r + ", " + rgb.g + ", " + rgb.b + ", " + rgb.a + ")",
            zIndex: "2"
          },
          toggles: {
            flex: "1"
          },
          hue: {
            height: "10px",
            position: "relative",
            marginBottom: "8px"
          },
          Hue: {
            radius: "2px"
          },
          alpha: {
            height: "10px",
            position: "relative"
          },
          Alpha: {
            radius: "2px"
          }
        },
        "disableAlpha": {
          color: {
            width: "22px"
          },
          alpha: {
            display: "none"
          },
          hue: {
            marginBottom: "0px"
          },
          swatch: {
            width: "10px",
            height: "10px",
            marginTop: "0px"
          }
        }
      }, passedStyles), { disableAlpha });
      return React.createElement(
        "div",
        { style: styles2.picker, className: "chrome-picker " + className },
        React.createElement(
          "div",
          { style: styles2.saturation },
          React.createElement(Saturation, {
            style: styles2.Saturation,
            hsl,
            hsv,
            pointer: ChromePointerCircle,
            onChange
          })
        ),
        React.createElement(
          "div",
          { style: styles2.body },
          React.createElement(
            "div",
            { style: styles2.controls, className: "flexbox-fix" },
            React.createElement(
              "div",
              { style: styles2.color },
              React.createElement(
                "div",
                { style: styles2.swatch },
                React.createElement("div", { style: styles2.active }),
                React.createElement(Checkboard, { renderers })
              )
            ),
            React.createElement(
              "div",
              { style: styles2.toggles },
              React.createElement(
                "div",
                { style: styles2.hue },
                React.createElement(Hue, {
                  style: styles2.Hue,
                  hsl,
                  pointer: ChromePointer,
                  onChange
                })
              ),
              React.createElement(
                "div",
                { style: styles2.alpha },
                React.createElement(Alpha, {
                  style: styles2.Alpha,
                  rgb,
                  hsl,
                  pointer: ChromePointer,
                  renderers,
                  onChange
                })
              )
            )
          ),
          React.createElement(ChromeFields, {
            rgb,
            hsl,
            hex,
            view: defaultView,
            onChange,
            disableAlpha
          })
        )
      );
    };
    Chrome.propTypes = {
      width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
      disableAlpha: PropTypes.bool,
      styles: PropTypes.object,
      defaultView: PropTypes.oneOf(["hex", "rgb", "hsl"])
    };
    Chrome.defaultProps = {
      width: 225,
      disableAlpha: false,
      styles: {}
    };
    const ChromePicker = ColorWrap(Chrome);
    var CompactColor = function CompactColor2(_ref) {
      var color = _ref.color, _ref$onClick = _ref.onClick, onClick = _ref$onClick === void 0 ? function() {
      } : _ref$onClick, onSwatchHover = _ref.onSwatchHover, active2 = _ref.active;
      var styles2 = reactCSS({
        "default": {
          color: {
            background: color,
            width: "15px",
            height: "15px",
            float: "left",
            marginRight: "5px",
            marginBottom: "5px",
            position: "relative",
            cursor: "pointer"
          },
          dot: {
            absolute: "5px 5px 5px 5px",
            background: getContrastingColor(color),
            borderRadius: "50%",
            opacity: "0"
          }
        },
        "active": {
          dot: {
            opacity: "1"
          }
        },
        "color-#FFFFFF": {
          color: {
            boxShadow: "inset 0 0 0 1px #ddd"
          },
          dot: {
            background: "#000"
          }
        },
        "transparent": {
          dot: {
            background: "#000"
          }
        }
      }, { active: active2, "color-#FFFFFF": color === "#FFFFFF", "transparent": color === "transparent" });
      return React.createElement(
        Swatch$1,
        {
          style: styles2.color,
          color,
          onClick,
          onHover: onSwatchHover,
          focusStyle: { boxShadow: "0 0 4px " + color }
        },
        React.createElement("div", { style: styles2.dot })
      );
    };
    var CompactFields = function CompactFields2(_ref) {
      var hex = _ref.hex, rgb = _ref.rgb, onChange = _ref.onChange;
      var styles2 = reactCSS({
        "default": {
          fields: {
            display: "flex",
            paddingBottom: "6px",
            paddingRight: "5px",
            position: "relative"
          },
          active: {
            position: "absolute",
            top: "6px",
            left: "5px",
            height: "9px",
            width: "9px",
            background: hex
          },
          HEXwrap: {
            flex: "6",
            position: "relative"
          },
          HEXinput: {
            width: "80%",
            padding: "0px",
            paddingLeft: "20%",
            border: "none",
            outline: "none",
            background: "none",
            fontSize: "12px",
            color: "#333",
            height: "16px"
          },
          HEXlabel: {
            display: "none"
          },
          RGBwrap: {
            flex: "3",
            position: "relative"
          },
          RGBinput: {
            width: "70%",
            padding: "0px",
            paddingLeft: "30%",
            border: "none",
            outline: "none",
            background: "none",
            fontSize: "12px",
            color: "#333",
            height: "16px"
          },
          RGBlabel: {
            position: "absolute",
            top: "3px",
            left: "0px",
            lineHeight: "16px",
            textTransform: "uppercase",
            fontSize: "12px",
            color: "#999"
          }
        }
      });
      var handleChange = function handleChange2(data, e) {
        if (data.r || data.g || data.b) {
          onChange({
            r: data.r || rgb.r,
            g: data.g || rgb.g,
            b: data.b || rgb.b,
            source: "rgb"
          }, e);
        } else {
          onChange({
            hex: data.hex,
            source: "hex"
          }, e);
        }
      };
      return React.createElement(
        "div",
        { style: styles2.fields, className: "flexbox-fix" },
        React.createElement("div", { style: styles2.active }),
        React.createElement(EditableInput, {
          style: { wrap: styles2.HEXwrap, input: styles2.HEXinput, label: styles2.HEXlabel },
          label: "hex",
          value: hex,
          onChange: handleChange
        }),
        React.createElement(EditableInput, {
          style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
          label: "r",
          value: rgb.r,
          onChange: handleChange
        }),
        React.createElement(EditableInput, {
          style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
          label: "g",
          value: rgb.g,
          onChange: handleChange
        }),
        React.createElement(EditableInput, {
          style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
          label: "b",
          value: rgb.b,
          onChange: handleChange
        })
      );
    };
    var Compact = function Compact2(_ref) {
      var onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, colors = _ref.colors, hex = _ref.hex, rgb = _ref.rgb, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
      var styles2 = reactCSS(merge({
        "default": {
          Compact: {
            background: "#f6f6f6",
            radius: "4px"
          },
          compact: {
            paddingTop: "5px",
            paddingLeft: "5px",
            boxSizing: "initial",
            width: "240px"
          },
          clear: {
            clear: "both"
          }
        }
      }, passedStyles));
      var handleChange = function handleChange2(data, e) {
        if (data.hex) {
          isValidHex(data.hex) && onChange({
            hex: data.hex,
            source: "hex"
          }, e);
        } else {
          onChange(data, e);
        }
      };
      return React.createElement(
        Raised,
        { style: styles2.Compact, styles: passedStyles },
        React.createElement(
          "div",
          { style: styles2.compact, className: "compact-picker " + className },
          React.createElement(
            "div",
            null,
            map(colors, function(c) {
              return React.createElement(CompactColor, {
                key: c,
                color: c,
                active: c.toLowerCase() === hex,
                onClick: handleChange,
                onSwatchHover
              });
            }),
            React.createElement("div", { style: styles2.clear })
          ),
          React.createElement(CompactFields, { hex, rgb, onChange: handleChange })
        )
      );
    };
    Compact.propTypes = {
      colors: PropTypes.arrayOf(PropTypes.string),
      styles: PropTypes.object
    };
    Compact.defaultProps = {
      colors: ["#4D4D4D", "#999999", "#FFFFFF", "#F44E3B", "#FE9200", "#FCDC00", "#DBDF00", "#A4DD00", "#68CCCA", "#73D8FF", "#AEA1FF", "#FDA1FF", "#333333", "#808080", "#cccccc", "#D33115", "#E27300", "#FCC400", "#B0BC00", "#68BC00", "#16A5A5", "#009CE0", "#7B64FF", "#FA28FF", "#000000", "#666666", "#B3B3B3", "#9F0500", "#C45100", "#FB9E00", "#808900", "#194D33", "#0C797D", "#0062B1", "#653294", "#AB149E"],
      styles: {}
    };
    ColorWrap(Compact);
    var GithubSwatch = function GithubSwatch2(_ref) {
      var hover2 = _ref.hover, color = _ref.color, onClick = _ref.onClick, onSwatchHover = _ref.onSwatchHover;
      var hoverSwatch = {
        position: "relative",
        zIndex: "2",
        outline: "2px solid #fff",
        boxShadow: "0 0 5px 2px rgba(0,0,0,0.25)"
      };
      var styles2 = reactCSS({
        "default": {
          swatch: {
            width: "25px",
            height: "25px",
            fontSize: "0"
          }
        },
        "hover": {
          swatch: hoverSwatch
        }
      }, { hover: hover2 });
      return React.createElement(
        "div",
        { style: styles2.swatch },
        React.createElement(Swatch$1, {
          color,
          onClick,
          onHover: onSwatchHover,
          focusStyle: hoverSwatch
        })
      );
    };
    const GithubSwatch$1 = libExports.handleHover(GithubSwatch);
    var Github = function Github2(_ref) {
      var width = _ref.width, colors = _ref.colors, onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, triangle = _ref.triangle, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
      var styles2 = reactCSS(merge({
        "default": {
          card: {
            width,
            background: "#fff",
            border: "1px solid rgba(0,0,0,0.2)",
            boxShadow: "0 3px 12px rgba(0,0,0,0.15)",
            borderRadius: "4px",
            position: "relative",
            padding: "5px",
            display: "flex",
            flexWrap: "wrap"
          },
          triangle: {
            position: "absolute",
            border: "7px solid transparent",
            borderBottomColor: "#fff"
          },
          triangleShadow: {
            position: "absolute",
            border: "8px solid transparent",
            borderBottomColor: "rgba(0,0,0,0.15)"
          }
        },
        "hide-triangle": {
          triangle: {
            display: "none"
          },
          triangleShadow: {
            display: "none"
          }
        },
        "top-left-triangle": {
          triangle: {
            top: "-14px",
            left: "10px"
          },
          triangleShadow: {
            top: "-16px",
            left: "9px"
          }
        },
        "top-right-triangle": {
          triangle: {
            top: "-14px",
            right: "10px"
          },
          triangleShadow: {
            top: "-16px",
            right: "9px"
          }
        },
        "bottom-left-triangle": {
          triangle: {
            top: "35px",
            left: "10px",
            transform: "rotate(180deg)"
          },
          triangleShadow: {
            top: "37px",
            left: "9px",
            transform: "rotate(180deg)"
          }
        },
        "bottom-right-triangle": {
          triangle: {
            top: "35px",
            right: "10px",
            transform: "rotate(180deg)"
          },
          triangleShadow: {
            top: "37px",
            right: "9px",
            transform: "rotate(180deg)"
          }
        }
      }, passedStyles), {
        "hide-triangle": triangle === "hide",
        "top-left-triangle": triangle === "top-left",
        "top-right-triangle": triangle === "top-right",
        "bottom-left-triangle": triangle === "bottom-left",
        "bottom-right-triangle": triangle === "bottom-right"
      });
      var handleChange = function handleChange2(hex, e) {
        return onChange({ hex, source: "hex" }, e);
      };
      return React.createElement(
        "div",
        { style: styles2.card, className: "github-picker " + className },
        React.createElement("div", { style: styles2.triangleShadow }),
        React.createElement("div", { style: styles2.triangle }),
        map(colors, function(c) {
          return React.createElement(GithubSwatch$1, {
            color: c,
            key: c,
            onClick: handleChange,
            onSwatchHover
          });
        })
      );
    };
    Github.propTypes = {
      width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
      colors: PropTypes.arrayOf(PropTypes.string),
      triangle: PropTypes.oneOf(["hide", "top-left", "top-right", "bottom-left", "bottom-right"]),
      styles: PropTypes.object
    };
    Github.defaultProps = {
      width: 200,
      colors: ["#B80000", "#DB3E00", "#FCCB00", "#008B02", "#006B76", "#1273DE", "#004DCF", "#5300EB", "#EB9694", "#FAD0C3", "#FEF3BD", "#C1E1C5", "#BEDADC", "#C4DEF6", "#BED3F3", "#D4C4FB"],
      triangle: "top-left",
      styles: {}
    };
    ColorWrap(Github);
    var SliderPointer$1 = function SliderPointer2(_ref) {
      var direction = _ref.direction;
      var styles2 = reactCSS({
        "default": {
          picker: {
            width: "18px",
            height: "18px",
            borderRadius: "50%",
            transform: "translate(-9px, -1px)",
            backgroundColor: "rgb(248, 248, 248)",
            boxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.37)"
          }
        },
        "vertical": {
          picker: {
            transform: "translate(-3px, -9px)"
          }
        }
      }, { vertical: direction === "vertical" });
      return React.createElement("div", { style: styles2.picker });
    };
    var _extends$2 = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var HuePicker = function HuePicker2(_ref) {
      var width = _ref.width, height = _ref.height, onChange = _ref.onChange, hsl = _ref.hsl, direction = _ref.direction, pointer = _ref.pointer, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
      var styles2 = reactCSS(merge({
        "default": {
          picker: {
            position: "relative",
            width,
            height
          },
          hue: {
            radius: "2px"
          }
        }
      }, passedStyles));
      var handleChange = function handleChange2(data) {
        return onChange({ a: 1, h: data.h, l: 0.5, s: 1 });
      };
      return React.createElement(
        "div",
        { style: styles2.picker, className: "hue-picker " + className },
        React.createElement(Hue, _extends$2({}, styles2.hue, {
          hsl,
          pointer,
          onChange: handleChange,
          direction
        }))
      );
    };
    HuePicker.propTypes = {
      styles: PropTypes.object
    };
    HuePicker.defaultProps = {
      width: "316px",
      height: "16px",
      direction: "horizontal",
      pointer: SliderPointer$1,
      styles: {}
    };
    ColorWrap(HuePicker);
    var Material = function Material2(_ref) {
      var onChange = _ref.onChange, hex = _ref.hex, rgb = _ref.rgb, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
      var styles2 = reactCSS(merge({
        "default": {
          material: {
            width: "98px",
            height: "98px",
            padding: "16px",
            fontFamily: "Roboto"
          },
          HEXwrap: {
            position: "relative"
          },
          HEXinput: {
            width: "100%",
            marginTop: "12px",
            fontSize: "15px",
            color: "#333",
            padding: "0px",
            border: "0px",
            borderBottom: "2px solid " + hex,
            outline: "none",
            height: "30px"
          },
          HEXlabel: {
            position: "absolute",
            top: "0px",
            left: "0px",
            fontSize: "11px",
            color: "#999999",
            textTransform: "capitalize"
          },
          Hex: {
            style: {}
          },
          RGBwrap: {
            position: "relative"
          },
          RGBinput: {
            width: "100%",
            marginTop: "12px",
            fontSize: "15px",
            color: "#333",
            padding: "0px",
            border: "0px",
            borderBottom: "1px solid #eee",
            outline: "none",
            height: "30px"
          },
          RGBlabel: {
            position: "absolute",
            top: "0px",
            left: "0px",
            fontSize: "11px",
            color: "#999999",
            textTransform: "capitalize"
          },
          split: {
            display: "flex",
            marginRight: "-10px",
            paddingTop: "11px"
          },
          third: {
            flex: "1",
            paddingRight: "10px"
          }
        }
      }, passedStyles));
      var handleChange = function handleChange2(data, e) {
        if (data.hex) {
          isValidHex(data.hex) && onChange({
            hex: data.hex,
            source: "hex"
          }, e);
        } else if (data.r || data.g || data.b) {
          onChange({
            r: data.r || rgb.r,
            g: data.g || rgb.g,
            b: data.b || rgb.b,
            source: "rgb"
          }, e);
        }
      };
      return React.createElement(
        Raised,
        { styles: passedStyles },
        React.createElement(
          "div",
          { style: styles2.material, className: "material-picker " + className },
          React.createElement(EditableInput, {
            style: { wrap: styles2.HEXwrap, input: styles2.HEXinput, label: styles2.HEXlabel },
            label: "hex",
            value: hex,
            onChange: handleChange
          }),
          React.createElement(
            "div",
            { style: styles2.split, className: "flexbox-fix" },
            React.createElement(
              "div",
              { style: styles2.third },
              React.createElement(EditableInput, {
                style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
                label: "r",
                value: rgb.r,
                onChange: handleChange
              })
            ),
            React.createElement(
              "div",
              { style: styles2.third },
              React.createElement(EditableInput, {
                style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
                label: "g",
                value: rgb.g,
                onChange: handleChange
              })
            ),
            React.createElement(
              "div",
              { style: styles2.third },
              React.createElement(EditableInput, {
                style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
                label: "b",
                value: rgb.b,
                onChange: handleChange
              })
            )
          )
        )
      );
    };
    ColorWrap(Material);
    var PhotoshopPicker = function PhotoshopPicker2(_ref) {
      var onChange = _ref.onChange, rgb = _ref.rgb, hsv = _ref.hsv, hex = _ref.hex;
      var styles2 = reactCSS({
        "default": {
          fields: {
            paddingTop: "5px",
            paddingBottom: "9px",
            width: "80px",
            position: "relative"
          },
          divider: {
            height: "5px"
          },
          RGBwrap: {
            position: "relative"
          },
          RGBinput: {
            marginLeft: "40%",
            width: "40%",
            height: "18px",
            border: "1px solid #888888",
            boxShadow: "inset 0 1px 1px rgba(0,0,0,.1), 0 1px 0 0 #ECECEC",
            marginBottom: "5px",
            fontSize: "13px",
            paddingLeft: "3px",
            marginRight: "10px"
          },
          RGBlabel: {
            left: "0px",
            top: "0px",
            width: "34px",
            textTransform: "uppercase",
            fontSize: "13px",
            height: "18px",
            lineHeight: "22px",
            position: "absolute"
          },
          HEXwrap: {
            position: "relative"
          },
          HEXinput: {
            marginLeft: "20%",
            width: "80%",
            height: "18px",
            border: "1px solid #888888",
            boxShadow: "inset 0 1px 1px rgba(0,0,0,.1), 0 1px 0 0 #ECECEC",
            marginBottom: "6px",
            fontSize: "13px",
            paddingLeft: "3px"
          },
          HEXlabel: {
            position: "absolute",
            top: "0px",
            left: "0px",
            width: "14px",
            textTransform: "uppercase",
            fontSize: "13px",
            height: "18px",
            lineHeight: "22px"
          },
          fieldSymbols: {
            position: "absolute",
            top: "5px",
            right: "-7px",
            fontSize: "13px"
          },
          symbol: {
            height: "20px",
            lineHeight: "22px",
            paddingBottom: "7px"
          }
        }
      });
      var handleChange = function handleChange2(data, e) {
        if (data["#"]) {
          isValidHex(data["#"]) && onChange({
            hex: data["#"],
            source: "hex"
          }, e);
        } else if (data.r || data.g || data.b) {
          onChange({
            r: data.r || rgb.r,
            g: data.g || rgb.g,
            b: data.b || rgb.b,
            source: "rgb"
          }, e);
        } else if (data.h || data.s || data.v) {
          onChange({
            h: data.h || hsv.h,
            s: data.s || hsv.s,
            v: data.v || hsv.v,
            source: "hsv"
          }, e);
        }
      };
      return React.createElement(
        "div",
        { style: styles2.fields },
        React.createElement(EditableInput, {
          style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
          label: "h",
          value: Math.round(hsv.h),
          onChange: handleChange
        }),
        React.createElement(EditableInput, {
          style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
          label: "s",
          value: Math.round(hsv.s * 100),
          onChange: handleChange
        }),
        React.createElement(EditableInput, {
          style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
          label: "v",
          value: Math.round(hsv.v * 100),
          onChange: handleChange
        }),
        React.createElement("div", { style: styles2.divider }),
        React.createElement(EditableInput, {
          style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
          label: "r",
          value: rgb.r,
          onChange: handleChange
        }),
        React.createElement(EditableInput, {
          style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
          label: "g",
          value: rgb.g,
          onChange: handleChange
        }),
        React.createElement(EditableInput, {
          style: { wrap: styles2.RGBwrap, input: styles2.RGBinput, label: styles2.RGBlabel },
          label: "b",
          value: rgb.b,
          onChange: handleChange
        }),
        React.createElement("div", { style: styles2.divider }),
        React.createElement(EditableInput, {
          style: { wrap: styles2.HEXwrap, input: styles2.HEXinput, label: styles2.HEXlabel },
          label: "#",
          value: hex.replace("#", ""),
          onChange: handleChange
        }),
        React.createElement(
          "div",
          { style: styles2.fieldSymbols },
          React.createElement(
            "div",
            { style: styles2.symbol },
            "°"
          ),
          React.createElement(
            "div",
            { style: styles2.symbol },
            "%"
          ),
          React.createElement(
            "div",
            { style: styles2.symbol },
            "%"
          )
        )
      );
    };
    var PhotoshopPointerCircle$1 = function PhotoshopPointerCircle2(_ref) {
      var hsl = _ref.hsl;
      var styles2 = reactCSS({
        "default": {
          picker: {
            width: "12px",
            height: "12px",
            borderRadius: "6px",
            boxShadow: "inset 0 0 0 1px #fff",
            transform: "translate(-6px, -6px)"
          }
        },
        "black-outline": {
          picker: {
            boxShadow: "inset 0 0 0 1px #000"
          }
        }
      }, { "black-outline": hsl.l > 0.5 });
      return React.createElement("div", { style: styles2.picker });
    };
    var PhotoshopPointerCircle = function PhotoshopPointerCircle2() {
      var styles2 = reactCSS({
        "default": {
          triangle: {
            width: 0,
            height: 0,
            borderStyle: "solid",
            borderWidth: "4px 0 4px 6px",
            borderColor: "transparent transparent transparent #fff",
            position: "absolute",
            top: "1px",
            left: "1px"
          },
          triangleBorder: {
            width: 0,
            height: 0,
            borderStyle: "solid",
            borderWidth: "5px 0 5px 8px",
            borderColor: "transparent transparent transparent #555"
          },
          left: {
            Extend: "triangleBorder",
            transform: "translate(-13px, -4px)"
          },
          leftInside: {
            Extend: "triangle",
            transform: "translate(-8px, -5px)"
          },
          right: {
            Extend: "triangleBorder",
            transform: "translate(20px, -14px) rotate(180deg)"
          },
          rightInside: {
            Extend: "triangle",
            transform: "translate(-8px, -5px)"
          }
        }
      });
      return React.createElement(
        "div",
        { style: styles2.pointer },
        React.createElement(
          "div",
          { style: styles2.left },
          React.createElement("div", { style: styles2.leftInside })
        ),
        React.createElement(
          "div",
          { style: styles2.right },
          React.createElement("div", { style: styles2.rightInside })
        )
      );
    };
    var PhotoshopButton = function PhotoshopButton2(_ref) {
      var onClick = _ref.onClick, label = _ref.label, children = _ref.children, active2 = _ref.active;
      var styles2 = reactCSS({
        "default": {
          button: {
            backgroundImage: "linear-gradient(-180deg, #FFFFFF 0%, #E6E6E6 100%)",
            border: "1px solid #878787",
            borderRadius: "2px",
            height: "20px",
            boxShadow: "0 1px 0 0 #EAEAEA",
            fontSize: "14px",
            color: "#000",
            lineHeight: "20px",
            textAlign: "center",
            marginBottom: "10px",
            cursor: "pointer"
          }
        },
        "active": {
          button: {
            boxShadow: "0 0 0 1px #878787"
          }
        }
      }, { active: active2 });
      return React.createElement(
        "div",
        { style: styles2.button, onClick },
        label || children
      );
    };
    var PhotoshopPreviews = function PhotoshopPreviews2(_ref) {
      var rgb = _ref.rgb, currentColor = _ref.currentColor;
      var styles2 = reactCSS({
        "default": {
          swatches: {
            border: "1px solid #B3B3B3",
            borderBottom: "1px solid #F0F0F0",
            marginBottom: "2px",
            marginTop: "1px"
          },
          new: {
            height: "34px",
            background: "rgb(" + rgb.r + "," + rgb.g + ", " + rgb.b + ")",
            boxShadow: "inset 1px 0 0 #000, inset -1px 0 0 #000, inset 0 1px 0 #000"
          },
          current: {
            height: "34px",
            background: currentColor,
            boxShadow: "inset 1px 0 0 #000, inset -1px 0 0 #000, inset 0 -1px 0 #000"
          },
          label: {
            fontSize: "14px",
            color: "#000",
            textAlign: "center"
          }
        }
      });
      return React.createElement(
        "div",
        null,
        React.createElement(
          "div",
          { style: styles2.label },
          "new"
        ),
        React.createElement(
          "div",
          { style: styles2.swatches },
          React.createElement("div", { style: styles2.new }),
          React.createElement("div", { style: styles2.current })
        ),
        React.createElement(
          "div",
          { style: styles2.label },
          "current"
        )
      );
    };
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var Photoshop = function(_React$Component) {
      _inherits(Photoshop2, _React$Component);
      function Photoshop2(props) {
        _classCallCheck(this, Photoshop2);
        var _this = _possibleConstructorReturn(this, (Photoshop2.__proto__ || Object.getPrototypeOf(Photoshop2)).call(this));
        _this.state = {
          currentColor: props.hex
        };
        return _this;
      }
      _createClass(Photoshop2, [{
        key: "render",
        value: function render2() {
          var _props = this.props, _props$styles = _props.styles, passedStyles = _props$styles === void 0 ? {} : _props$styles, _props$className = _props.className, className = _props$className === void 0 ? "" : _props$className;
          var styles2 = reactCSS(merge({
            "default": {
              picker: {
                background: "#DCDCDC",
                borderRadius: "4px",
                boxShadow: "0 0 0 1px rgba(0,0,0,.25), 0 8px 16px rgba(0,0,0,.15)",
                boxSizing: "initial",
                width: "513px"
              },
              head: {
                backgroundImage: "linear-gradient(-180deg, #F0F0F0 0%, #D4D4D4 100%)",
                borderBottom: "1px solid #B1B1B1",
                boxShadow: "inset 0 1px 0 0 rgba(255,255,255,.2), inset 0 -1px 0 0 rgba(0,0,0,.02)",
                height: "23px",
                lineHeight: "24px",
                borderRadius: "4px 4px 0 0",
                fontSize: "13px",
                color: "#4D4D4D",
                textAlign: "center"
              },
              body: {
                padding: "15px 15px 0",
                display: "flex"
              },
              saturation: {
                width: "256px",
                height: "256px",
                position: "relative",
                border: "2px solid #B3B3B3",
                borderBottom: "2px solid #F0F0F0",
                overflow: "hidden"
              },
              hue: {
                position: "relative",
                height: "256px",
                width: "19px",
                marginLeft: "10px",
                border: "2px solid #B3B3B3",
                borderBottom: "2px solid #F0F0F0"
              },
              controls: {
                width: "180px",
                marginLeft: "10px"
              },
              top: {
                display: "flex"
              },
              previews: {
                width: "60px"
              },
              actions: {
                flex: "1",
                marginLeft: "20px"
              }
            }
          }, passedStyles));
          return React.createElement(
            "div",
            { style: styles2.picker, className: "photoshop-picker " + className },
            React.createElement(
              "div",
              { style: styles2.head },
              this.props.header
            ),
            React.createElement(
              "div",
              { style: styles2.body, className: "flexbox-fix" },
              React.createElement(
                "div",
                { style: styles2.saturation },
                React.createElement(Saturation, {
                  hsl: this.props.hsl,
                  hsv: this.props.hsv,
                  pointer: PhotoshopPointerCircle$1,
                  onChange: this.props.onChange
                })
              ),
              React.createElement(
                "div",
                { style: styles2.hue },
                React.createElement(Hue, {
                  direction: "vertical",
                  hsl: this.props.hsl,
                  pointer: PhotoshopPointerCircle,
                  onChange: this.props.onChange
                })
              ),
              React.createElement(
                "div",
                { style: styles2.controls },
                React.createElement(
                  "div",
                  { style: styles2.top, className: "flexbox-fix" },
                  React.createElement(
                    "div",
                    { style: styles2.previews },
                    React.createElement(PhotoshopPreviews, {
                      rgb: this.props.rgb,
                      currentColor: this.state.currentColor
                    })
                  ),
                  React.createElement(
                    "div",
                    { style: styles2.actions },
                    React.createElement(PhotoshopButton, { label: "OK", onClick: this.props.onAccept, active: true }),
                    React.createElement(PhotoshopButton, { label: "Cancel", onClick: this.props.onCancel }),
                    React.createElement(PhotoshopPicker, {
                      onChange: this.props.onChange,
                      rgb: this.props.rgb,
                      hsv: this.props.hsv,
                      hex: this.props.hex
                    })
                  )
                )
              )
            )
          );
        }
      }]);
      return Photoshop2;
    }(React.Component);
    Photoshop.propTypes = {
      header: PropTypes.string,
      styles: PropTypes.object
    };
    Photoshop.defaultProps = {
      header: "Color Picker",
      styles: {}
    };
    ColorWrap(Photoshop);
    var SketchFields = function SketchFields2(_ref) {
      var onChange = _ref.onChange, rgb = _ref.rgb, hsl = _ref.hsl, hex = _ref.hex, disableAlpha = _ref.disableAlpha;
      var styles2 = reactCSS({
        "default": {
          fields: {
            display: "flex",
            paddingTop: "4px"
          },
          single: {
            flex: "1",
            paddingLeft: "6px"
          },
          alpha: {
            flex: "1",
            paddingLeft: "6px"
          },
          double: {
            flex: "2"
          },
          input: {
            width: "80%",
            padding: "4px 10% 3px",
            border: "none",
            boxShadow: "inset 0 0 0 1px #ccc",
            fontSize: "11px"
          },
          label: {
            display: "block",
            textAlign: "center",
            fontSize: "11px",
            color: "#222",
            paddingTop: "3px",
            paddingBottom: "4px",
            textTransform: "capitalize"
          }
        },
        "disableAlpha": {
          alpha: {
            display: "none"
          }
        }
      }, { disableAlpha });
      var handleChange = function handleChange2(data, e) {
        if (data.hex) {
          isValidHex(data.hex) && onChange({
            hex: data.hex,
            source: "hex"
          }, e);
        } else if (data.r || data.g || data.b) {
          onChange({
            r: data.r || rgb.r,
            g: data.g || rgb.g,
            b: data.b || rgb.b,
            a: rgb.a,
            source: "rgb"
          }, e);
        } else if (data.a) {
          if (data.a < 0) {
            data.a = 0;
          } else if (data.a > 100) {
            data.a = 100;
          }
          data.a /= 100;
          onChange({
            h: hsl.h,
            s: hsl.s,
            l: hsl.l,
            a: data.a,
            source: "rgb"
          }, e);
        }
      };
      return React.createElement(
        "div",
        { style: styles2.fields, className: "flexbox-fix" },
        React.createElement(
          "div",
          { style: styles2.double },
          React.createElement(EditableInput, {
            style: { input: styles2.input, label: styles2.label },
            label: "hex",
            value: hex.replace("#", ""),
            onChange: handleChange
          })
        ),
        React.createElement(
          "div",
          { style: styles2.single },
          React.createElement(EditableInput, {
            style: { input: styles2.input, label: styles2.label },
            label: "r",
            value: rgb.r,
            onChange: handleChange,
            dragLabel: "true",
            dragMax: "255"
          })
        ),
        React.createElement(
          "div",
          { style: styles2.single },
          React.createElement(EditableInput, {
            style: { input: styles2.input, label: styles2.label },
            label: "g",
            value: rgb.g,
            onChange: handleChange,
            dragLabel: "true",
            dragMax: "255"
          })
        ),
        React.createElement(
          "div",
          { style: styles2.single },
          React.createElement(EditableInput, {
            style: { input: styles2.input, label: styles2.label },
            label: "b",
            value: rgb.b,
            onChange: handleChange,
            dragLabel: "true",
            dragMax: "255"
          })
        ),
        React.createElement(
          "div",
          { style: styles2.alpha },
          React.createElement(EditableInput, {
            style: { input: styles2.input, label: styles2.label },
            label: "a",
            value: Math.round(rgb.a * 100),
            onChange: handleChange,
            dragLabel: "true",
            dragMax: "100"
          })
        )
      );
    };
    var _extends$1 = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var SketchPresetColors = function SketchPresetColors2(_ref) {
      var colors = _ref.colors, _ref$onClick = _ref.onClick, onClick = _ref$onClick === void 0 ? function() {
      } : _ref$onClick, onSwatchHover = _ref.onSwatchHover;
      var styles2 = reactCSS({
        "default": {
          colors: {
            margin: "0 -10px",
            padding: "10px 0 0 10px",
            borderTop: "1px solid #eee",
            display: "flex",
            flexWrap: "wrap",
            position: "relative"
          },
          swatchWrap: {
            width: "16px",
            height: "16px",
            margin: "0 10px 10px 0"
          },
          swatch: {
            borderRadius: "3px",
            boxShadow: "inset 0 0 0 1px rgba(0,0,0,.15)"
          }
        },
        "no-presets": {
          colors: {
            display: "none"
          }
        }
      }, {
        "no-presets": !colors || !colors.length
      });
      var handleClick = function handleClick2(hex, e) {
        onClick({
          hex,
          source: "hex"
        }, e);
      };
      return React.createElement(
        "div",
        { style: styles2.colors, className: "flexbox-fix" },
        colors.map(function(colorObjOrString) {
          var c = typeof colorObjOrString === "string" ? { color: colorObjOrString } : colorObjOrString;
          var key = "" + c.color + (c.title || "");
          return React.createElement(
            "div",
            { key, style: styles2.swatchWrap },
            React.createElement(Swatch$1, _extends$1({}, c, {
              style: styles2.swatch,
              onClick: handleClick,
              onHover: onSwatchHover,
              focusStyle: {
                boxShadow: "inset 0 0 0 1px rgba(0,0,0,.15), 0 0 4px " + c.color
              }
            }))
          );
        })
      );
    };
    SketchPresetColors.propTypes = {
      colors: PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.string, PropTypes.shape({
        color: PropTypes.string,
        title: PropTypes.string
      })])).isRequired
    };
    var _extends = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var Sketch = function Sketch2(_ref) {
      var width = _ref.width, rgb = _ref.rgb, hex = _ref.hex, hsv = _ref.hsv, hsl = _ref.hsl, onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, disableAlpha = _ref.disableAlpha, presetColors = _ref.presetColors, renderers = _ref.renderers, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
      var styles2 = reactCSS(merge({
        "default": _extends({
          picker: {
            width,
            padding: "10px 10px 0",
            boxSizing: "initial",
            background: "#fff",
            borderRadius: "4px",
            boxShadow: "0 0 0 1px rgba(0,0,0,.15), 0 8px 16px rgba(0,0,0,.15)"
          },
          saturation: {
            width: "100%",
            paddingBottom: "75%",
            position: "relative",
            overflow: "hidden"
          },
          Saturation: {
            radius: "3px",
            shadow: "inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)"
          },
          controls: {
            display: "flex"
          },
          sliders: {
            padding: "4px 0",
            flex: "1"
          },
          color: {
            width: "24px",
            height: "24px",
            position: "relative",
            marginTop: "4px",
            marginLeft: "4px",
            borderRadius: "3px"
          },
          activeColor: {
            absolute: "0px 0px 0px 0px",
            borderRadius: "2px",
            background: "rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + "," + rgb.a + ")",
            boxShadow: "inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)"
          },
          hue: {
            position: "relative",
            height: "10px",
            overflow: "hidden"
          },
          Hue: {
            radius: "2px",
            shadow: "inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)"
          },
          alpha: {
            position: "relative",
            height: "10px",
            marginTop: "4px",
            overflow: "hidden"
          },
          Alpha: {
            radius: "2px",
            shadow: "inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)"
          }
        }, passedStyles),
        "disableAlpha": {
          color: {
            height: "10px"
          },
          hue: {
            height: "10px"
          },
          alpha: {
            display: "none"
          }
        }
      }, passedStyles), { disableAlpha });
      return React.createElement(
        "div",
        { style: styles2.picker, className: "sketch-picker " + className },
        React.createElement(
          "div",
          { style: styles2.saturation },
          React.createElement(Saturation, {
            style: styles2.Saturation,
            hsl,
            hsv,
            onChange
          })
        ),
        React.createElement(
          "div",
          { style: styles2.controls, className: "flexbox-fix" },
          React.createElement(
            "div",
            { style: styles2.sliders },
            React.createElement(
              "div",
              { style: styles2.hue },
              React.createElement(Hue, {
                style: styles2.Hue,
                hsl,
                onChange
              })
            ),
            React.createElement(
              "div",
              { style: styles2.alpha },
              React.createElement(Alpha, {
                style: styles2.Alpha,
                rgb,
                hsl,
                renderers,
                onChange
              })
            )
          ),
          React.createElement(
            "div",
            { style: styles2.color },
            React.createElement(Checkboard, null),
            React.createElement("div", { style: styles2.activeColor })
          )
        ),
        React.createElement(SketchFields, {
          rgb,
          hsl,
          hex,
          onChange,
          disableAlpha
        }),
        React.createElement(SketchPresetColors, {
          colors: presetColors,
          onClick: onChange,
          onSwatchHover
        })
      );
    };
    Sketch.propTypes = {
      disableAlpha: PropTypes.bool,
      width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
      styles: PropTypes.object
    };
    Sketch.defaultProps = {
      disableAlpha: false,
      width: 200,
      styles: {},
      presetColors: ["#D0021B", "#F5A623", "#F8E71C", "#8B572A", "#7ED321", "#417505", "#BD10E0", "#9013FE", "#4A90E2", "#50E3C2", "#B8E986", "#000000", "#4A4A4A", "#9B9B9B", "#FFFFFF"]
    };
    ColorWrap(Sketch);
    var SliderSwatch = function SliderSwatch2(_ref) {
      var hsl = _ref.hsl, offset = _ref.offset, _ref$onClick = _ref.onClick, onClick = _ref$onClick === void 0 ? function() {
      } : _ref$onClick, active2 = _ref.active, first = _ref.first, last = _ref.last;
      var styles2 = reactCSS({
        "default": {
          swatch: {
            height: "12px",
            background: "hsl(" + hsl.h + ", 50%, " + offset * 100 + "%)",
            cursor: "pointer"
          }
        },
        "first": {
          swatch: {
            borderRadius: "2px 0 0 2px"
          }
        },
        "last": {
          swatch: {
            borderRadius: "0 2px 2px 0"
          }
        },
        "active": {
          swatch: {
            transform: "scaleY(1.8)",
            borderRadius: "3.6px/2px"
          }
        }
      }, { active: active2, first, last });
      var handleClick = function handleClick2(e) {
        return onClick({
          h: hsl.h,
          s: 0.5,
          l: offset,
          source: "hsl"
        }, e);
      };
      return React.createElement("div", { style: styles2.swatch, onClick: handleClick });
    };
    var SliderSwatches = function SliderSwatches2(_ref) {
      var onClick = _ref.onClick, hsl = _ref.hsl;
      var styles2 = reactCSS({
        "default": {
          swatches: {
            marginTop: "20px"
          },
          swatch: {
            boxSizing: "border-box",
            width: "20%",
            paddingRight: "1px",
            float: "left"
          },
          clear: {
            clear: "both"
          }
        }
      });
      var epsilon = 0.1;
      return React.createElement(
        "div",
        { style: styles2.swatches },
        React.createElement(
          "div",
          { style: styles2.swatch },
          React.createElement(SliderSwatch, {
            hsl,
            offset: ".80",
            active: Math.abs(hsl.l - 0.8) < epsilon && Math.abs(hsl.s - 0.5) < epsilon,
            onClick,
            first: true
          })
        ),
        React.createElement(
          "div",
          { style: styles2.swatch },
          React.createElement(SliderSwatch, {
            hsl,
            offset: ".65",
            active: Math.abs(hsl.l - 0.65) < epsilon && Math.abs(hsl.s - 0.5) < epsilon,
            onClick
          })
        ),
        React.createElement(
          "div",
          { style: styles2.swatch },
          React.createElement(SliderSwatch, {
            hsl,
            offset: ".50",
            active: Math.abs(hsl.l - 0.5) < epsilon && Math.abs(hsl.s - 0.5) < epsilon,
            onClick
          })
        ),
        React.createElement(
          "div",
          { style: styles2.swatch },
          React.createElement(SliderSwatch, {
            hsl,
            offset: ".35",
            active: Math.abs(hsl.l - 0.35) < epsilon && Math.abs(hsl.s - 0.5) < epsilon,
            onClick
          })
        ),
        React.createElement(
          "div",
          { style: styles2.swatch },
          React.createElement(SliderSwatch, {
            hsl,
            offset: ".20",
            active: Math.abs(hsl.l - 0.2) < epsilon && Math.abs(hsl.s - 0.5) < epsilon,
            onClick,
            last: true
          })
        ),
        React.createElement("div", { style: styles2.clear })
      );
    };
    var SliderPointer = function SliderPointer2() {
      var styles2 = reactCSS({
        "default": {
          picker: {
            width: "14px",
            height: "14px",
            borderRadius: "6px",
            transform: "translate(-7px, -1px)",
            backgroundColor: "rgb(248, 248, 248)",
            boxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.37)"
          }
        }
      });
      return React.createElement("div", { style: styles2.picker });
    };
    var Slider = function Slider2(_ref) {
      var hsl = _ref.hsl, onChange = _ref.onChange, pointer = _ref.pointer, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
      var styles2 = reactCSS(merge({
        "default": {
          hue: {
            height: "12px",
            position: "relative"
          },
          Hue: {
            radius: "2px"
          }
        }
      }, passedStyles));
      return React.createElement(
        "div",
        { style: styles2.wrap || {}, className: "slider-picker " + className },
        React.createElement(
          "div",
          { style: styles2.hue },
          React.createElement(Hue, {
            style: styles2.Hue,
            hsl,
            pointer,
            onChange
          })
        ),
        React.createElement(
          "div",
          { style: styles2.swatches },
          React.createElement(SliderSwatches, { hsl, onClick: onChange })
        )
      );
    };
    Slider.propTypes = {
      styles: PropTypes.object
    };
    Slider.defaultProps = {
      pointer: SliderPointer,
      styles: {}
    };
    ColorWrap(Slider);
    var CheckIcon$1 = {};
    var hasRequiredCheckIcon;
    function requireCheckIcon() {
      if (hasRequiredCheckIcon) return CheckIcon$1;
      hasRequiredCheckIcon = 1;
      Object.defineProperty(CheckIcon$1, "__esModule", {
        value: true
      });
      var _extends2 = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      var _react = requireReact();
      var _react2 = _interopRequireDefault(_react);
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      function _objectWithoutProperties(obj, keys2) {
        var target = {};
        for (var i in obj) {
          if (keys2.indexOf(i) >= 0) continue;
          if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
          target[i] = obj[i];
        }
        return target;
      }
      var DEFAULT_SIZE = 24;
      CheckIcon$1.default = function(_ref) {
        var _ref$fill = _ref.fill, fill = _ref$fill === void 0 ? "currentColor" : _ref$fill, _ref$width = _ref.width, width = _ref$width === void 0 ? DEFAULT_SIZE : _ref$width, _ref$height = _ref.height, height = _ref$height === void 0 ? DEFAULT_SIZE : _ref$height, _ref$style = _ref.style, style = _ref$style === void 0 ? {} : _ref$style, props = _objectWithoutProperties(_ref, ["fill", "width", "height", "style"]);
        return _react2.default.createElement(
          "svg",
          _extends2({
            viewBox: "0 0 " + DEFAULT_SIZE + " " + DEFAULT_SIZE,
            style: _extends2({ fill, width, height }, style)
          }, props),
          _react2.default.createElement("path", { d: "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z" })
        );
      };
      return CheckIcon$1;
    }
    var CheckIconExports = requireCheckIcon();
    const CheckIcon = /* @__PURE__ */ getDefaultExportFromCjs(CheckIconExports);
    var SwatchesColor = function SwatchesColor2(_ref) {
      var color = _ref.color, _ref$onClick = _ref.onClick, onClick = _ref$onClick === void 0 ? function() {
      } : _ref$onClick, onSwatchHover = _ref.onSwatchHover, first = _ref.first, last = _ref.last, active2 = _ref.active;
      var styles2 = reactCSS({
        "default": {
          color: {
            width: "40px",
            height: "24px",
            cursor: "pointer",
            background: color,
            marginBottom: "1px"
          },
          check: {
            color: getContrastingColor(color),
            marginLeft: "8px",
            display: "none"
          }
        },
        "first": {
          color: {
            overflow: "hidden",
            borderRadius: "2px 2px 0 0"
          }
        },
        "last": {
          color: {
            overflow: "hidden",
            borderRadius: "0 0 2px 2px"
          }
        },
        "active": {
          check: {
            display: "block"
          }
        },
        "color-#FFFFFF": {
          color: {
            boxShadow: "inset 0 0 0 1px #ddd"
          },
          check: {
            color: "#333"
          }
        },
        "transparent": {
          check: {
            color: "#333"
          }
        }
      }, {
        first,
        last,
        active: active2,
        "color-#FFFFFF": color === "#FFFFFF",
        "transparent": color === "transparent"
      });
      return React.createElement(
        Swatch$1,
        {
          color,
          style: styles2.color,
          onClick,
          onHover: onSwatchHover,
          focusStyle: { boxShadow: "0 0 4px " + color }
        },
        React.createElement(
          "div",
          { style: styles2.check },
          React.createElement(CheckIcon, null)
        )
      );
    };
    var SwatchesGroup = function SwatchesGroup2(_ref) {
      var onClick = _ref.onClick, onSwatchHover = _ref.onSwatchHover, group = _ref.group, active2 = _ref.active;
      var styles2 = reactCSS({
        "default": {
          group: {
            paddingBottom: "10px",
            width: "40px",
            float: "left",
            marginRight: "10px"
          }
        }
      });
      return React.createElement(
        "div",
        { style: styles2.group },
        map(group, function(color, i) {
          return React.createElement(SwatchesColor, {
            key: color,
            color,
            active: color.toLowerCase() === active2,
            first: i === 0,
            last: i === group.length - 1,
            onClick,
            onSwatchHover
          });
        })
      );
    };
    var Swatches = function Swatches2(_ref) {
      var width = _ref.width, height = _ref.height, onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, colors = _ref.colors, hex = _ref.hex, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
      var styles2 = reactCSS(merge({
        "default": {
          picker: {
            width,
            height
          },
          overflow: {
            height,
            overflowY: "scroll"
          },
          body: {
            padding: "16px 0 6px 16px"
          },
          clear: {
            clear: "both"
          }
        }
      }, passedStyles));
      var handleChange = function handleChange2(data, e) {
        return onChange({ hex: data, source: "hex" }, e);
      };
      return React.createElement(
        "div",
        { style: styles2.picker, className: "swatches-picker " + className },
        React.createElement(
          Raised,
          null,
          React.createElement(
            "div",
            { style: styles2.overflow },
            React.createElement(
              "div",
              { style: styles2.body },
              map(colors, function(group) {
                return React.createElement(SwatchesGroup, {
                  key: group.toString(),
                  group,
                  active: hex,
                  onClick: handleChange,
                  onSwatchHover
                });
              }),
              React.createElement("div", { style: styles2.clear })
            )
          )
        )
      );
    };
    Swatches.propTypes = {
      width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
      height: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
      colors: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.string)),
      styles: PropTypes.object
      /* eslint-disable max-len */
    };
    Swatches.defaultProps = {
      width: 320,
      height: 240,
      colors: [[red["900"], red["700"], red["500"], red["300"], red["100"]], [pink["900"], pink["700"], pink["500"], pink["300"], pink["100"]], [purple["900"], purple["700"], purple["500"], purple["300"], purple["100"]], [deepPurple["900"], deepPurple["700"], deepPurple["500"], deepPurple["300"], deepPurple["100"]], [indigo["900"], indigo["700"], indigo["500"], indigo["300"], indigo["100"]], [blue["900"], blue["700"], blue["500"], blue["300"], blue["100"]], [lightBlue["900"], lightBlue["700"], lightBlue["500"], lightBlue["300"], lightBlue["100"]], [cyan["900"], cyan["700"], cyan["500"], cyan["300"], cyan["100"]], [teal["900"], teal["700"], teal["500"], teal["300"], teal["100"]], ["#194D33", green["700"], green["500"], green["300"], green["100"]], [lightGreen["900"], lightGreen["700"], lightGreen["500"], lightGreen["300"], lightGreen["100"]], [lime["900"], lime["700"], lime["500"], lime["300"], lime["100"]], [yellow["900"], yellow["700"], yellow["500"], yellow["300"], yellow["100"]], [amber["900"], amber["700"], amber["500"], amber["300"], amber["100"]], [orange["900"], orange["700"], orange["500"], orange["300"], orange["100"]], [deepOrange["900"], deepOrange["700"], deepOrange["500"], deepOrange["300"], deepOrange["100"]], [brown["900"], brown["700"], brown["500"], brown["300"], brown["100"]], [blueGrey["900"], blueGrey["700"], blueGrey["500"], blueGrey["300"], blueGrey["100"]], ["#000000", "#525252", "#969696", "#D9D9D9", "#FFFFFF"]],
      styles: {}
    };
    ColorWrap(Swatches);
    var Twitter = function Twitter2(_ref) {
      var onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, hex = _ref.hex, colors = _ref.colors, width = _ref.width, triangle = _ref.triangle, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
      var styles2 = reactCSS(merge({
        "default": {
          card: {
            width,
            background: "#fff",
            border: "0 solid rgba(0,0,0,0.25)",
            boxShadow: "0 1px 4px rgba(0,0,0,0.25)",
            borderRadius: "4px",
            position: "relative"
          },
          body: {
            padding: "15px 9px 9px 15px"
          },
          label: {
            fontSize: "18px",
            color: "#fff"
          },
          triangle: {
            width: "0px",
            height: "0px",
            borderStyle: "solid",
            borderWidth: "0 9px 10px 9px",
            borderColor: "transparent transparent #fff transparent",
            position: "absolute"
          },
          triangleShadow: {
            width: "0px",
            height: "0px",
            borderStyle: "solid",
            borderWidth: "0 9px 10px 9px",
            borderColor: "transparent transparent rgba(0,0,0,.1) transparent",
            position: "absolute"
          },
          hash: {
            background: "#F0F0F0",
            height: "30px",
            width: "30px",
            borderRadius: "4px 0 0 4px",
            float: "left",
            color: "#98A1A4",
            display: "flex",
            alignItems: "center",
            justifyContent: "center"
          },
          input: {
            width: "100px",
            fontSize: "14px",
            color: "#666",
            border: "0px",
            outline: "none",
            height: "28px",
            boxShadow: "inset 0 0 0 1px #F0F0F0",
            boxSizing: "content-box",
            borderRadius: "0 4px 4px 0",
            float: "left",
            paddingLeft: "8px"
          },
          swatch: {
            width: "30px",
            height: "30px",
            float: "left",
            borderRadius: "4px",
            margin: "0 6px 6px 0"
          },
          clear: {
            clear: "both"
          }
        },
        "hide-triangle": {
          triangle: {
            display: "none"
          },
          triangleShadow: {
            display: "none"
          }
        },
        "top-left-triangle": {
          triangle: {
            top: "-10px",
            left: "12px"
          },
          triangleShadow: {
            top: "-11px",
            left: "12px"
          }
        },
        "top-right-triangle": {
          triangle: {
            top: "-10px",
            right: "12px"
          },
          triangleShadow: {
            top: "-11px",
            right: "12px"
          }
        }
      }, passedStyles), {
        "hide-triangle": triangle === "hide",
        "top-left-triangle": triangle === "top-left",
        "top-right-triangle": triangle === "top-right"
      });
      var handleChange = function handleChange2(hexcode, e) {
        isValidHex(hexcode) && onChange({
          hex: hexcode,
          source: "hex"
        }, e);
      };
      return React.createElement(
        "div",
        { style: styles2.card, className: "twitter-picker " + className },
        React.createElement("div", { style: styles2.triangleShadow }),
        React.createElement("div", { style: styles2.triangle }),
        React.createElement(
          "div",
          { style: styles2.body },
          map(colors, function(c, i) {
            return React.createElement(Swatch$1, {
              key: i,
              color: c,
              hex: c,
              style: styles2.swatch,
              onClick: handleChange,
              onHover: onSwatchHover,
              focusStyle: {
                boxShadow: "0 0 4px " + c
              }
            });
          }),
          React.createElement(
            "div",
            { style: styles2.hash },
            "#"
          ),
          React.createElement(EditableInput, {
            label: null,
            style: { input: styles2.input },
            value: hex.replace("#", ""),
            onChange: handleChange
          }),
          React.createElement("div", { style: styles2.clear })
        )
      );
    };
    Twitter.propTypes = {
      width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
      triangle: PropTypes.oneOf(["hide", "top-left", "top-right"]),
      colors: PropTypes.arrayOf(PropTypes.string),
      styles: PropTypes.object
    };
    Twitter.defaultProps = {
      width: 276,
      colors: ["#FF6900", "#FCB900", "#7BDCB5", "#00D084", "#8ED1FC", "#0693E3", "#ABB8C3", "#EB144C", "#F78DA7", "#9900EF"],
      triangle: "top-left",
      styles: {}
    };
    ColorWrap(Twitter);
    var GooglePointerCircle = function GooglePointerCircle2(props) {
      var styles2 = reactCSS({
        "default": {
          picker: {
            width: "20px",
            height: "20px",
            borderRadius: "22px",
            border: "2px #fff solid",
            transform: "translate(-12px, -13px)",
            background: "hsl(" + Math.round(props.hsl.h) + ", " + Math.round(props.hsl.s * 100) + "%, " + Math.round(props.hsl.l * 100) + "%)"
          }
        }
      });
      return React.createElement("div", { style: styles2.picker });
    };
    GooglePointerCircle.propTypes = {
      hsl: PropTypes.shape({
        h: PropTypes.number,
        s: PropTypes.number,
        l: PropTypes.number,
        a: PropTypes.number
      })
    };
    GooglePointerCircle.defaultProps = {
      hsl: { a: 1, h: 249.94, l: 0.2, s: 0.5 }
    };
    var GooglePointer = function GooglePointer2(props) {
      var styles2 = reactCSS({
        "default": {
          picker: {
            width: "20px",
            height: "20px",
            borderRadius: "22px",
            transform: "translate(-10px, -7px)",
            background: "hsl(" + Math.round(props.hsl.h) + ", 100%, 50%)",
            border: "2px white solid"
          }
        }
      });
      return React.createElement("div", { style: styles2.picker });
    };
    GooglePointer.propTypes = {
      hsl: PropTypes.shape({
        h: PropTypes.number,
        s: PropTypes.number,
        l: PropTypes.number,
        a: PropTypes.number
      })
    };
    GooglePointer.defaultProps = {
      hsl: { a: 1, h: 249.94, l: 0.2, s: 0.5 }
    };
    var GoogleFields = function GoogleFields2(_ref) {
      var onChange = _ref.onChange, rgb = _ref.rgb, hsl = _ref.hsl, hex = _ref.hex, hsv = _ref.hsv;
      var handleChange = function handleChange2(data, e) {
        if (data.hex) {
          isValidHex(data.hex) && onChange({
            hex: data.hex,
            source: "hex"
          }, e);
        } else if (data.rgb) {
          var values = data.rgb.split(",");
          isvalidColorString(data.rgb, "rgb") && onChange({
            r: values[0],
            g: values[1],
            b: values[2],
            a: 1,
            source: "rgb"
          }, e);
        } else if (data.hsv) {
          var _values = data.hsv.split(",");
          if (isvalidColorString(data.hsv, "hsv")) {
            _values[2] = _values[2].replace("%", "");
            _values[1] = _values[1].replace("%", "");
            _values[0] = _values[0].replace("°", "");
            if (_values[1] == 1) {
              _values[1] = 0.01;
            } else if (_values[2] == 1) {
              _values[2] = 0.01;
            }
            onChange({
              h: Number(_values[0]),
              s: Number(_values[1]),
              v: Number(_values[2]),
              source: "hsv"
            }, e);
          }
        } else if (data.hsl) {
          var _values2 = data.hsl.split(",");
          if (isvalidColorString(data.hsl, "hsl")) {
            _values2[2] = _values2[2].replace("%", "");
            _values2[1] = _values2[1].replace("%", "");
            _values2[0] = _values2[0].replace("°", "");
            if (hsvValue[1] == 1) {
              hsvValue[1] = 0.01;
            } else if (hsvValue[2] == 1) {
              hsvValue[2] = 0.01;
            }
            onChange({
              h: Number(_values2[0]),
              s: Number(_values2[1]),
              v: Number(_values2[2]),
              source: "hsl"
            }, e);
          }
        }
      };
      var styles2 = reactCSS({
        "default": {
          wrap: {
            display: "flex",
            height: "100px",
            marginTop: "4px"
          },
          fields: {
            width: "100%"
          },
          column: {
            paddingTop: "10px",
            display: "flex",
            justifyContent: "space-between"
          },
          double: {
            padding: "0px 4.4px",
            boxSizing: "border-box"
          },
          input: {
            width: "100%",
            height: "38px",
            boxSizing: "border-box",
            padding: "4px 10% 3px",
            textAlign: "center",
            border: "1px solid #dadce0",
            fontSize: "11px",
            textTransform: "lowercase",
            borderRadius: "5px",
            outline: "none",
            fontFamily: "Roboto,Arial,sans-serif"
          },
          input2: {
            height: "38px",
            width: "100%",
            border: "1px solid #dadce0",
            boxSizing: "border-box",
            fontSize: "11px",
            textTransform: "lowercase",
            borderRadius: "5px",
            outline: "none",
            paddingLeft: "10px",
            fontFamily: "Roboto,Arial,sans-serif"
          },
          label: {
            textAlign: "center",
            fontSize: "12px",
            background: "#fff",
            position: "absolute",
            textTransform: "uppercase",
            color: "#3c4043",
            width: "35px",
            top: "-6px",
            left: "0",
            right: "0",
            marginLeft: "auto",
            marginRight: "auto",
            fontFamily: "Roboto,Arial,sans-serif"
          },
          label2: {
            left: "10px",
            textAlign: "center",
            fontSize: "12px",
            background: "#fff",
            position: "absolute",
            textTransform: "uppercase",
            color: "#3c4043",
            width: "32px",
            top: "-6px",
            fontFamily: "Roboto,Arial,sans-serif"
          },
          single: {
            flexGrow: "1",
            margin: "0px 4.4px"
          }
        }
      });
      var rgbValue = rgb.r + ", " + rgb.g + ", " + rgb.b;
      var hslValue = Math.round(hsl.h) + "°, " + Math.round(hsl.s * 100) + "%, " + Math.round(hsl.l * 100) + "%";
      var hsvValue = Math.round(hsv.h) + "°, " + Math.round(hsv.s * 100) + "%, " + Math.round(hsv.v * 100) + "%";
      return React.createElement(
        "div",
        { style: styles2.wrap, className: "flexbox-fix" },
        React.createElement(
          "div",
          { style: styles2.fields },
          React.createElement(
            "div",
            { style: styles2.double },
            React.createElement(EditableInput, {
              style: { input: styles2.input, label: styles2.label },
              label: "hex",
              value: hex,
              onChange: handleChange
            })
          ),
          React.createElement(
            "div",
            { style: styles2.column },
            React.createElement(
              "div",
              { style: styles2.single },
              React.createElement(EditableInput, {
                style: { input: styles2.input2, label: styles2.label2 },
                label: "rgb",
                value: rgbValue,
                onChange: handleChange
              })
            ),
            React.createElement(
              "div",
              { style: styles2.single },
              React.createElement(EditableInput, {
                style: { input: styles2.input2, label: styles2.label2 },
                label: "hsv",
                value: hsvValue,
                onChange: handleChange
              })
            ),
            React.createElement(
              "div",
              { style: styles2.single },
              React.createElement(EditableInput, {
                style: { input: styles2.input2, label: styles2.label2 },
                label: "hsl",
                value: hslValue,
                onChange: handleChange
              })
            )
          )
        )
      );
    };
    var Google = function Google2(_ref) {
      var width = _ref.width, onChange = _ref.onChange, rgb = _ref.rgb, hsl = _ref.hsl, hsv = _ref.hsv, hex = _ref.hex, header2 = _ref.header, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
      var styles2 = reactCSS(merge({
        "default": {
          picker: {
            width,
            background: "#fff",
            border: "1px solid #dfe1e5",
            boxSizing: "initial",
            display: "flex",
            flexWrap: "wrap",
            borderRadius: "8px 8px 0px 0px"
          },
          head: {
            height: "57px",
            width: "100%",
            paddingTop: "16px",
            paddingBottom: "16px",
            paddingLeft: "16px",
            fontSize: "20px",
            boxSizing: "border-box",
            fontFamily: "Roboto-Regular,HelveticaNeue,Arial,sans-serif"
          },
          saturation: {
            width: "70%",
            padding: "0px",
            position: "relative",
            overflow: "hidden"
          },
          swatch: {
            width: "30%",
            height: "228px",
            padding: "0px",
            background: "rgba(" + rgb.r + ", " + rgb.g + ", " + rgb.b + ", 1)",
            position: "relative",
            overflow: "hidden"
          },
          body: {
            margin: "auto",
            width: "95%"
          },
          controls: {
            display: "flex",
            boxSizing: "border-box",
            height: "52px",
            paddingTop: "22px"
          },
          color: {
            width: "32px"
          },
          hue: {
            height: "8px",
            position: "relative",
            margin: "0px 16px 0px 16px",
            width: "100%"
          },
          Hue: {
            radius: "2px"
          }
        }
      }, passedStyles));
      return React.createElement(
        "div",
        { style: styles2.picker, className: "google-picker " + className },
        React.createElement(
          "div",
          { style: styles2.head },
          header2
        ),
        React.createElement("div", { style: styles2.swatch }),
        React.createElement(
          "div",
          { style: styles2.saturation },
          React.createElement(Saturation, {
            hsl,
            hsv,
            pointer: GooglePointerCircle,
            onChange
          })
        ),
        React.createElement(
          "div",
          { style: styles2.body },
          React.createElement(
            "div",
            { style: styles2.controls, className: "flexbox-fix" },
            React.createElement(
              "div",
              { style: styles2.hue },
              React.createElement(Hue, {
                style: styles2.Hue,
                hsl,
                radius: "4px",
                pointer: GooglePointer,
                onChange
              })
            )
          ),
          React.createElement(GoogleFields, {
            rgb,
            hsl,
            hex,
            hsv,
            onChange
          })
        )
      );
    };
    Google.propTypes = {
      width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
      styles: PropTypes.object,
      header: PropTypes.string
    };
    Google.defaultProps = {
      width: 652,
      styles: {},
      header: "Color picker"
    };
    ColorWrap(Google);
    const colorPicker = `_color-picker_d5708d0`;
    const chromePicker = `_chrome-picker_64d34a4`;
    const styles$k = { "color-picker": colorPicker, "chrome-picker": chromePicker };
    React.forwardRef(function ColorPicker2({ color, onColorChange, className, ...props }, ref) {
      const padRef = reactExports.useRef(null);
      const forkedRef = useForkRef(padRef, ref);
      reactExports.useLayoutEffect(() => {
        padRef.current && padRef.current.focus();
      }, []);
      return React.createElement(
        Pad,
        { tabIndex: 0, ref: forkedRef, amount: "8px", height: "auto", width: "auto", className: classNames(styles$k["color-picker"], className), ...props },
        React.createElement(ChromePicker, { className: styles$k["chrome-picker"], color, onChange: onColorChange })
      );
    });
    const checkerBoard = `_checker-board_5f02a4b`;
    const styles$j = { "checker-board": checkerBoard };
    const accordionSummary = `_accordion-summary_f0bd000`;
    const contentSpacer = `_content-spacer_01b02a4`;
    const chevron = `_chevron_5e2cb10`;
    const chevronContainer$1 = `_chevron-container_2411750`;
    const styles$i = { "accordion-summary": accordionSummary, "content-spacer": contentSpacer, chevron, "chevron-container": chevronContainer$1 };
    React.forwardRef(function Accordion({ label, startAdornments, endAdornments, chevronVariant = "start", selected, as, open, onOpen, onClose, children, className, ...props }, ref) {
      const [isOpen, setIsOpen] = reactExports.useState(open);
      const finalLabel = typeof label === "string" ? React.createElement(BodyText, { className: "accordion-label", "data-is-selected": selected, "data-is-open": isOpen, emphasis: selected ? "strong" : "normal" }, label) : label;
      reactExports.useEffect(() => {
        setIsOpen(open);
      }, [open]);
      function toggle() {
        if (isOpen) {
          setIsOpen(false);
          onClose && onClose();
        } else {
          setIsOpen(true);
          onOpen && onOpen();
        }
      }
      const chevron2 = React.createElement(
        "span",
        { "data-variant": chevronVariant, className: classNames(styles$i["chevron-container"], "accordion-chevron-wrapper"), "data-is-open": isOpen },
        React.createElement(Icon, { flipOnRtl: true, "data-is-selected": selected, "data-variant": chevronVariant, "data-is-open": isOpen, className: classNames(styles$i.chevron, "accordion-chevron"), name: chevronVariant === "start" ? "chevron_right" : "chevron_down", size: "20px" })
      );
      return React.createElement(
        VStack,
        { as, ref, height: "auto", horizontalAlignment: "start", className: classNames(className, "accordion"), "data-is-selected": selected, "data-is-open": isOpen, ...props },
        React.createElement(
          HStack,
          { className: classNames(styles$i["accordion-summary"], "accordion-summary"), onClick: toggle, "data-is-selected": selected, "data-is-open": isOpen },
          chevronVariant === "start" && chevron2,
          React.createElement(HStack, { width: "auto" }, startAdornments),
          React.createElement(HStack, { width: "auto" }, finalLabel),
          React.createElement(Spacer, null),
          React.createElement(HStack, { width: "auto" }, endAdornments),
          chevronVariant === "end" && chevron2
        ),
        isOpen && React.createElement(VStack, { height: "auto", "data-is-selected": selected, "data-is-open": isOpen, paddingInlineStart: "14px", className: "accordion-body" }, children)
      );
    });
    const loadingLine = `_loading-line_e963ea2`;
    const linePulse = `_linePulse_273ff7c`;
    const styles$h = { "loading-line": loadingLine, linePulse };
    const Loading = React.forwardRef(({ size = "1em", color = "currentColor", lineCount = 12, animationDuration = 1200, className, style }, ref) => {
      const canvasSize = 50;
      const lines = Array.from({ length: lineCount });
      const angleStep = 360 / lineCount;
      return React.createElement("svg", { ref, width: canvasSize, height: canvasSize, viewBox: `0 0 ${canvasSize} ${canvasSize}`, className, xmlns: "http://www.w3.org/2000/svg", style: { height: size, width: size, ...style }, fill: "none" }, lines.map((_, i) => {
        const angle = angleStep * i;
        const innerRadius = canvasSize / 4.5;
        const outerRadius = canvasSize / 2.25;
        const x1 = canvasSize / 2 + innerRadius * Math.cos(angle * Math.PI / 180);
        const y1 = canvasSize / 2 + innerRadius * Math.sin(angle * Math.PI / 180);
        const x2 = canvasSize / 2 + outerRadius * Math.cos(angle * Math.PI / 180);
        const y2 = canvasSize / 2 + outerRadius * Math.sin(angle * Math.PI / 180);
        return React.createElement("line", { className: styles$h["loading-line"], style: {
          animationDelay: `${i * animationDuration / lineCount}ms`,
          animationDuration: `${animationDuration}ms`
        }, key: i, x1, y1, x2, y2, stroke: color, strokeWidth: 3, strokeLinecap: "round" });
      }));
    });
    const fieldrow = `_fieldrow_8d72787`;
    const styles$g = { fieldrow };
    const Fieldrow = React.forwardRef(function Fieldrow2({ label, value: value2, description, errorMessage, labelWidth = "40%", locked = false, style, className, loading = false, ...props }, ref) {
      if (typeof label === "string") {
        label = React.createElement(BodyText, { breakWords: true }, label);
      }
      if (typeof value2 === "string") {
        value2 = React.createElement(BodyText, { breakWords: true, className: "fieldrow-label-text" }, value2);
      }
      if (typeof description === "string") {
        description = React.createElement(BodyText, { breakWords: true, contrast: "light", variant: "small", className: "fieldrow-description-text" }, description);
      }
      return React.createElement(
        HStack,
        { ref, height: "auto", style, className: classNames(className, styles$g.fieldrow, "fieldrow"), "data-locked": locked, ...props },
        React.createElement(
          HStack,
          { verticalAlignment: "center", horizontalAlignment: "start", minWidth: labelWidth, width: labelWidth },
          React.createElement(
            VStack,
            { height: "auto", horizontalAlignment: "start", className: "fieldrow-label", overflowX: "visible" },
            label,
            description,
            React.createElement(Spacer, { className: styles$g["label-spacer"] })
          ),
          React.createElement(Spacer, null)
        ),
        React.createElement(Spacer, { width: "8px" }),
        React.createElement(
          VStack,
          { height: "auto", verticalAlignment: "center", flex: true },
          React.createElement(
            HStack,
            { height: "auto", horizontalAlignment: "end", className: "fieldrow-value" },
            errorMessage && React.createElement(
              React.Fragment,
              null,
              React.createElement(Spacer, null),
              React.createElement(Icon, { name: "alert_triangle", className: "fieldrow-error-icon", color: "#e0383e", size: "20px" }),
              React.createElement(Spacer, { width: "4px" })
            ),
            !loading ? !locked && value2 : React.createElement(Loading, { size: "20px", className: "fieldrow-loading-icon" }),
            !loading && locked && React.createElement(Icon, { name: "lock_two", className: "fieldrow-locked-icon", size: "20px" })
          ),
          React.createElement(
            HStack,
            { height: "auto" },
            React.createElement(VStack, { height: "auto", horizontalAlignment: "end", flex: true }, errorMessage && React.createElement(
              React.Fragment,
              null,
              React.createElement(Spacer, { height: "4px" }),
              React.createElement(BodyText, { breakWords: true, variant: "small", className: "fieldrow-error-text", color: "#e0383e" }, errorMessage)
            ))
          )
        )
      );
    });
    const fieldset = `_fieldset_17af4ab`;
    const body$1 = `_body_6ba4981`;
    const legend = `_legend_6201385`;
    const styles$f = { fieldset, body: body$1, legend };
    let fieldsetIdCount = 0;
    const Fieldset = React.forwardRef(function Fieldset2({ legend: legend2, startAdornments, endAdornments, children, className, style, width = "100%", height = "auto", minWidth, minHeight, maxWidth, maxHeight, ...props }, ref) {
      const id = reactExports.useMemo(() => {
        return fieldsetIdCount++;
      }, []);
      const labelId = `field-set-${id}`;
      return React.createElement(
        VStack,
        { role: "group", "aria-labelledby": labelId, ref, className: classNames(className, styles$f.fieldset, "fieldset"), minWidth, width, maxWidth, minHeight, height, maxHeight, style, ...props },
        legend2 && React.createElement(
          HStack,
          { id: labelId, className: classNames(styles$f.legend, "legend"), horizontalAlignment: "start", height },
          startAdornments,
          startAdornments && React.createElement(Spacer, { width: "8px" }),
          React.createElement(Header$1, { className: "legend-text" }, legend2),
          endAdornments && React.createElement(Spacer, null),
          endAdornments
        ),
        React.createElement(VStack, { className: classNames(styles$f.body, "fieldset-body"), height: "auto", width, minWidth }, children)
      );
    });
    const accordionFieldrow = `_accordion-fieldrow_a92d854`;
    const chevronContainer = `_chevron-container_9cee87b`;
    const styles$e = { "accordion-fieldrow": accordionFieldrow, "chevron-container": chevronContainer };
    React.forwardRef(function({ label, value: value2, labelWidth, children, onClose, onOpen, open = false, ...props }, ref) {
      function toggle() {
        if (open) {
          onClose && onClose();
        } else {
          onOpen && onOpen();
        }
      }
      return React.createElement(
        VStack,
        { ref, height: "auto", className: "accordion-fieldrow" },
        React.createElement(Fieldrow, { label, labelWidth, className: styles$e["accordion-fieldrow"], onClick: toggle, value: React.createElement(
          HStack,
          { horizontalAlignment: "end" },
          React.createElement(
            Button,
            { variant: "tertiary", style: { paddingInlineEnd: "0px" } },
            React.createElement(
              HStack,
              { inline: true, width: "auto", height: "auto" },
              value2,
              React.createElement(Spacer, { width: "4px" })
            ),
            React.createElement(
              ZStack,
              { height: "auto", width: "auto", className: styles$e["chevron-container"], "data-is-open": open },
              React.createElement(Icon, { name: "chevron_right", size: "20px", flipOnRtl: true })
            )
          )
        ), ...props }),
        open && children
      );
    });
    const tabsHeader = `_tabs-header_6b2c877`;
    const tabsBody = `_tabs-body_6fecb64`;
    const topMargin = `_top-margin_1a231e5`;
    const styles$d = { "tabs-header": tabsHeader, "tabs-body": tabsBody, "top-margin": topMargin };
    React.forwardRef(function Tabs({ children, onTabChange, className, selected, width = "auto", height = "auto", ...props }, ref) {
      const [selectedTabName, setSelectedTabName] = reactExports.useState(selected);
      reactExports.useLayoutEffect(() => {
        setSelectedTabName(selected);
      }, [selected]);
      const childrenArray = React.Children.toArray(children);
      let content = childrenArray.filter((c) => Boolean(c.props.name === selectedTabName));
      let value2 = content.map((c) => c.props.name);
      const options = childrenArray.map((child, index) => {
        const { name: name2, label } = child.props;
        return React.createElement("option", { key: index, value: name2 }, label);
      });
      function changeTab(selected2) {
        if (selected2.length > 0) {
          const selectedTabName2 = selected2[selected2.length - 1];
          setSelectedTabName(selectedTabName2);
          onTabChange && onTabChange(selectedTabName2);
        }
      }
      if (content.length === 0) {
        content = childrenArray;
        value2 = [childrenArray[0].props.name];
      }
      return React.createElement(
        ZStack,
        { ref, inline: true, width, height, className: classNames(styles$d.tabs, className, "tabs"), ...props, verticalAlignment: "start", horizontalAlignment: "center" },
        React.createElement(
          Fieldset,
          { width, height, className: classNames(styles$d["tabs-body"], "tabs-body") },
          React.createElement(
            Box,
            { height: "20px", className: "tabs-header-wrapper" },
            React.createElement(
              HStack,
              { height: "auto", className: classNames(styles$d["tabs-header"], "tabs-header"), horizontalAlignment: "center" },
              React.createElement(SelectGroup, { value: value2, onChange: changeTab, className: "tabs-buttons" }, options)
            )
          ),
          content[0],
          React.createElement(Spacer, { height: "8px" })
        )
      );
    });
    class FieldPresenter {
      constructor(label, value2, options = {}) {
        __publicField(this, "_validate");
        __publicField(this, "_state");
        __publicField(this, "setLabel", (label) => {
          this._state.transform((s) => {
            s.label = label;
            return s;
          });
        });
        __publicField(this, "setDescription", (description) => {
          this._state.transform((s) => {
            s.description = description;
            return s;
          });
        });
        __publicField(this, "setValue", (value2) => {
          this._state.transform((s) => {
            try {
              this._validate && this._validate(value2);
              s.error = null;
            } catch (e) {
              s.error = e.message || e.toString();
            }
            s.value = value2;
            return s;
          });
        });
        __publicField(this, "setError", (error) => {
          this._state.transform((s) => {
            s.error = error;
            s.hasError = error != null;
            return s;
          });
        });
        __publicField(this, "clearError", () => {
          this.setError(null);
        });
        this._validate = options.validate;
        this._state = new Signal({
          label,
          value: value2,
          error: null,
          hasError: false,
          description: options.description
        });
      }
      get stateBroadcast() {
        return this._state.broadcast;
      }
      get state() {
        return this._state.get();
      }
    }
    class OptionsFieldPresenter extends FieldPresenter {
      constructor(label, value2, options) {
        super(label, value2, options);
        __publicField(this, "_options");
        __publicField(this, "optionsValueMap");
        __publicField(this, "optionsLabelMap");
        this.optionsValueMap = /* @__PURE__ */ new Map();
        this.optionsLabelMap = /* @__PURE__ */ new Map();
        this._options = new Signal(options.options || []);
        this._updateOptionsMap(options.options || []);
      }
      get optionsBroadcast() {
        return this._options.broadcast;
      }
      _updateOptionsMap(options) {
        this.optionsValueMap.clear();
        options.forEach((o) => {
          this.optionsValueMap.set(o.label, o.value);
          this.optionsLabelMap.set(o.value, o.label);
        });
      }
      setOptions(options) {
        this._options.set(options);
        this._updateOptionsMap(options);
      }
    }
    React.forwardRef(function SelectRow({ presenter: presenter2, ...props }, ref) {
      const [finalPresenter] = reactExports.useState(() => {
        if (presenter2 == null) {
          return new OptionsFieldPresenter("Label", "option-1", {
            options: [
              { label: "Option 1", value: "option-1" },
              { label: "Option 2", value: "option-2" },
              { label: "Option 3", value: "option-3" }
            ]
          });
        }
        return presenter2;
      });
      const { label, value: value2, description, error } = useSignalValue(finalPresenter.stateBroadcast);
      const options = useSignalValue(finalPresenter.optionsBroadcast);
      const optionElements = options.map((o, index) => {
        return React.createElement("option", { key: index, value: o.label }, o.label);
      });
      function mapSelectedValue(value3) {
        const selectedValue = finalPresenter.optionsValueMap.get(value3);
        selectedValue && finalPresenter.setValue(selectedValue);
      }
      const stringValue = finalPresenter.optionsLabelMap.get(value2);
      return React.createElement(Fieldrow, { ref, label, description, errorMessage: error, value: React.createElement(Select, { ...props, value: stringValue, onChange: mapSelectedValue }, optionElements) });
    });
    React.forwardRef(function MultiselectRow({ presenter: presenter2, ...props }, ref) {
      const [finalPresenter] = reactExports.useState(() => {
        if (presenter2 == null) {
          return new OptionsFieldPresenter("Label", [], {});
        }
        return presenter2;
      });
      const { label, value: value2, description, error } = useSignalValue(finalPresenter.stateBroadcast);
      const options = useSignalValue(finalPresenter.optionsBroadcast);
      const optionElements = options.map((o, index) => {
        return React.createElement("option", { key: index, value: o.label }, o.label);
      });
      function mapSelectedValues(values) {
        const mappedValues = values.map((v) => finalPresenter.optionsValueMap.get(v)).filter((v) => v != null);
        finalPresenter.setValue(mappedValues);
      }
      const stringValues = value2.map((v) => finalPresenter.optionsLabelMap.get(v)).filter((v) => v != null);
      return React.createElement(Fieldrow, { ref, label, description, errorMessage: error, value: React.createElement(Multiselect, { ...props, value: stringValues, onChange: mapSelectedValues }, optionElements) });
    });
    class UnitFieldPresenter extends FieldPresenter {
      constructor(label, value2, options = {}) {
        super(label, value2, options);
        __publicField(this, "_units");
        __publicField(this, "unitsValueMap");
        __publicField(this, "unitsLabelMap");
        this.unitsValueMap = /* @__PURE__ */ new Map();
        this.unitsLabelMap = /* @__PURE__ */ new Map();
        this._units = new Signal(options.units || []);
        this._updateUnitsMap(options.units || []);
      }
      get unitsBroadcast() {
        return this._units.broadcast;
      }
      _updateUnitsMap(options) {
        this.unitsValueMap.clear();
        options.forEach((o) => {
          this.unitsValueMap.set(o.label, o.value);
          this.unitsLabelMap.set(o.value, o.label);
        });
      }
      setUnits(units) {
        this._units.set(units);
        this._updateUnitsMap(units);
      }
    }
    React.forwardRef(function UnitInputRow({ presenter: presenter2, ...props }, ref) {
      const [finalPresenter] = reactExports.useState(() => {
        if (presenter2 == null) {
          return new UnitFieldPresenter("Label", {
            value: null,
            unit: "unit-1"
          }, {
            units: [
              { value: "unit-1", label: "Unit 1" },
              { value: "unit-2", label: "Unit 2" },
              { value: "unit-3", label: "Unit 3" }
            ]
          });
        }
        return presenter2;
      });
      const { label, value: complexValue, description, error } = useSignalValue(finalPresenter.stateBroadcast);
      const units = useSignalValue(finalPresenter.unitsBroadcast);
      const optionElements = units.map((o, index) => {
        return React.createElement("option", { key: index, value: o.label }, o.label);
      });
      function update(value2, unit) {
        finalPresenter.setValue({ value: Number(value2), unit });
      }
      return React.createElement(Fieldrow, { ref, label, description, errorMessage: error, value: React.createElement(UnitInput, { value: complexValue.value, unit: complexValue.unit, onChange: update, ...props }, optionElements) });
    });
    React.forwardRef(function MaskInputRow({ presenter: presenter2, ...props }, ref) {
      const [finalPresenter] = reactExports.useState(() => {
        if (presenter2 == null) {
          return new FieldPresenter("Label", "");
        }
        return presenter2;
      });
      const { label, value: value2, description, error } = useSignalValue(finalPresenter.stateBroadcast);
      function update(value3) {
        finalPresenter.setValue(value3);
      }
      return React.createElement(Fieldrow, { ref, label, description, errorMessage: error, value: React.createElement(MaskInput, { value: value2, ...props, onChange: update }) });
    });
    React.forwardRef(function PhoneNumberInputRow({ presenter: presenter2, ...props }, ref) {
      const [finalPresenter] = reactExports.useState(() => {
        if (presenter2 == null) {
          return new FieldPresenter("Label", "");
        }
        return presenter2;
      });
      const { label, value: value2, description, error } = useSignalValue(finalPresenter.stateBroadcast);
      function update(value3) {
        finalPresenter.setValue(value3);
      }
      return React.createElement(Fieldrow, { ref, label, description, errorMessage: error, value: React.createElement(PhoneNumberInput, { value: value2, ...props, onChange: update }) });
    });
    const bubble$1 = `_bubble_eab9bca`;
    const styles$c = { bubble: bubble$1 };
    const Bubble = React.forwardRef(function Badge({ children, className, style: defaultStyle, backgroundColor, textColor: color, variant = "medium", elevate = false, ...props }, ref) {
      const style = {
        "--bubble-color": color,
        "--bubble-background-color": backgroundColor,
        ...defaultStyle
      };
      return React.createElement(HStack, { inline: true, className: classNames(styles$c.bubble, className, "bubble"), width: "auto", ref, style, horizontalAlignment: "center", verticalAlignment: "center", "data-variant": variant, "data-elevate": elevate, padding: "4px", ...props }, children);
    });
    const bubble = `_bubble_b9fa942`;
    const bublble = `_bublble_21084dc`;
    const styles$b = { bubble, bublble };
    React.forwardRef(({ value: value2, children, backgroundColor, textColor: color, className, ...props }, ref) => {
      return React.createElement(
        ZStack,
        { inline: true, width: "auto", height: "auto", ref, verticalAlignment: "end", horizontalAlignment: "end", zIndex: 0, className: classNames(className, "badge"), ...props },
        React.createElement(ZStack, { zIndex: 0, inline: true, width: "auto", height: "auto" }, children),
        React.createElement(
          VStack,
          { zIndex: 1, height: "100%", width: "auto" },
          React.createElement(Bubble, { className: styles$b.bubble, backgroundColor, textColor: color, elevate: true }, value2),
          React.createElement(Spacer, { height: "100%" })
        )
      );
    });
    const progressBarContainer = `_progress-bar-container_edc8341`;
    const progressBarBackground = `_progress-bar-background_fd5979d`;
    const progressBar = `_progress-bar_31f1a49`;
    const progressBarFill = `_progress-bar-fill_8c1d95c`;
    const moveStripes = `_moveStripes_9c9df4c`;
    const styles$a = { "progress-bar-container": progressBarContainer, "progress-bar-background": progressBarBackground, "progress-bar": progressBar, "progress-bar-fill": progressBarFill, moveStripes };
    React.forwardRef(function ProgressBar({ message, value: value2, ...props }, ref) {
      const progressPercent = `${(value2 * 100).toFixed(0)}%`;
      const styleVariables = { "--progress-percentage": progressPercent };
      return React.createElement(
        VStack,
        { ref, className: styles$a["progress-bar-container"], ...props },
        React.createElement(
          HStack,
          { height: "auto", verticalAlignment: "end" },
          React.createElement(BodyText, null, message),
          React.createElement(Spacer, null),
          React.createElement(Spacer, { width: "8px" }),
          React.createElement(BodyText, { variant: "small", style: { flexShrink: 0 } }, progressPercent)
        ),
        React.createElement(
          ZStack,
          { height: "8px", horizontalAlignment: "start" },
          React.createElement("div", { className: styles$a["progress-bar-background"] }),
          React.createElement("div", { "data-finished": progressPercent === "100%", style: styleVariables, className: styles$a["progress-bar-fill"] }),
          React.createElement("div", { className: styles$a["progress-bar"] })
        )
      );
    });
    const confirm = `_confirm_de98d62`;
    const shake = `_shake_c12b5df`;
    const actions = `_actions_361a552`;
    const styles$9 = { confirm, shake, actions };
    const Confirm = React.forwardRef(function Confirm2({ open, graphic, title, description, actions: actions2, veilProps, className, ...props }, ref) {
      const [shake2, setShake] = reactExports.useState(false);
      reactExports.useLayoutEffect(() => {
        if (shake2) {
          const id = window.setTimeout(() => {
            setShake(false);
          }, 600);
          return () => window.clearTimeout(id);
        }
      }, [shake2]);
      function shakeConfirm() {
        setShake(true);
      }
      return React.createElement(React.Fragment, null, open && React.createElement(
        Portal,
        null,
        React.createElement(
          ZStack,
          { style: { position: "fixed" } },
          React.createElement(Box, { onClick: shakeConfirm, ...veilProps }),
          React.createElement(
            Pad,
            { ref, className: classNames(styles$9.confirm, className, "confirm"), amount: "16px", width: "250px", height: "auto", "data-shake": shake2, ...props },
            React.createElement(
              VStack,
              { horizontalAlignment: "center" },
              graphic,
              React.createElement(Header$1, { className: "confirm-title", emphasis: "strong", variant: "small" }, title),
              React.createElement(BodyText, { className: "confirm-description", contrast: "light" }, description),
              React.createElement(Spacer, { height: "16px" }),
              React.createElement(Box, { className: classNames(styles$9.actions, "confirm-actions"), height: "auto" }, actions2)
            )
          )
        )
      ));
    });
    React.forwardRef(function Alert({ className, onAccept, ...props }, ref) {
      return React.createElement(Confirm, { ref, className: classNames(className, "alert"), ...props, actions: React.createElement(Button, { onClick: onAccept, variant: "primary" }, "OK") });
    });
    const styles$8 = {};
    function TextEditor({ presenter: presenter2 }) {
      const ref = reactExports.useRef(null);
      reactExports.useLayoutEffect(() => {
        if (ref.current != null) {
          presenter2.initialize(ref.current);
        }
        return () => {
          presenter2.dispose();
        };
      }, [presenter2]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { className: styles$8["text-editor"], ref });
    }
    function TestEditor({ presenter: presenter2 }) {
      const patterns = useSignalValue(presenter2.patternsBroadcast);
      const selectedPatternName = useSignalValue(presenter2.selectedPatternBroadcast);
      const options = Object.keys(patterns).map((key, index) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsx("option", { children: key }, index);
      });
      function selectPattern(value2) {
        presenter2.selectPattern(value2);
      }
      options.unshift(/* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "null", children: "-- Choose Pattern To Test --" }, "null"));
      reactExports.useLayoutEffect(() => {
        presenter2.initialize();
      }, [presenter2]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(VStack, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Select, { value: String(selectedPatternName), onChange: selectPattern, children: options }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(FlexBox, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextEditor, { presenter: presenter2.textEditor }) })
      ] });
    }
    function GrammarEditor({ presenter: presenter2 }) {
      reactExports.useLayoutEffect(() => {
        presenter2.initialize();
      }, [presenter2]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(TextEditor, { presenter: presenter2.textEditor });
    }
    const examples = `_examples_d136939`;
    const toolbar = `_toolbar_2e5f768`;
    const grammar$1 = `_grammar_1ac3437`;
    const top = `_top_c68ed06`;
    const left = `_left_26e05bb`;
    const iconButton = `_icon-button_04e2425`;
    const icon = `_icon_bf9fe07`;
    const black = `_black_5086a6c`;
    const styles$7 = { examples, toolbar, grammar: grammar$1, top, left, "icon-button": iconButton, icon, black };
    const panelHeader$2 = `_panel-header_ea787b9`;
    const styles$6 = { "panel-header": panelHeader$2 };
    function PanelHeader({ children, className, style }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(HStack, { height: "auto", verticalAlignment: "center", className: classNames(styles$6["panel-header"], className), style, children });
    }
    const snippets = `_snippets_73f43d3`;
    const snippetHeader = `_snippet-header_6242ed9`;
    const snippetCode = `_snippet-code_aae714b`;
    const styles$5 = { snippets, "snippet-header": snippetHeader, "snippet-code": snippetCode };
    function GrammarExampleHeader({ text }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: styles$5["snippet-header"], children: text });
    }
    function Literal$1() {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(VStack, { height: "auto", horizontalAlignment: "start", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(GrammarExampleHeader, { text: "Literal" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5["snippet-code"], children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "john" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "=" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-literal", children: '"John"' })
        ] })
      ] });
    }
    function Regex$1() {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(VStack, { height: "auto", horizontalAlignment: "start", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(GrammarExampleHeader, { text: "Regular Expression" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5["snippet-code"], children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "space" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "=" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-regex", children: "/\\s+/" })
        ] })
      ] });
    }
    function Options$2() {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(VStack, { height: "auto", horizontalAlignment: "start", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(GrammarExampleHeader, { text: "Options" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5["snippet-code"], children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "john" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "=" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-literal", children: '"John"' })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "jane" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "=" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-literal", children: '"Jane"' })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "name" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "=" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "jane" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " | " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "john" })
          ] })
        ] })
      ] });
    }
    function Sequence$2() {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(VStack, { height: "auto", horizontalAlignment: "start", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(GrammarExampleHeader, { text: "Sequence" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5["snippet-code"], children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "prefix" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "=" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-literal", children: '"I am "' })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "adjective" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "=" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-literal", children: '"happy"' })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "mood" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "=" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "prefix" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " + " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "adjective" })
          ] })
        ] })
      ] });
    }
    function OptionalPattern() {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(VStack, { height: "auto", horizontalAlignment: "start", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(GrammarExampleHeader, { text: "Optional Pattern" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5["snippet-code"], children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "prefix" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "=" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-literal", children: '"I am "' })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "super" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "=" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-literal", children: '"super "' })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "adjective" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "=" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-literal", children: '"happy"' })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "mood" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "=" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "prefix" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " + " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "super" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "? + " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "adjective" })
          ] })
        ] })
      ] });
    }
    function Repeat$1() {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(VStack, { height: "auto", horizontalAlignment: "start", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(GrammarExampleHeader, { text: "Repeat" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5["snippet-code"], children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "name" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "=" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-literal", children: '"John"' })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "comma" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "=" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-literal", children: '", "' })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "zero-or-more" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "=" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            "(",
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "name" }),
            ", ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "comma" }),
            ")*"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "at-least-one-entry" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "=" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            "(",
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "name" }),
            ", ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "comma" }),
            ")+"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "at-least-two-entries" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "=" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            "(",
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "name" }),
            ", ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "comma" }),
            ")",
            `{2,}`
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "between-two-and-four-entries" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "=" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            "(",
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "name" }),
            ", ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "comma" }),
            ")",
            `{2,4}`
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "no-more-than-four-entries" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "=" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            "(",
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "name" }),
            ", ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "comma" }),
            ")",
            `{,4}`
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "trim-divider" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "=" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            "(",
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "name" }),
            ", ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "comma" }),
            " trim)"
          ] })
        ] })
      ] });
    }
    function NegativeLookahead() {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(VStack, { height: "auto", horizontalAlignment: "start", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(GrammarExampleHeader, { text: "Negative Lookahead" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5["snippet-code"], children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "bob" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "=" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-literal", children: '"Bob"' })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "james" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "=" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-literal", children: '"James"' })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "name" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " = !" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "james" }),
            " + ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "bob" })
          ] })
        ] })
      ] });
    }
    function Import() {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(VStack, { height: "auto", horizontalAlignment: "start", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(GrammarExampleHeader, { text: "Import" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5["snippet-code"], children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-keyword", children: "import" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              " ",
              "{",
              " "
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "another-test" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              " ",
              "}",
              " "
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-keyword", children: "from " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-literal", children: '"./test.cpat"' })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "another-test" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "=" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "test" }),
            " | ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-literal", children: '"something else"' })
          ] })
        ] })
      ] });
    }
    function UseParams() {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(VStack, { height: "auto", horizontalAlignment: "start", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(GrammarExampleHeader, { text: "Use Parameters" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5["snippet-code"], children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-keyword", children: "use params " }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              " ",
              "{",
              " "
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "customer-names" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              " ",
              "}",
              " "
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "name" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "=" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "customer-names" }),
            " | ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-literal", children: '"Billy"' })
          ] })
        ] })
      ] });
    }
    function DefineImportParams() {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(VStack, { height: "auto", horizontalAlignment: "start", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(GrammarExampleHeader, { text: "Define Parameters on Import" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5["snippet-code"], children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-keyword", children: "import" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              " ",
              "{",
              " "
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "name" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              " ",
              "}",
              " "
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-keyword", children: "from " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-literal", children: '"./names.cpat"' }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-keyword", children: " with params " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "{" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", style: { whiteSpace: "pre" }, children: "  customer-names" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " = " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-literal", children: '"Anakin"' }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " | " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-literal", children: '"Yoda"' })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "}" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "name-list" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "=" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            "(",
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "name" }),
            ", ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "comma" }),
            " trim)"
          ] })
        ] })
      ] });
    }
    function Comment$1() {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(VStack, { height: "auto", horizontalAlignment: "start", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(GrammarExampleHeader, { text: "Comment" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$5["snippet-code"], children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-comment", children: "# Describe your patterns" }) })
      ] });
    }
    function GreedyOptions() {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(VStack, { height: "auto", horizontalAlignment: "start", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(GrammarExampleHeader, { text: "Greedy Options" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5["snippet-code"], children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-comment", children: "# Will traverse each option and take the longest one" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "john" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "=" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-literal", children: '"John"' })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "jane" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "=" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-literal", children: '"Jane"' })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "name" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "=" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "jane" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              " ",
              "<|>",
              " "
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-name", children: "john" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "syntax-comment", children: "# Potentially computationally expensive, use with care" }) })
        ] })
      ] });
    }
    function Snippets({ className, style }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        VStack,
        {
          flex: true,
          horizontalAlignment: "start",
          overflowY: "auto",
          className: classNames(styles$5["snippets"], className),
          style,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Literal$1, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Regex$1, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Options$2, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Sequence$2, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(OptionalPattern, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Repeat$1, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(NegativeLookahead, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Import, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(UseParams, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(DefineImportParams, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Comment$1, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(GreedyOptions, {})
          ]
        }
      );
    }
    const snippetsSidePanel = `_snippets-side-panel_21e7c82`;
    const panelHeader$1 = `_panel-header_b1868fe`;
    const panelBody$1 = `_panel-body_efe8a3a`;
    const styles$4 = { "snippets-side-panel": snippetsSidePanel, "panel-header": panelHeader$1, "panel-body": panelBody$1 };
    function SnippetsSidePanel({ onClose }) {
      function close() {
        onClose && onClose();
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        VStack,
        {
          className: styles$4["snippets-side-panel"],
          horizontalAlignment: "start",
          overflowY: "hidden",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(PanelHeader, { className: styles$4["panel-header"], children: /* @__PURE__ */ jsxRuntimeExports.jsxs(HStack, { height: "auto", children: [
              "SNIPPETS",
              /* @__PURE__ */ jsxRuntimeExports.jsx(Spacer, {}),
              /* @__PURE__ */ jsxRuntimeExports.jsx(IconButton, { iconSize: "22px", iconName: "cross", onClick: close })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Snippets, { className: styles$4["panel-body"] })
          ]
        }
      );
    }
    const fileExplorerSidePanel = `_file-explorer-side-panel_329ec4f`;
    const panelHeader = `_panel-header_e42105c`;
    const panelBody = `_panel-body_14c219e`;
    const styles$3 = { "file-explorer-side-panel": fileExplorerSidePanel, "panel-header": panelHeader, "panel-body": panelBody };
    function PendingFileCreation({ presenter: presenter2 }) {
      const inputRef = reactExports.useRef(null);
      const name2 = useSignalValue(presenter2.nameBroadcast);
      const error = useSignalValue(presenter2.errorBroadcast);
      function checkForEnter(event) {
        if (event.key === "Enter") {
          presenter2.commit();
        } else if (event.key === "Escape") {
          presenter2.abort();
        }
      }
      function updateName(value2) {
        presenter2.updateName(value2);
      }
      function abort() {
        presenter2.abort();
      }
      reactExports.useEffect(() => {
        const input2 = inputRef.current;
        if (input2 != null) {
          input2.focus();
        }
      }, []);
      const padding2 = (presenter2.directory.split("/").length + 2) * 5;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        VStack,
        {
          height: "auto",
          gap: "8px",
          paddingInlineStart: `${padding2}px`,
          paddingBlock: "6px 6px",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input$1,
              {
                ref: inputRef,
                value: name2,
                onKeyDown: checkForEnter,
                onChange: updateName,
                onBlur: abort
              }
            ),
            error && /* @__PURE__ */ jsxRuntimeExports.jsx(BodyText, { color: "var(--default-error-color)", children: error })
          ]
        }
      );
    }
    const fileItem = `_file-item_7c1f760`;
    const styles$2 = { "file-item": fileItem };
    function PendingFileRenaming({ presenter: presenter2 }) {
      const inputRef = reactExports.useRef(null);
      const name2 = useSignalValue(presenter2.nameBroadcast);
      const error = useSignalValue(presenter2.errorBroadcast);
      function checkForEnter(event) {
        if (event.key === "Enter") {
          presenter2.commit();
        } else if (event.key === "Escape") {
          presenter2.abort();
        }
      }
      function updateName(value2) {
        presenter2.updateName(value2);
      }
      function abort() {
        presenter2.abort();
      }
      reactExports.useEffect(() => {
        const input2 = inputRef.current;
        if (input2 != null) {
          input2.focus();
        }
      }, []);
      const padding2 = (presenter2.directory.split("/").length + 2) * 5;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        VStack,
        {
          height: "auto",
          gap: "8px",
          paddingInlineStart: `${padding2}px`,
          paddingBlock: "6px 6px",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input$1,
              {
                ref: inputRef,
                value: name2,
                onKeyDown: checkForEnter,
                onChange: updateName,
                onBlur: abort
              }
            ),
            error && /* @__PURE__ */ jsxRuntimeExports.jsx(BodyText, { color: "var(--default-error-color)", children: error })
          ]
        }
      );
    }
    function FileItem({ file, presenter: presenter2 }) {
      const focusedItem = useSignalValue(presenter2.focusedItemBroadcast);
      const renamingFilePath = useSignalValue(
        presenter2.pendingFileRenamingBroadcast
      );
      const isFocused = file.path === (focusedItem == null ? void 0 : focusedItem.path);
      const [isOpen, setIsOpen] = reactExports.useState(false);
      const [position, setPosition] = reactExports.useState(null);
      const isRenaming = (renamingFilePath == null ? void 0 : renamingFilePath.filePath) === file.path;
      function selectItem(event) {
        presenter2.focus(file.path);
        event.preventDefault();
        event.stopPropagation();
      }
      function placeMenu(event) {
        setPosition({ x: event.clientX, y: event.clientY });
        setIsOpen(true);
        event.preventDefault();
      }
      function close() {
        setIsOpen(false);
      }
      function deleteFile() {
        presenter2.deleteFile(file.path);
      }
      function renameFile() {
        presenter2.startRenamingFile(file.path);
      }
      const padding2 = (file.path.split("/").length + 1) * 5;
      if (isRenaming) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(PendingFileRenaming, { presenter: renamingFilePath });
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          HStack,
          {
            className: styles$2["file-item"],
            "data-is-focused": isFocused,
            height: "auto",
            onContextMenu: placeMenu,
            onClick: selectItem,
            paddingInlineStart: `${padding2}px`,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { name: "file", size: "25px" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(BodyText, { variant: "large", children: file.name })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(ContextMenu, { open: isOpen, position, onClose: close, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { label: "Rename", onClick: renameFile }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { label: "Delete", onClick: deleteFile })
        ] })
      ] });
    }
    function PendingDirectoryCreation({ presenter: presenter2 }) {
      const inputRef = reactExports.useRef(null);
      const name2 = useSignalValue(presenter2.nameBroadcast);
      const error = useSignalValue(presenter2.errorBroadcast);
      function checkForEnter(event) {
        if (event.key === "Enter") {
          presenter2.commit();
          console.log("Committed");
        } else if (event.key === "Escape") {
          presenter2.abort();
        }
      }
      function updateName(value2) {
        presenter2.updateName(value2);
      }
      function abort() {
        presenter2.abort();
      }
      reactExports.useEffect(() => {
        const input2 = inputRef.current;
        if (input2 != null) {
          input2.focus();
        }
      }, []);
      const padding2 = (presenter2.directory.split("/").length + 2) * 5;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        VStack,
        {
          height: "auto",
          paddingInlineStart: `${padding2}px`,
          paddingBlock: "6px 6px",
          gap: "8px",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input$1,
              {
                ref: inputRef,
                value: name2,
                onKeyDown: checkForEnter,
                onChange: updateName,
                onBlur: abort
              }
            ),
            error && /* @__PURE__ */ jsxRuntimeExports.jsx(BodyText, { color: "--default-error-color", children: error })
          ]
        }
      );
    }
    const directoryItem = `_directory-item_3c48b80`;
    const styles$1 = { "directory-item": directoryItem };
    const SvgChevronDown = (props) => /* @__PURE__ */ reactExports.createElement("svg", { width: "1em", height: "1em", viewBox: "0 0 24 24", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ reactExports.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.46967 8.46967C5.76256 8.17678 6.23744 8.17678 6.53033 8.46967L12 13.9393L17.4697 8.46967C17.7626 8.17678 18.2374 8.17678 18.5303 8.46967C18.8232 8.76256 18.8232 9.23744 18.5303 9.53033L12.5303 15.5303C12.2374 15.8232 11.7626 15.8232 11.4697 15.5303L5.46967 9.53033C5.17678 9.23744 5.17678 8.76256 5.46967 8.46967Z" }));
    const SvgChevronRight = (props) => /* @__PURE__ */ reactExports.createElement("svg", { width: "1em", height: "1em", viewBox: "0 0 24 24", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ reactExports.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.46967 5.46967C9.76256 5.17678 10.2374 5.17678 10.5303 5.46967L16.5303 11.4697C16.8232 11.7626 16.8232 12.2374 16.5303 12.5303L10.5303 18.5303C10.2374 18.8232 9.76256 18.8232 9.46967 18.5303C9.17678 18.2374 9.17678 17.7626 9.46967 17.4697L14.9393 12L9.46967 6.53033C9.17678 6.23744 9.17678 5.76256 9.46967 5.46967Z" }));
    function PendingDirectoryRenaming({ presenter: presenter2 }) {
      const inputRef = reactExports.useRef(null);
      const name2 = useSignalValue(presenter2.nameBroadcast);
      const error = useSignalValue(presenter2.errorBroadcast);
      function checkForEnter(event) {
        if (event.key === "Enter") {
          presenter2.commit();
        } else if (event.key === "Escape") {
          presenter2.abort();
        }
      }
      function updateName(value2) {
        presenter2.updateName(value2);
      }
      function abort() {
        presenter2.abort();
      }
      reactExports.useEffect(() => {
        const input2 = inputRef.current;
        if (input2 != null) {
          input2.focus();
        }
      }, []);
      const padding2 = (presenter2.directory.split("/").length + 2) * 5;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        VStack,
        {
          height: "auto",
          gap: "8px",
          paddingInlineStart: `${padding2}px`,
          paddingBlock: "6px 6px",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input$1,
              {
                ref: inputRef,
                value: name2,
                onKeyDown: checkForEnter,
                onChange: updateName,
                onBlur: abort
              }
            ),
            error && /* @__PURE__ */ jsxRuntimeExports.jsx(BodyText, { color: "var(--default-error-color)", children: error })
          ]
        }
      );
    }
    function DirectoryItem({ directory, presenter: presenter2 }) {
      const focusedItem = useSignalValue(presenter2.focusedItemBroadcast);
      const renamingDirectoryPath = useSignalValue(
        presenter2.pendingDirectoryRenamingBroadcast
      );
      const isFocused = directory.path === (focusedItem == null ? void 0 : focusedItem.path);
      const [isContextMenuOpen, setContextMenuOpen] = reactExports.useState(false);
      const [position, setPosition] = reactExports.useState(null);
      const openMap = useSignalValue(presenter2.openDirectoriesBroadcast);
      const pendingFileCreation = useSignalValue(
        presenter2.pendingFileCreationBroadcast
      );
      const pendingDirectoryCreation = useSignalValue(
        presenter2.pendingDirectoryCreationBroadcast
      );
      const isPending = pendingDirectoryCreation != null || pendingFileCreation != null;
      const isOpen = openMap.get(directory.path);
      const path = directory.path;
      const isRenaming = (renamingDirectoryPath == null ? void 0 : renamingDirectoryPath.directoryPath) === directory.path;
      const children = directory.items.map((i, index) => {
        if (i.type === "directory") {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(DirectoryItem, { directory: i, presenter: presenter2 }, index);
        } else {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(FileItem, { file: i, presenter: presenter2 }, index);
        }
      });
      if (pendingFileCreation != null && pendingFileCreation.directory === directory.path) {
        children.unshift(
          /* @__PURE__ */ jsxRuntimeExports.jsx(PendingFileCreation, { presenter: pendingFileCreation }, -1)
        );
      }
      if (pendingDirectoryCreation != null && pendingDirectoryCreation.directory === directory.path) {
        children.unshift(
          /* @__PURE__ */ jsxRuntimeExports.jsx(PendingDirectoryCreation, { presenter: pendingDirectoryCreation }, -1)
        );
      }
      function selectItem(event) {
        presenter2.toggleDirectory(directory.path);
        presenter2.focus(directory.path);
        event.stopPropagation();
        event.preventDefault();
      }
      function placeMenu(event) {
        setPosition({ x: event.clientX, y: event.clientY });
        setContextMenuOpen(true);
        event.preventDefault();
      }
      function close() {
        setContextMenuOpen(false);
      }
      function deleteDirectory() {
        presenter2.deleteDirectory(directory.path);
      }
      function renameDirectory() {
        presenter2.startRenamingDirectory(directory.path);
      }
      reactExports.useLayoutEffect(() => {
        if (isPending) {
          presenter2.openDirectory(path);
        }
      }, [isPending, presenter2, path]);
      const padding2 = path.split("/").length * 5;
      if (isRenaming) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(PendingDirectoryRenaming, { presenter: renamingDirectoryPath });
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          HStack,
          {
            height: "auto",
            "data-is-focused": isFocused,
            onContextMenu: placeMenu,
            onClick: selectItem,
            className: styles$1["directory-item"],
            paddingInlineStart: `${padding2}px`,
            children: [
              isOpen ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                SvgChevronDown,
                {
                  className: `${styles$7["icon"]} ${styles$7["black"]}`
                }
              ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                SvgChevronRight,
                {
                  className: `${styles$7["icon"]} ${styles$7["black"]}`
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(BodyText, { variant: "large", children: directory.name })
            ]
          }
        ),
        isOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(VStack, { height: "auto", children }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(ContextMenu, { open: isContextMenuOpen, position, onClose: close, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { label: "Delete", onClick: deleteDirectory }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItem, { label: "Rename", onClick: renameDirectory })
        ] })
      ] });
    }
    function RootDirectory({ directory, presenter: presenter2 }) {
      const pendingFileCreation = useSignalValue(presenter2.pendingFileCreationBroadcast);
      const pendingDirectoryCreation = useSignalValue(
        presenter2.pendingDirectoryCreationBroadcast
      );
      const children = directory.items.map((i, index) => {
        if (i.type === "directory") {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(DirectoryItem, { directory: i, presenter: presenter2 }, index);
        } else {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(FileItem, { file: i, presenter: presenter2 }, index);
        }
      });
      if (pendingFileCreation != null && pendingFileCreation.directory === "/") {
        children.unshift(/* @__PURE__ */ jsxRuntimeExports.jsx(PendingFileCreation, { presenter: pendingFileCreation }, -1));
      }
      if (pendingDirectoryCreation != null && pendingDirectoryCreation.directory === "/") {
        children.unshift(
          /* @__PURE__ */ jsxRuntimeExports.jsx(PendingDirectoryCreation, { presenter: pendingDirectoryCreation }, -1)
        );
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
    }
    const SvgFilePlus = (props) => /* @__PURE__ */ reactExports.createElement("svg", { width: "1em", height: "1em", viewBox: "0 0 24 24", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ reactExports.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12.5147 3.74997C12.7983 3.74997 13.0406 3.75062 13.25 3.75331V4.00006V4.05205C13.25 4.95053 13.2499 5.69975 13.3299 6.29453C13.4143 6.92233 13.6 7.48913 14.0555 7.9446C14.5109 8.40007 15.0777 8.58574 15.7055 8.67014C16.3003 8.75011 17.0495 8.75008 17.948 8.75006L18 8.75005H18.2467C18.2494 8.95944 18.25 9.20166 18.25 9.48525V15C18.25 16.4354 18.2484 17.4365 18.1469 18.1919C18.0482 18.9256 17.8678 19.3142 17.591 19.591C17.3142 19.8677 16.9257 20.0482 16.1919 20.1468C15.4365 20.2484 14.4354 20.25 13 20.25H11C9.56458 20.25 8.56347 20.2484 7.80812 20.1468C7.07435 20.0482 6.68577 19.8677 6.40901 19.591C6.13225 19.3142 5.9518 18.9256 5.85315 18.1919C5.75159 17.4365 5.75 16.4354 5.75 15V8.99997C5.75 7.56455 5.75159 6.56344 5.85315 5.80809C5.9518 5.07432 6.13225 4.68574 6.40901 4.40898C6.68577 4.13222 7.07435 3.95177 7.80812 3.85312C8.56347 3.75156 9.56458 3.74997 11 3.74997H12.5147ZM16.7123 5.77294C17.5168 6.57741 17.8431 6.9184 18.0172 7.25005H18C17.036 7.25005 16.3884 7.24846 15.9054 7.18352C15.4439 7.12148 15.2464 7.01425 15.1161 6.88394C14.9858 6.75362 14.8786 6.55612 14.8165 6.09466C14.7516 5.61163 14.75 4.96407 14.75 4.00006V3.98285C15.0816 4.15692 15.4226 4.48326 16.227 5.28766L16.7123 5.77294ZM12.6573 2.24993C13.7451 2.24941 14.501 2.24905 15.1924 2.53542C15.8838 2.8218 16.4181 3.35659 17.1869 4.12613L17.2877 4.227L17.773 4.71228L17.8738 4.81308C18.6434 5.58189 19.1782 6.11617 19.4645 6.80755C19.7509 7.49892 19.7506 8.25487 19.75 9.34264V9.34265V9.48525V15V15.0548V15.0549C19.75 16.4224 19.75 17.5248 19.6335 18.3917C19.5125 19.2918 19.2536 20.0497 18.6517 20.6516C18.0497 21.2535 17.2919 21.5124 16.3918 21.6334C15.5248 21.75 14.4225 21.75 13.0549 21.75H13H11H10.9451C9.57754 21.75 8.47522 21.75 7.60825 21.6334C6.70814 21.5124 5.95027 21.2535 5.34835 20.6516C4.74643 20.0497 4.48754 19.2918 4.36652 18.3917C4.24996 17.5248 4.24998 16.4224 4.25 15.0548V15V8.99997V8.9451C4.24998 7.57751 4.24996 6.47519 4.36652 5.60822C4.48754 4.70811 4.74643 3.95024 5.34835 3.34832C5.95027 2.7464 6.70814 2.48751 7.60825 2.36649C8.47522 2.24993 9.57754 2.24995 10.9451 2.24997H11H12.5147L12.6573 2.24993ZM12.75 11.5001C12.75 11.0858 12.4142 10.7501 12 10.7501C11.5858 10.7501 11.25 11.0858 11.25 11.5001V13.2501H9.5C9.08579 13.2501 8.75 13.5858 8.75 14.0001C8.75 14.4143 9.08579 14.7501 9.5 14.7501H11.25V16.5001C11.25 16.9143 11.5858 17.2501 12 17.2501C12.4142 17.2501 12.75 16.9143 12.75 16.5001V14.7501H14.5C14.9142 14.7501 15.25 14.4143 15.25 14.0001C15.25 13.5858 14.9142 13.2501 14.5 13.2501H12.75V11.5001Z" }));
    const SvgFolderPlus = (props) => /* @__PURE__ */ reactExports.createElement("svg", { width: "1em", height: "1em", viewBox: "0 0 24 24", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ reactExports.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M5.99999 2.24994L5.88419 2.24991C5.06623 2.24964 4.50808 2.24946 4.02942 2.37772C2.73532 2.72447 1.72452 3.73527 1.37777 5.02937C1.24951 5.50803 1.2497 6.06618 1.24996 6.88414L1.24999 6.99994V13.9999V14.0548C1.24997 15.4224 1.24995 16.5247 1.36651 17.3917C1.48753 18.2918 1.74642 19.0497 2.34834 19.6516C2.95026 20.2535 3.70813 20.5124 4.60824 20.6334C5.47521 20.75 6.57753 20.75 7.94512 20.7499H7.99999H16H16.0549C17.4225 20.75 18.5248 20.75 19.3918 20.6334C20.2919 20.5124 21.0497 20.2535 21.6517 19.6516C22.2536 19.0497 22.5125 18.2918 22.6335 17.3917C22.75 16.5247 22.75 15.4224 22.75 14.0548V13.9999V11.9999V11.9451C22.75 10.5775 22.75 9.47516 22.6335 8.60819C22.5125 7.70808 22.2536 6.9502 21.6517 6.34829C21.0497 5.74637 20.2919 5.48748 19.3918 5.36646C18.5248 5.2499 17.4225 5.24992 16.0549 5.24994H16H15.1213C14.2137 5.24994 13.9048 5.24326 13.6259 5.16375C13.4598 5.1164 13.2997 5.05009 13.1487 4.96612C12.8953 4.8251 12.6721 4.61138 12.0303 3.96961L11.9591 3.89836C11.4161 3.35501 11.04 2.97857 10.5806 2.72298C10.329 2.58302 10.0622 2.4725 9.78532 2.39359C9.27974 2.24947 8.74757 2.24965 7.97941 2.24992L7.87867 2.24994H5.99999ZM4.41765 3.82661C4.67973 3.75638 5.02173 3.74994 5.99999 3.74994H7.87867C8.78627 3.74994 9.0952 3.75662 9.37413 3.83613C9.54023 3.88347 9.70033 3.94979 9.85126 4.03376C10.1047 4.17477 10.3279 4.3885 10.9697 5.03027L11.0409 5.10151V5.10153C11.5839 5.64487 11.96 6.0213 12.4194 6.2769C12.671 6.41685 12.9378 6.52738 13.2147 6.60629C13.7203 6.7504 14.2524 6.75022 15.0206 6.74996L15.1213 6.74994H16C17.4354 6.74994 18.4365 6.75153 19.1919 6.85309C19.9257 6.95174 20.3142 7.13219 20.591 7.40895C20.8678 7.68571 21.0482 8.07428 21.1469 8.80806C21.2484 9.56341 21.25 10.5645 21.25 11.9999V13.9999C21.25 15.4354 21.2484 16.4365 21.1469 17.1918C21.0482 17.9256 20.8678 18.3142 20.591 18.5909C20.3142 18.8677 19.9257 19.0481 19.1919 19.1468C18.4365 19.2483 17.4354 19.2499 16 19.2499H7.99999C6.56457 19.2499 5.56346 19.2483 4.80811 19.1468C4.07433 19.0481 3.68576 18.8677 3.409 18.5909C3.13224 18.3142 2.95179 17.9256 2.85314 17.1918C2.75158 16.4365 2.74999 15.4354 2.74999 13.9999V6.99994C2.74999 6.02168 2.75643 5.67968 2.82666 5.4176C3.03471 4.64114 3.64119 4.03466 4.41765 3.82661ZM12.75 10.0001C12.75 9.58585 12.4142 9.25006 12 9.25006C11.5858 9.25006 11.25 9.58585 11.25 10.0001V12.2501H8.99999C8.58578 12.2501 8.24999 12.5858 8.24999 13.0001C8.24999 13.4143 8.58578 13.7501 8.99999 13.7501H11.25V16.0001C11.25 16.4143 11.5858 16.7501 12 16.7501C12.4142 16.7501 12.75 16.4143 12.75 16.0001V13.7501H15C15.4142 13.7501 15.75 13.4143 15.75 13.0001C15.75 12.5858 15.4142 12.2501 15 12.2501H12.75V10.0001Z" }));
    const SvgRefreshCcw = (props) => /* @__PURE__ */ reactExports.createElement("svg", { width: "1em", height: "1em", viewBox: "0 0 24 24", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ reactExports.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4.76986 4.92383C6.36338 3.5959 8.77743 2.25 12 2.25C17.4158 2.25 21.75 6.61682 21.75 12C21.75 12.4142 21.4142 12.75 21 12.75C20.5858 12.75 20.25 12.4142 20.25 12C20.25 7.44205 16.5842 3.75 12 3.75C9.22257 3.75 7.13662 4.9041 5.73014 6.07617C5.24073 6.48401 4.83635 6.89199 4.51757 7.25H7C7.41421 7.25 7.75 7.58579 7.75 8C7.75 8.41421 7.41421 8.75 7 8.75H3C2.58579 8.75 2.25 8.41421 2.25 8V3.5C2.25 3.08579 2.58579 2.75 3 2.75C3.41421 2.75 3.75 3.08579 3.75 3.5V5.87217C4.04305 5.56863 4.38294 5.24627 4.76986 4.92383ZM3 11.25C3.41421 11.25 3.75 11.5858 3.75 12C3.75 16.5563 7.44365 20.25 12 20.25C14.2251 20.25 16.0526 19.13 17.3602 17.9444C17.8176 17.5297 18.2031 17.1142 18.5105 16.75H15.9355C15.5213 16.75 15.1855 16.4142 15.1855 16C15.1855 15.5858 15.5213 15.25 15.9355 15.25H20C20.4142 15.25 20.75 15.5858 20.75 16V20.5C20.75 20.9142 20.4142 21.25 20 21.25C19.5858 21.25 19.25 20.9142 19.25 20.5V18.1789C18.9904 18.4609 18.6959 18.7581 18.3677 19.0556C16.918 20.37 14.7455 21.75 12 21.75C6.61522 21.75 2.25 17.3848 2.25 12C2.25 11.5858 2.58579 11.25 3 11.25Z" }));
    function FileExplorer({ presenter: presenter2 }) {
      const directory = useSignalValue(presenter2.directoryBroadcast);
      function startFileCreation() {
        presenter2.startFileCreation();
      }
      function startDirectoryCreation() {
        presenter2.startDirectoryCreation();
      }
      function refresh() {
        presenter2.refresh();
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        VStack,
        {
          className: styles$3["file-explorer-side-panel"],
          horizontalAlignment: "start",
          overflowY: "hidden",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(PanelHeader, { className: styles$3["panel-header"], children: /* @__PURE__ */ jsxRuntimeExports.jsxs(HStack, { children: [
              "FILE EXPLORER ",
              /* @__PURE__ */ jsxRuntimeExports.jsx(Spacer, {}),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: styles$7["icon-button"], onClick: startFileCreation, children: /* @__PURE__ */ jsxRuntimeExports.jsx(SvgFilePlus, { className: styles$7["icon"] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Spacer, { width: "8px" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: styles$7["icon-button"], onClick: startDirectoryCreation, children: /* @__PURE__ */ jsxRuntimeExports.jsx(SvgFolderPlus, { className: styles$7["icon"] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Spacer, { width: "8px" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: styles$7["icon-button"], onClick: refresh, children: /* @__PURE__ */ jsxRuntimeExports.jsx(SvgRefreshCcw, { className: styles$7["icon"] }) })
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FlexBox, { className: styles$3["panel-body"], children: /* @__PURE__ */ jsxRuntimeExports.jsx(RootDirectory, { directory, presenter: presenter2 }) })
          ]
        }
      );
    }
    const SvgQuestion = (props) => /* @__PURE__ */ reactExports.createElement("svg", { width: "1em", height: "1em", viewBox: "0 0 24 24", fill: "currentColor", xmlns: "http://www.w3.org/2000/svg", ...props }, /* @__PURE__ */ reactExports.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12 3.75C7.44365 3.75 3.75 7.44365 3.75 12C3.75 16.5563 7.44365 20.25 12 20.25C16.5563 20.25 20.25 16.5563 20.25 12C20.25 7.44365 16.5563 3.75 12 3.75ZM2.25 12C2.25 6.61522 6.61522 2.25 12 2.25C17.3848 2.25 21.75 6.61522 21.75 12C21.75 17.3848 17.3848 21.75 12 21.75C6.61522 21.75 2.25 17.3848 2.25 12ZM13 16C13 16.5523 12.5523 17 12 17C11.4477 17 11 16.5523 11 16C11 15.4477 11.4477 15 12 15C12.5523 15 13 15.4477 13 16ZM10.75 10C10.75 9.30964 11.3096 8.75 12 8.75C12.6904 8.75 13.25 9.30964 13.25 10V10.1213C13.25 10.485 13.1055 10.8338 12.8483 11.091L11.4697 12.4697C11.1768 12.7626 11.1768 13.2374 11.4697 13.5303C11.7626 13.8232 12.2374 13.8232 12.5303 13.5303L13.909 12.1517C14.4475 11.6132 14.75 10.8828 14.75 10.1213V10C14.75 8.48122 13.5188 7.25 12 7.25C10.4812 7.25 9.25 8.48122 9.25 10V10.5C9.25 10.9142 9.58579 11.25 10 11.25C10.4142 11.25 10.75 10.9142 10.75 10.5V10Z" }));
    const debuggerHeader = `_debugger-header_54fa375`;
    const playbackSpeed = `_playback-speed_c8aa5c2`;
    const styles = { "debugger-header": debuggerHeader, "playback-speed": playbackSpeed };
    function Debugger({ presenter: presenter2, onComplete }) {
      const isPlaying = useSignalValue(presenter2.isPlayingBroadcast);
      const playbackSpeed2 = 1e3 - useSignalValue(presenter2.playbackSpeedBroadcast) + 300;
      reactExports.useLayoutEffect(() => {
        presenter2.initialize();
      }, [presenter2]);
      function next() {
        presenter2.next();
      }
      function prev() {
        presenter2.previous();
      }
      function start() {
        presenter2.start();
      }
      function end() {
        presenter2.end();
      }
      function stop() {
        presenter2.stop();
      }
      function play() {
        presenter2.play();
      }
      function updatePlaybackSpeed(value2) {
        const numberValue = Number(value2);
        presenter2.setPlaybackSpeed(1e3 - numberValue + 300);
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(VStack, { zIndex: 2, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          HStack,
          {
            height: "40px",
            className: styles["debugger-header"],
            horizontalAlignment: "center",
            padding: "8px",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Spacer, {}),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(ButtonGroup, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: start, children: "Start" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: prev, children: "Previous" }),
                !isPlaying ? /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: play, children: "Play" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: stop, children: "Stop" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: next, children: "Next" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: end, children: "End" })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(HStack, { flex: true, horizontalAlignment: "center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Slider$1,
                {
                  min: "300",
                  max: "1000",
                  value: String(playbackSpeed2),
                  onChange: updatePlaybackSpeed,
                  style: { pointerEvents: "auto", width: "200px" }
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: onComplete, children: "Close" })
            ]
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(HStack, { flex: true, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FlexBox, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(TextEditor, { presenter: presenter2.textEditorPresenter }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { width: "50%", enableResizeOnStart: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Diagram$1,
            {
              presenter: presenter2.diagramPresenter,
              onPatternClick: (patternPath) => {
                presenter2.diagramPresenter.togglePatternPath(patternPath);
              }
            }
          ) })
        ] })
      ] });
    }
    function App({ presenter: presenter2 }) {
      const ast = useSignalValue(presenter2.testEditor.astBroadcast);
      const isDocumentationOpen = useSignalValue(
        presenter2.isDocumentationOpenBroadcast
      );
      const debuggerPresenter = useSignalValue(presenter2.debuggerPresenter);
      const selectedPattern = useSignalValue(
        presenter2.testEditor.selectedPatternBroadcast
      );
      const canDebug = selectedPattern != null || selectedPattern === "null";
      function toggleDocumentation() {
        presenter2.toggleDocumentation();
      }
      reactExports.useLayoutEffect(() => {
        presenter2.initialize();
      }, [presenter2]);
      function closeDocumenation() {
        presenter2.toggleDocumentation();
      }
      function showDebug() {
        presenter2.showDebugger();
      }
      function closeDebug() {
        presenter2.closeDebugger();
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ZStack, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(VStack, { zIndex: 1, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(HStack, { zIndex: 2, className: styles$7.toolbar, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(HStack, { width: "auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Spacer, { width: "8px" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Spacer, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Header$1, { children: "CPAT Playground" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Spacer, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(HStack, { width: "auto", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  className: styles$7["icon-button"],
                  onClick: toggleDocumentation,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(SvgQuestion, { className: styles$7["icon"] })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Spacer, { width: "8px" })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(HStack, { flex: true, zIndex: 1, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Box,
              {
                zIndex: 2,
                className: styles$7.examples,
                minWidth: "100px",
                width: "300px",
                enableResizeOnEnd: true,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(FileExplorer, { presenter: presenter2.fileExplorer })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(VStack, { zIndex: 1, flex: true, overflowX: "hidden", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(HStack, { flex: true, className: styles$7.top, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(FlexBox, { minWidth: "200px", className: styles$7.left, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  GrammarEditor,
                  {
                    presenter: presenter2.grammarEditor
                  }
                ) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { width: "50%", enableResizeOnStart: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Diagram$1,
                  {
                    presenter: presenter2.diagramPresenter,
                    onPatternClick: (path) => {
                      presenter2.diagramPresenter.togglePatternPath(path);
                    }
                  }
                ) })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { height: "50%", enableResizeOnTop: true, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(HStack, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(FlexBox, { minWidth: "200px", className: styles$7.left, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ZStack, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(TestEditor, { presenter: presenter2.testEditor }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    VStack,
                    {
                      padding: "8px",
                      verticalAlignment: "end",
                      horizontalAlignment: "end",
                      style: { pointerEvents: "none" },
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Button,
                        {
                          disabled: !canDebug,
                          onClick: showDebug,
                          style: { pointerEvents: "auto" },
                          children: "Debug"
                        }
                      )
                    }
                  )
                ] }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Box, { width: "50%", enableResizeOnStart: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Ast, { text: ast }) })
              ] }) })
            ] }),
            isDocumentationOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
              Box,
              {
                className: styles$7.examples,
                minWidth: "100px",
                width: "33%",
                enableResizeOnStart: true,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(SnippetsSidePanel, { onClose: closeDocumenation })
              }
            )
          ] })
        ] }),
        debuggerPresenter && /* @__PURE__ */ jsxRuntimeExports.jsx(Debugger, { presenter: debuggerPresenter, onComplete: closeDebug })
      ] }) });
    }
    const Options$1 = {
      DEBUG: false,
      // if true, writes some debug information into attributes
      VS: 8,
      // minimum vertical separation between things. For a 3px stroke, must be at least 4
      AR: 10,
      // radius of arcs
      DIAGRAM_CLASS: "railroad-diagram",
      // class to put on the root <svg>
      STROKE_ODD_PIXEL_LENGTH: true,
      // is the stroke width an odd (1px, 3px, etc) pixel length?
      INTERNAL_ALIGNMENT: "center",
      // how to align items when they have extra space. left/right/center
      CHAR_WIDTH: 8.5,
      // width of each monospace character. play until you find the right value for your font
      COMMENT_CHAR_WIDTH: 7,
      // comments are in smaller text by default
      ESCAPE_HTML: true
      // Should Diagram.toText() produce HTML-escaped text, or raw?
    };
    const defaultCSS = `
	svg {
		background-color: hsl(30,20%,95%);
	}
	path {
		stroke-width: 3;
		stroke: black;
		fill: rgba(0,0,0,0);
	}
	text {
		font: bold 14px monospace;
		text-anchor: middle;
		white-space: pre;
	}
	text.diagram-text {
		font-size: 12px;
	}
	text.diagram-arrow {
		font-size: 16px;
	}
	text.label {
		text-anchor: start;
	}
	text.comment {
		font: italic 12px monospace;
	}
	g.non-terminal text {
		/*font-style: italic;*/
	}
	rect {
		stroke-width: 3;
		stroke: black;
		fill: hsl(120,100%,90%);
	}
	rect.group-box {
		stroke: gray;
		stroke-dasharray: 10 5;
		fill: none;
	}
	path.diagram-text {
		stroke-width: 3;
		stroke: black;
		fill: white;
		cursor: help;
	}
	g.diagram-text:hover path.diagram-text {
		fill: #eee;
	}`;
    class FakeSVG {
      constructor(tagName, attrs, text) {
        if (text) this.children = text;
        else this.children = [];
        this.tagName = tagName;
        this.attrs = unnull(attrs, {});
      }
      format(x, y, width) {
      }
      addTo(parent) {
        if (parent instanceof FakeSVG) {
          parent.children.push(this);
          return this;
        } else {
          var svg = this.toSVG();
          parent.appendChild(svg);
          return svg;
        }
      }
      toSVG() {
        var el = SVG(this.tagName, this.attrs);
        if (typeof this.children == "string") {
          el.textContent = this.children;
        } else {
          this.children.forEach(function(e) {
            el.appendChild(e.toSVG());
          });
        }
        return el;
      }
      toString() {
        var str = "<" + this.tagName;
        var group = this.tagName == "g" || this.tagName == "svg";
        for (var attr in this.attrs) {
          str += " " + attr + '="' + (this.attrs[attr] + "").replace(/&/g, "&amp;").replace(/"/g, "&quot;") + '"';
        }
        str += ">";
        if (group) str += "\n";
        if (typeof this.children == "string") {
          str += escapeString(this.children);
        } else {
          this.children.forEach(function(e) {
            str += e;
          });
        }
        str += "</" + this.tagName + ">\n";
        return str;
      }
      toTextDiagram() {
        return new TextDiagram(0, 0, []);
      }
      toText() {
        var outputTD = this.toTextDiagram();
        var output = outputTD.lines.join("\n") + "\n";
        {
          output = output.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;").replace('"', "&quot;");
        }
        return output;
      }
      walk(cb) {
        cb(this);
      }
    }
    class Path extends FakeSVG {
      constructor(x, y) {
        super("path");
        this.attrs.d = "M" + x + " " + y;
      }
      m(x, y) {
        this.attrs.d += "m" + x + " " + y;
        return this;
      }
      h(val) {
        this.attrs.d += "h" + val;
        return this;
      }
      right(val) {
        return this.h(Math.max(0, val));
      }
      left(val) {
        return this.h(-Math.max(0, val));
      }
      v(val) {
        this.attrs.d += "v" + val;
        return this;
      }
      down(val) {
        return this.v(Math.max(0, val));
      }
      up(val) {
        return this.v(-Math.max(0, val));
      }
      arc(sweep) {
        var x = Options$1.AR;
        var y = Options$1.AR;
        if (sweep[0] == "e" || sweep[1] == "w") {
          x *= -1;
        }
        if (sweep[0] == "s" || sweep[1] == "n") {
          y *= -1;
        }
        var cw;
        if (sweep == "ne" || sweep == "es" || sweep == "sw" || sweep == "wn") {
          cw = 1;
        } else {
          cw = 0;
        }
        this.attrs.d += "a" + Options$1.AR + " " + Options$1.AR + " 0 0 " + cw + " " + x + " " + y;
        return this;
      }
      arc_8(start, dir) {
        const arc = Options$1.AR;
        const s2 = 1 / Math.sqrt(2) * arc;
        const s2inv = arc - s2;
        let path = "a " + arc + " " + arc + " 0 0 " + (dir == "cw" ? "1" : "0") + " ";
        const sd = start + dir;
        const offset = sd == "ncw" ? [s2, s2inv] : sd == "necw" ? [s2inv, s2] : sd == "ecw" ? [-s2inv, s2] : sd == "secw" ? [-s2, s2inv] : sd == "scw" ? [-s2, -s2inv] : sd == "swcw" ? [-s2inv, -s2] : sd == "wcw" ? [s2inv, -s2] : sd == "nwcw" ? [s2, -s2inv] : sd == "nccw" ? [-s2, s2inv] : sd == "nwccw" ? [-s2inv, s2] : sd == "wccw" ? [s2inv, s2] : sd == "swccw" ? [s2, s2inv] : sd == "sccw" ? [s2, -s2inv] : sd == "seccw" ? [s2inv, -s2] : sd == "eccw" ? [-s2inv, -s2] : sd == "neccw" ? [-s2, -s2inv] : null;
        path += offset.join(" ");
        this.attrs.d += path;
        return this;
      }
      l(x, y) {
        this.attrs.d += "l" + x + " " + y;
        return this;
      }
      format() {
        this.attrs.d += "h.5";
        return this;
      }
      toTextDiagram() {
        return new TextDiagram(0, 0, []);
      }
    }
    class DiagramMultiContainer extends FakeSVG {
      constructor(tagName, items, attrs, text) {
        super(tagName, attrs, text);
        this.items = items.map(wrapString);
      }
      walk(cb) {
        cb(this);
        this.items.forEach((x) => x.walk(cb));
      }
    }
    class Diagram extends DiagramMultiContainer {
      constructor(...items) {
        super("svg", items, { class: Options$1.DIAGRAM_CLASS });
        if (!(this.items[0] instanceof Start)) {
          this.items.unshift(new Start());
        }
        if (!(this.items[this.items.length - 1] instanceof End)) {
          this.items.push(new End());
        }
        this.up = this.down = this.height = this.width = 0;
        for (const item of this.items) {
          this.width += item.width + (item.needsSpace ? 20 : 0);
          this.up = Math.max(this.up, item.up - this.height);
          this.height += item.height;
          this.down = Math.max(this.down - item.height, item.down);
        }
        this.formatted = false;
      }
      format(paddingt, paddingr, paddingb, paddingl) {
        paddingt = unnull(paddingt, 20);
        paddingr = unnull(paddingr, paddingt, 20);
        paddingb = unnull(paddingb, paddingt, 20);
        paddingl = unnull(paddingl, paddingr, 20);
        var x = paddingl;
        var y = paddingt;
        y += this.up;
        var g = new FakeSVG("g", { transform: "translate(.5 .5)" });
        for (var i = 0; i < this.items.length; i++) {
          var item = this.items[i];
          if (item.needsSpace) {
            new Path(x, y).h(10).addTo(g);
            x += 10;
          }
          item.format(x, y, item.width).addTo(g);
          x += item.width;
          y += item.height;
          if (item.needsSpace) {
            new Path(x, y).h(10).addTo(g);
            x += 10;
          }
        }
        this.attrs.width = this.width + paddingl + paddingr;
        this.attrs.height = this.up + this.height + this.down + paddingt + paddingb;
        this.attrs.viewBox = "0 0 " + this.attrs.width + " " + this.attrs.height;
        g.addTo(this);
        this.formatted = true;
        return this;
      }
      addTo(parent) {
        if (!parent) {
          var scriptTag = document.getElementsByTagName("script");
          scriptTag = scriptTag[scriptTag.length - 1];
          parent = scriptTag.parentNode;
        }
        return super.addTo.call(this, parent);
      }
      toSVG() {
        if (!this.formatted) {
          this.format();
        }
        return super.toSVG.call(this);
      }
      toString() {
        if (!this.formatted) {
          this.format();
        }
        return super.toString.call(this);
      }
      toStandalone(style) {
        if (!this.formatted) {
          this.format();
        }
        const s = new FakeSVG("style", {}, style || defaultCSS);
        this.children.push(s);
        this.attrs.xmlns = "http://www.w3.org/2000/svg";
        this.attrs["xmlns:xlink"] = "http://www.w3.org/1999/xlink";
        const result = super.toString.call(this);
        this.children.pop();
        delete this.attrs.xmlns;
        return result;
      }
      toTextDiagram() {
        var [separator] = TextDiagram._getParts(["separator"]);
        var diagramTD = this.items[0].toTextDiagram();
        for (const item of this.items.slice(1)) {
          var itemTD = item.toTextDiagram();
          if (item.needsSpace) {
            itemTD = itemTD.expand(1, 1, 0, 0);
          }
          diagramTD = diagramTD.appendRight(itemTD, separator);
        }
        return diagramTD;
      }
    }
    let Sequence$1 = class Sequence extends DiagramMultiContainer {
      constructor(...items) {
        super("g", items);
        this.items.length;
        this.needsSpace = true;
        this.up = this.down = this.height = this.width = 0;
        for (var i = 0; i < this.items.length; i++) {
          var item = this.items[i];
          this.width += item.width + (item.needsSpace ? 20 : 0);
          this.up = Math.max(this.up, item.up - this.height);
          this.height += item.height;
          this.down = Math.max(this.down - item.height, item.down);
        }
        if (this.items[0].needsSpace) this.width -= 10;
        if (this.items[this.items.length - 1].needsSpace) this.width -= 10;
      }
      format(x, y, width) {
        var gaps = determineGaps(width, this.width);
        new Path(x, y).h(gaps[0]).addTo(this);
        new Path(x + gaps[0] + this.width, y + this.height).h(gaps[1]).addTo(this);
        x += gaps[0];
        for (var i = 0; i < this.items.length; i++) {
          var item = this.items[i];
          if (item.needsSpace && i > 0) {
            new Path(x, y).h(10).addTo(this);
            x += 10;
          }
          item.format(x, y, item.width).addTo(this);
          x += item.width;
          y += item.height;
          if (item.needsSpace && i < this.items.length - 1) {
            new Path(x, y).h(10).addTo(this);
            x += 10;
          }
        }
        return this;
      }
      toTextDiagram() {
        var [separator] = TextDiagram._getParts(["separator"]);
        var diagramTD = new TextDiagram(0, 0, [""]);
        for (const item of this.items) {
          var itemTD = item.toTextDiagram();
          if (item.needsSpace) {
            itemTD = itemTD.expand(1, 1, 0, 0);
          }
          diagramTD = diagramTD.appendRight(itemTD, separator);
        }
        return diagramTD;
      }
    };
    class Choice extends DiagramMultiContainer {
      constructor(normal, ...items) {
        super("g", items);
        if (typeof normal !== "number" || normal !== Math.floor(normal)) {
          throw new TypeError("The first argument of Choice() must be an integer.");
        } else if (normal < 0 || normal >= items.length) {
          throw new RangeError("The first argument of Choice() must be an index for one of the items.");
        } else {
          this.normal = normal;
        }
        this.width = max$1(this.items, (el) => el.width) + Options$1.AR * 4;
        var firstItem = this.items[0];
        var lastItem = this.items[items.length - 1];
        var normalItem = this.items[normal];
        this.separators = Array.from({ length: items.length - 1 }, (x) => 0);
        this.up = 0;
        var arcs;
        for (var i = normal - 1; i >= 0; i--) {
          if (i == normal - 1) arcs = Options$1.AR * 2;
          else arcs = Options$1.AR;
          let item = this.items[i];
          let lowerItem = this.items[i + 1];
          let entryDelta = lowerItem.up + Options$1.VS + item.down + item.height;
          let exitDelta = lowerItem.height + lowerItem.up + Options$1.VS + item.down;
          let separator = Options$1.VS;
          if (exitDelta < arcs || entryDelta < arcs) {
            separator += Math.max(arcs - entryDelta, arcs - exitDelta);
          }
          this.separators[i] = separator;
          this.up += lowerItem.up + separator + item.down + item.height;
        }
        this.up += firstItem.up;
        this.height = normalItem.height;
        this.down = 0;
        for (var i = normal + 1; i < this.items.length; i++) {
          if (i == normal + 1) arcs = Options$1.AR * 2;
          else arcs = Options$1.AR;
          let item = this.items[i];
          let upperItem = this.items[i - 1];
          let entryDelta = upperItem.height + upperItem.down + Options$1.VS + item.up;
          let exitDelta = upperItem.down + Options$1.VS + item.up + item.height;
          let separator = Options$1.VS;
          if (entryDelta < arcs || exitDelta < arcs) {
            separator += Math.max(arcs - entryDelta, arcs - exitDelta);
          }
          this.separators[i - 1] = separator;
          this.down += upperItem.down + separator + item.up + item.height;
        }
        this.down += lastItem.down;
      }
      format(x, y, width) {
        var gaps = determineGaps(width, this.width);
        new Path(x, y).h(gaps[0]).addTo(this);
        new Path(x + gaps[0] + this.width, y + this.height).h(gaps[1]).addTo(this);
        x += gaps[0];
        var last = this.items.length - 1;
        var innerWidth = this.width - Options$1.AR * 4;
        var distanceFromY = 0;
        for (var i = this.normal - 1; i >= 0; i--) {
          let item = this.items[i];
          let lowerItem = this.items[i + 1];
          distanceFromY += lowerItem.up + this.separators[i] + item.down + item.height;
          new Path(x, y).arc("se").up(distanceFromY - Options$1.AR * 2).arc("wn").addTo(this);
          item.format(x + Options$1.AR * 2, y - distanceFromY, innerWidth).addTo(this);
          new Path(x + Options$1.AR * 2 + innerWidth, y - distanceFromY + item.height).arc("ne").down(distanceFromY - item.height + this.height - Options$1.AR * 2).arc("ws").addTo(this);
        }
        new Path(x, y).right(Options$1.AR * 2).addTo(this);
        this.items[this.normal].format(x + Options$1.AR * 2, y, innerWidth).addTo(this);
        new Path(x + Options$1.AR * 2 + innerWidth, y + this.height).right(Options$1.AR * 2).addTo(this);
        var distanceFromY = 0;
        for (var i = this.normal + 1; i <= last; i++) {
          let item = this.items[i];
          let upperItem = this.items[i - 1];
          distanceFromY += upperItem.height + upperItem.down + this.separators[i - 1] + item.up;
          new Path(x, y).arc("ne").down(distanceFromY - Options$1.AR * 2).arc("ws").addTo(this);
          if (!item.format) console.log(item);
          item.format(x + Options$1.AR * 2, y + distanceFromY, innerWidth).addTo(this);
          new Path(x + Options$1.AR * 2 + innerWidth, y + distanceFromY + item.height).arc("se").up(distanceFromY - Options$1.AR * 2 + item.height - this.height).arc("wn").addTo(this);
        }
        return this;
      }
      toTextDiagram() {
        var [cross, line, line_vertical, roundcorner_bot_left, roundcorner_bot_right, roundcorner_top_left, roundcorner_top_right] = TextDiagram._getParts(["cross", "line", "line_vertical", "roundcorner_bot_left", "roundcorner_bot_right", "roundcorner_top_left", "roundcorner_top_right"]);
        var itemTDs = [];
        for (const item of this.items) {
          itemTDs.push(item.toTextDiagram().expand(1, 1, 0, 0));
        }
        var max_item_width = Math.max(...itemTDs.map(function(itemTD2) {
          return itemTD2.width;
        }));
        var diagramTD = new TextDiagram(0, 0, []);
        for (var [itemNum, itemTD] of enumerate(itemTDs)) {
          var [leftPad, rightPad] = TextDiagram._gaps(max_item_width, itemTD.width);
          itemTD = itemTD.expand(leftPad, rightPad, 0, 0);
          var hasSeparator = true;
          var leftLines = [];
          var rightLines = [];
          for (var i = 0; i < itemTD.height; i++) {
            leftLines.push(line_vertical);
            rightLines.push(line_vertical);
          }
          var moveEntry = false;
          var moveExit = false;
          if (itemNum <= this.normal) {
            leftLines[itemTD.entry] = roundcorner_top_left;
            rightLines[itemTD.exit] = roundcorner_top_right;
            if (itemNum == 0) {
              hasSeparator = false;
              for (i = 0; i < itemTD.entry; i++) {
                leftLines[i] = " ";
              }
              for (i = 0; i < itemTD.exit; i++) {
                rightLines[i] = " ";
              }
            }
          }
          if (itemNum >= this.normal) {
            leftLines[itemTD.entry] = roundcorner_bot_left;
            rightLines[itemTD.exit] = roundcorner_bot_right;
            if (itemNum == 0) {
              hasSeparator = false;
            }
            if (itemNum == this.items.length - 1) {
              for (i = itemTD.entry + 1; i < itemTD.height; i++) {
                leftLines[i] = " ";
              }
              for (i = itemTD.exit + 1; i < itemTD.height; i++) {
                rightLines[i] = " ";
              }
            }
          }
          if (itemNum == this.normal) {
            leftLines[itemTD.entry] = cross;
            rightLines[itemTD.exit] = cross;
            moveEntry = true;
            moveExit = true;
            if (itemNum == 0 && itemNum == this.items.length - 1) {
              leftLines[itemTD.entry] = line;
              rightLines[itemTD.exit] = line;
            } else if (itemNum == 0) {
              leftLines[itemTD.entry] = roundcorner_top_right;
              rightLines[itemTD.exit] = roundcorner_top_left;
            } else if (itemNum == this.items.length - 1) {
              leftLines[itemTD.entry] = roundcorner_bot_right;
              rightLines[itemTD.exit] = roundcorner_bot_left;
            }
          }
          var leftJointTD = new TextDiagram(itemTD.entry, itemTD.entry, leftLines);
          var rightJointTD = new TextDiagram(itemTD.exit, itemTD.exit, rightLines);
          itemTD = leftJointTD.appendRight(itemTD, "").appendRight(rightJointTD, "");
          var separator = hasSeparator ? [line_vertical + " ".repeat(TextDiagram._maxWidth(diagramTD, itemTD) - 2) + line_vertical] : [];
          diagramTD = diagramTD.appendBelow(itemTD, separator, moveEntry, moveExit);
        }
        return diagramTD;
      }
    }
    let Optional$1 = class Optional extends FakeSVG {
      constructor(item, skip) {
        if (skip === void 0)
          return new Choice(1, new Skip(), item);
        else if (skip === "skip")
          return new Choice(0, new Skip(), item);
        else
          throw "Unknown value for Optional()'s 'skip' argument.";
      }
    };
    class OneOrMore extends FakeSVG {
      constructor(item, rep) {
        super("g");
        rep = rep || new Skip();
        this.item = wrapString(item);
        this.rep = wrapString(rep);
        this.width = Math.max(this.item.width, this.rep.width) + Options$1.AR * 2;
        this.height = this.item.height;
        this.up = this.item.up;
        this.down = Math.max(Options$1.AR * 2, this.item.down + Options$1.VS + this.rep.up + this.rep.height + this.rep.down);
        this.needsSpace = true;
      }
      format(x, y, width) {
        var gaps = determineGaps(width, this.width);
        new Path(x, y).h(gaps[0]).addTo(this);
        new Path(x + gaps[0] + this.width, y + this.height).h(gaps[1]).addTo(this);
        x += gaps[0];
        new Path(x, y).right(Options$1.AR).addTo(this);
        this.item.format(x + Options$1.AR, y, this.width - Options$1.AR * 2).addTo(this);
        new Path(x + this.width - Options$1.AR, y + this.height).right(Options$1.AR).addTo(this);
        var distanceFromY = Math.max(Options$1.AR * 2, this.item.height + this.item.down + Options$1.VS + this.rep.up);
        new Path(x + Options$1.AR, y).arc("nw").down(distanceFromY - Options$1.AR * 2).arc("ws").addTo(this);
        this.rep.format(x + Options$1.AR, y + distanceFromY, this.width - Options$1.AR * 2).addTo(this);
        new Path(x + this.width - Options$1.AR, y + distanceFromY + this.rep.height).arc("se").up(distanceFromY - Options$1.AR * 2 + this.rep.height - this.item.height).arc("en").addTo(this);
        return this;
      }
      toTextDiagram() {
        var [line, repeat_top_left, repeat_left, repeat_bot_left, repeat_top_right, repeat_right, repeat_bot_right] = TextDiagram._getParts(["line", "repeat_top_left", "repeat_left", "repeat_bot_left", "repeat_top_right", "repeat_right", "repeat_bot_right"]);
        var itemTD = this.item.toTextDiagram();
        var repeatTD = this.rep.toTextDiagram();
        var fIRWidth = TextDiagram._maxWidth(itemTD, repeatTD);
        repeatTD = repeatTD.expand(0, fIRWidth - repeatTD.width, 0, 0);
        itemTD = itemTD.expand(0, fIRWidth - itemTD.width, 0, 0);
        var itemAndRepeatTD = itemTD.appendBelow(repeatTD, []);
        var leftLines = [];
        leftLines.push(repeat_top_left + line);
        for (var i = 0; i < itemTD.height - itemTD.entry + repeatTD.entry - 1; i++) {
          leftLines.push(repeat_left + " ");
        }
        leftLines.push(repeat_bot_left + line);
        var leftTD = new TextDiagram(0, 0, leftLines);
        leftTD = leftTD.appendRight(itemAndRepeatTD, "");
        var rightLines = [];
        rightLines.push(line + repeat_top_right);
        for (i = 0; i < itemTD.height - itemTD.exit + repeatTD.exit - 1; i++) {
          rightLines.push(" " + repeat_right);
        }
        rightLines.push(line + repeat_bot_right);
        var rightTD = new TextDiagram(0, 0, rightLines);
        var diagramTD = leftTD.appendRight(rightTD, "");
        return diagramTD;
      }
      walk(cb) {
        cb(this);
        this.item.walk(cb);
        this.rep.walk(cb);
      }
    }
    class Group extends FakeSVG {
      constructor(item, label) {
        super("g");
        this.item = wrapString(item);
        this.label = label instanceof FakeSVG ? label : label ? new Comment(label) : void 0;
        this.width = Math.max(
          this.item.width + (this.item.needsSpace ? 20 : 0),
          this.label ? this.label.width : 0,
          Options$1.AR * 2
        );
        this.height = this.item.height;
        this.boxUp = this.up = Math.max(this.item.up + Options$1.VS, Options$1.AR);
        if (this.label) {
          this.up += this.label.up + this.label.height + this.label.down;
        }
        this.down = Math.max(this.item.down + Options$1.VS, Options$1.AR);
        this.needsSpace = true;
      }
      format(x, y, width) {
        var gaps = determineGaps(width, this.width);
        new Path(x, y).h(gaps[0]).addTo(this);
        new Path(x + gaps[0] + this.width, y + this.height).h(gaps[1]).addTo(this);
        x += gaps[0];
        new FakeSVG("rect", {
          x,
          y: y - this.boxUp,
          width: this.width,
          height: this.boxUp + this.height + this.down,
          rx: Options$1.AR,
          ry: Options$1.AR,
          "class": "group-box"
        }).addTo(this);
        this.item.format(x, y, this.width).addTo(this);
        if (this.label) {
          this.label.format(
            x,
            y - (this.boxUp + this.label.down + this.label.height),
            this.label.width
          ).addTo(this);
        }
        return this;
      }
      toTextDiagram() {
        var diagramTD = TextDiagram.roundrect(this.item.toTextDiagram(), true);
        if (this.label != void 0) {
          var labelTD = this.label.toTextDiagram();
          diagramTD = labelTD.appendBelow(diagramTD, [], true, true).expand(0, 0, 1, 0);
        }
        return diagramTD;
      }
      walk(cb) {
        cb(this);
        this.item.walk(cb);
        this.label.walk(cb);
      }
    }
    class Start extends FakeSVG {
      constructor({ type = "simple", label } = {}) {
        super("g");
        this.width = 20;
        this.height = 0;
        this.up = 10;
        this.down = 10;
        this.type = type;
        if (label) {
          this.label = "" + label;
          this.width = Math.max(20, this.label.length * Options$1.CHAR_WIDTH + 10);
        }
      }
      format(x, y) {
        let path = new Path(x, y - 10);
        if (this.type === "complex") {
          path.down(20).m(0, -10).right(this.width).addTo(this);
        } else {
          path.down(20).m(10, -20).down(20).m(-10, -10).right(this.width).addTo(this);
        }
        if (this.label) {
          new FakeSVG("text", { x, y: y - 15, style: "text-anchor:start" }, this.label).addTo(this);
        }
        return this;
      }
      toTextDiagram() {
        var [cross, line, tee_right] = TextDiagram._getParts(["cross", "line", "tee_right"]);
        if (this.type === "simple") {
          var start = tee_right + cross + line;
        } else {
          start = tee_right + line;
        }
        var labelTD = new TextDiagram(0, 0, []);
        if (this.label != void 0) {
          labelTD = new TextDiagram(0, 0, [this.label]);
          start = TextDiagram._padR(start, labelTD.width, line);
        }
        var startTD = new TextDiagram(0, 0, [start]);
        return labelTD.appendBelow(startTD, [], true, true);
      }
    }
    class End extends FakeSVG {
      constructor({ type = "simple" } = {}) {
        super("path");
        this.width = 20;
        this.height = 0;
        this.up = 10;
        this.down = 10;
        this.type = type;
      }
      format(x, y) {
        if (this.type === "complex") {
          this.attrs.d = "M " + x + " " + y + " h 20 m 0 -10 v 20";
        } else {
          this.attrs.d = "M " + x + " " + y + " h 20 m -10 -10 v 20 m 10 -20 v 20";
        }
        return this;
      }
      toTextDiagram() {
        var [cross, line, tee_left] = TextDiagram._getParts(["cross", "line", "tee_left"]);
        if (this.type === "simple") {
          var end = line + cross + tee_left;
        } else {
          end = line + tee_left;
        }
        return new TextDiagram(0, 0, [end]);
      }
    }
    class Terminal extends FakeSVG {
      constructor(text, { href, title, cls } = {}) {
        super("g", { "class": ["terminal", cls].join(" ") });
        this.text = "" + text;
        this.href = href;
        this.title = title;
        this.cls = cls;
        this.width = this.text.length * Options$1.CHAR_WIDTH + 20;
        this.height = 0;
        this.up = 11;
        this.down = 11;
        this.needsSpace = true;
      }
      format(x, y, width) {
        var gaps = determineGaps(width, this.width);
        new Path(x, y).h(gaps[0]).addTo(this);
        new Path(x + gaps[0] + this.width, y).h(gaps[1]).addTo(this);
        x += gaps[0];
        new FakeSVG("rect", { x, y: y - 11, width: this.width, height: this.up + this.down, rx: 10, ry: 10 }).addTo(this);
        var text = new FakeSVG("text", { x: x + this.width / 2, y: y + 4 }, this.text);
        if (this.href)
          new FakeSVG("a", { "xlink:href": this.href }, [text]).addTo(this);
        else
          text.addTo(this);
        if (this.title)
          new FakeSVG("title", {}, [this.title]).addTo(this);
        return this;
      }
      toTextDiagram() {
        return TextDiagram.roundrect(this.text);
      }
    }
    class Comment extends FakeSVG {
      constructor(text, { href, title, cls = "" } = {}) {
        super("g", { "class": ["comment", cls].join(" ") });
        this.text = "" + text;
        this.href = href;
        this.title = title;
        this.cls = cls;
        this.width = this.text.length * Options$1.COMMENT_CHAR_WIDTH + 10;
        this.height = 0;
        this.up = 8;
        this.down = 8;
        this.needsSpace = true;
      }
      format(x, y, width) {
        var gaps = determineGaps(width, this.width);
        new Path(x, y).h(gaps[0]).addTo(this);
        new Path(x + gaps[0] + this.width, y + this.height).h(gaps[1]).addTo(this);
        x += gaps[0];
        var text = new FakeSVG("text", { x: x + this.width / 2, y: y + 5, class: "comment" }, this.text);
        if (this.href)
          new FakeSVG("a", { "xlink:href": this.href }, [text]).addTo(this);
        else
          text.addTo(this);
        if (this.title)
          new FakeSVG("title", {}, this.title).addTo(this);
        return this;
      }
      toTextDiagram() {
        return new TextDiagram(0, 0, [this.text]);
      }
    }
    class Skip extends FakeSVG {
      constructor() {
        super("g");
        this.width = 0;
        this.height = 0;
        this.up = 0;
        this.down = 0;
        this.needsSpace = false;
      }
      format(x, y, width) {
        new Path(x, y).right(width).addTo(this);
        return this;
      }
      toTextDiagram() {
        var [line] = TextDiagram._getParts(["line"]);
        return new TextDiagram(0, 0, [line]);
      }
    }
    const _TextDiagram = class _TextDiagram {
      constructor(entry, exit, lines) {
        this.entry = entry;
        this.exit = exit;
        this.height = lines.length;
        this.lines = Array.from(lines);
        this.width = lines.length > 0 ? lines[0].length : 0;
        if (entry > lines.length) {
          throw new Error("Entry is not within diagram vertically:\n" + this._dump(false));
        }
        if (exit > lines.length) {
          throw new Error("Exit is not within diagram vertically:\n" + this._dump(false));
        }
        for (var i = 0; i < lines.length; i++) {
          if (lines[0].length != lines[i].length) {
            throw new Error("Diagram data is not rectangular:\n" + this._dump(false));
          }
        }
      }
      alter(entry = null, exit = null, lines = null) {
        var newEntry = entry || this.entry;
        var newExit = exit || this.exit;
        var newLines = lines || this.lines;
        return new _TextDiagram(newEntry, newExit, Array.from(newLines));
      }
      appendBelow(item, linesBetween, moveEntry = false, moveExit = false) {
        var newWidth = Math.max(this.width, item.width);
        var newLines = [];
        var centeredLines = this.center(newWidth, " ").lines;
        for (const line of centeredLines) {
          newLines.push(line);
        }
        for (const line of linesBetween) {
          newLines.push(_TextDiagram._padR(line, newWidth, " "));
        }
        centeredLines = item.center(newWidth, " ").lines;
        for (const line of centeredLines) {
          newLines.push(line);
        }
        var newEntry = moveEntry ? this.height + linesBetween.length + item.entry : this.entry;
        var newExit = moveExit ? this.height + linesBetween.length + item.exit : this.exit;
        return new _TextDiagram(newEntry, newExit, newLines);
      }
      appendRight(item, charsBetween) {
        var joinLine = Math.max(this.exit, item.entry);
        var newHeight = Math.max(this.height - this.exit, item.height - item.entry) + joinLine;
        var leftTopAdd = joinLine - this.exit;
        var leftBotAdd = newHeight - this.height - leftTopAdd;
        var rightTopAdd = joinLine - item.entry;
        var rightBotAdd = newHeight - item.height - rightTopAdd;
        var left2 = this.expand(0, 0, leftTopAdd, leftBotAdd);
        var right = item.expand(0, 0, rightTopAdd, rightBotAdd);
        var newLines = [];
        for (var i = 0; i < newHeight; i++) {
          var sep = i != joinLine ? " ".repeat(charsBetween.length) : charsBetween;
          newLines.push(left2.lines[i] + sep + right.lines[i]);
        }
        var newEntry = this.entry + leftTopAdd;
        var newExit = item.exit + rightTopAdd;
        return new _TextDiagram(newEntry, newExit, newLines);
      }
      center(width, pad) {
        if (width < this.width) {
          throw new Error("Cannot center into smaller width");
        }
        if (width === this.width) {
          return this.copy();
        } else {
          var totalPadding = width - this.width;
          var leftWidth = Math.trunc(totalPadding / 2);
          var left2 = [];
          for (var i = 0; i < this.height; i++) {
            left2.push(pad.repeat(leftWidth));
          }
          var right = [];
          for (i = 0; i < this.height; i++) {
            right.push(pad.repeat(totalPadding - leftWidth));
          }
          return new _TextDiagram(this.entry, this.exit, _TextDiagram._encloseLines(this.lines, left2, right));
        }
      }
      copy() {
        return new _TextDiagram(this.entry, this.exit, Array.from(this.lines));
      }
      expand(left2, right, top2, bottom) {
        if (left2 < 0 || right < 0 || top2 < 0 || bottom < 0) {
          throw new Error("Expansion values cannot be negative");
        }
        if (left2 + right + top2 + bottom === 0) {
          return this.copy();
        } else {
          var line = _TextDiagram.parts["line"];
          var newLines = [];
          for (var i = 0; i < top2; i++) {
            newLines.push(" ".repeat(this.width + left2 + right));
          }
          for (i = 0; i < this.height; i++) {
            var leftExpansion = i === this.entry ? line : " ";
            var rightExpansion = i === this.exit ? line : " ";
            newLines.push(leftExpansion.repeat(left2) + this.lines[i] + rightExpansion.repeat(right));
          }
          for (i = 0; i < bottom; i++) {
            newLines.push(" ".repeat(this.width + left2 + right));
          }
          return new _TextDiagram(this.entry + top2, this.exit + top2, newLines);
        }
      }
      static rect(item, dashed = false) {
        return _TextDiagram._rectish("rect", item, dashed);
      }
      static roundrect(item, dashed = false) {
        return _TextDiagram._rectish("roundrect", item, dashed);
      }
      static setFormatting(characters = null, defaults = null) {
        if (characters !== null) {
          _TextDiagram.parts = {};
          if (defaults !== null) {
            _TextDiagram.parts = { ..._TextDiagram.parts, ...defaults };
          }
          _TextDiagram.parts = { ..._TextDiagram.parts, ...characters };
        }
        for (const [name2, value2] of _TextDiagram.parts) {
          if (value2.length != 1) ;
        }
      }
      _dump(show = true) {
        var nl = "\n";
        var result = "height=" + this.height + " lines.length=" + this.lines.length;
        if (this.entry > this.lines.length) {
          result += "; entry outside diagram: entry=" + this.entry;
        }
        if (this.exit > this.lines.length) {
          result += "; exit outside diagram: exit=" + this.exit;
        }
        for (var y = 0; y < Math.max(this.lines.length, this.entry + 1, this.exit + 1); y++) {
          result = result + nl + "[" + ("00" + y).slice(-3) + "]";
          if (y < this.lines.length) {
            result += " '" + this.lines[y] + "' len=" + this.lines[y].length;
          }
          if (y === this.entry && y === this.exit) {
            result += " <- entry, exit";
          } else if (y === this.entry) {
            result += " <- entry";
          } else if (y === this.exit) {
            result += " <- exit";
          }
        }
        if (show) {
          console.log(result);
        }
        return result;
      }
      static _encloseLines(lines, lefts, rights) {
        if (lines.length != lefts.length) {
          throw new Error("All arguments must be the same length");
        }
        if (lines.length != rights.length) {
          throw new Error("All arguments must be the same length");
        }
        var newLines = [];
        for (var i = 0; i < lines.length; i++) {
          newLines.push(lefts[i] + lines[i] + rights[i]);
        }
        return newLines;
      }
      static _gaps(outerWidth, innerWidth) {
        var diff = outerWidth - innerWidth;
        {
          var left2 = Math.trunc(diff / 2);
          var right = diff - left2;
          return [left2, right];
        }
      }
      static _getParts(partNames) {
        var result = [];
        for (const name2 of partNames) {
          if (_TextDiagram.parts[name2] == void 0) {
            throw new Error("Text diagram part " + name2 + "not found.");
          }
          result.push(_TextDiagram.parts[name2]);
        }
        return result;
      }
      static _maxWidth(...args) {
        var maxWidth = 0;
        for (const arg of args) {
          if (arg instanceof _TextDiagram) {
            var width = arg.width;
          } else if (arg instanceof Array) {
            width = Math.max(arg.map(function(e) {
              return e.length;
            }));
          } else if (Number.isInteger(arg)) {
            width = Number.toString(arg).length;
          } else {
            width = arg.length;
          }
          maxWidth = width > maxWidth ? width : maxWidth;
        }
        return maxWidth;
      }
      static _padL(string, width, pad) {
        if ((width - string.length) % pad.length != 0) {
          throw new Error("Gap " + (width - string.length) + " must be a multiple of pad string '" + pad + "'");
        }
        return pad.repeat(Math.trunc(width - string.length / pad.length)) + string;
      }
      static _padR(string, width, pad) {
        if ((width - string.length) % pad.length != 0) {
          throw new Error("Gap " + (width - string.length) + " must be a multiple of pad string '" + pad + "'");
        }
        return string + pad.repeat(Math.trunc(width - string.length / pad.length));
      }
      static _rectish(rectType, data, dashed = false) {
        var lineType = dashed ? "_dashed" : "";
        var [topLeft, ctrLeft, botLeft, topRight, ctrRight, botRight, topHoriz, botHoriz, line, cross] = _TextDiagram._getParts([rectType + "_top_left", rectType + "_left" + lineType, rectType + "_bot_left", rectType + "_top_right", rectType + "_right" + lineType, rectType + "_bot_right", rectType + "_top" + lineType, rectType + "_bot" + lineType, "line", "cross"]);
        var itemWasFormatted = data instanceof _TextDiagram;
        if (itemWasFormatted) {
          var itemTD = data;
        } else {
          itemTD = new _TextDiagram(0, 0, [data]);
        }
        var lines = [];
        lines.push(topHoriz.repeat(itemTD.width + 2));
        if (itemWasFormatted) {
          lines += itemTD.expand(1, 1, 0, 0).lines;
        } else {
          for (var i = 0; i < itemTD.lines.length; i++) {
            lines.push(" " + itemTD.lines[i] + " ");
          }
        }
        lines.push(botHoriz.repeat(itemTD.width + 2));
        var entry = itemTD.entry + 1;
        var exit = itemTD.exit + 1;
        var leftMaxWidth = _TextDiagram._maxWidth(topLeft, ctrLeft, botLeft);
        var lefts = [];
        lefts.push(_TextDiagram._padR(topLeft, leftMaxWidth, topHoriz));
        for (i = 1; i < lines.length - 1; i++) {
          lefts.push(_TextDiagram._padR(ctrLeft, leftMaxWidth, " "));
        }
        lefts.push(_TextDiagram._padR(botLeft, leftMaxWidth, botHoriz));
        if (itemWasFormatted) {
          lefts[entry] = cross;
        }
        var rightMaxWidth = _TextDiagram._maxWidth(topRight, ctrRight, botRight);
        var rights = [];
        rights.push(_TextDiagram._padL(topRight, rightMaxWidth, topHoriz));
        for (i = 1; i < lines.length - 1; i++) {
          rights.push(_TextDiagram._padL(ctrRight, rightMaxWidth, " "));
        }
        rights.push(_TextDiagram._padL(botRight, rightMaxWidth, botHoriz));
        if (itemWasFormatted) {
          rights[exit] = cross;
        }
        lines = _TextDiagram._encloseLines(lines, lefts, rights);
        lefts = [];
        for (i = 0; i < lines.length; i++) {
          lefts.push(" ");
        }
        lefts[entry] = line;
        rights = [];
        for (i = 0; i < lines.length; i++) {
          rights.push(" ");
        }
        rights[exit] = line;
        lines = _TextDiagram._encloseLines(lines, lefts, rights);
        return new _TextDiagram(entry, exit, lines);
      }
    };
    // Note:  All the drawing sequences below MUST be single characters.  setFormatting() checks this.
    // Unicode 25xx box drawing characters, plus a few others.
    __publicField(_TextDiagram, "PARTS_UNICODE", {
      "cross_diag": "╳",
      "corner_bot_left": "└",
      "corner_bot_right": "┘",
      "corner_top_left": "┌",
      "corner_top_right": "┐",
      "cross": "┼",
      "left": "│",
      "line": "─",
      "line_vertical": "│",
      "multi_repeat": "↺",
      "rect_bot": "─",
      "rect_bot_dashed": "┄",
      "rect_bot_left": "└",
      "rect_bot_right": "┘",
      "rect_left": "│",
      "rect_left_dashed": "┆",
      "rect_right": "│",
      "rect_right_dashed": "┆",
      "rect_top": "─",
      "rect_top_dashed": "┄",
      "rect_top_left": "┌",
      "rect_top_right": "┐",
      "repeat_bot_left": "╰",
      "repeat_bot_right": "╯",
      "repeat_left": "│",
      "repeat_right": "│",
      "repeat_top_left": "╭",
      "repeat_top_right": "╮",
      "right": "│",
      "roundcorner_bot_left": "╰",
      "roundcorner_bot_right": "╯",
      "roundcorner_top_left": "╭",
      "roundcorner_top_right": "╮",
      "roundrect_bot": "─",
      "roundrect_bot_dashed": "┄",
      "roundrect_bot_left": "╰",
      "roundrect_bot_right": "╯",
      "roundrect_left": "│",
      "roundrect_left_dashed": "┆",
      "roundrect_right": "│",
      "roundrect_right_dashed": "┆",
      "roundrect_top": "─",
      "roundrect_top_dashed": "┄",
      "roundrect_top_left": "╭",
      "roundrect_top_right": "╮",
      "separator": "─",
      "tee_left": "┤",
      "tee_right": "├"
    });
    //	Plain	old	ASCII	characters.
    __publicField(_TextDiagram, "PARTS_ASCII", {
      "cross_diag": "X",
      "corner_bot_left": "\\",
      "corner_bot_right": "/",
      "corner_top_left": "/",
      "corner_top_right": "\\",
      "cross": "+",
      "left": "|",
      "line": "-",
      "line_vertical": "|",
      "multi_repeat": "&",
      "rect_bot": "-",
      "rect_bot_dashed": "-",
      "rect_bot_left": "+",
      "rect_bot_right": "+",
      "rect_left": "|",
      "rect_left_dashed": "|",
      "rect_right": "|",
      "rect_right_dashed": "|",
      "rect_top_dashed": "-",
      "rect_top": "-",
      "rect_top_left": "+",
      "rect_top_right": "+",
      "repeat_bot_left": "\\",
      "repeat_bot_right": "/",
      "repeat_left": "|",
      "repeat_right": "|",
      "repeat_top_left": "/",
      "repeat_top_right": "\\",
      "right": "|",
      "roundcorner_bot_left": "\\",
      "roundcorner_bot_right": "/",
      "roundcorner_top_left": "/",
      "roundcorner_top_right": "\\",
      "roundrect_bot": "-",
      "roundrect_bot_dashed": "-",
      "roundrect_bot_left": "\\",
      "roundrect_bot_right": "/",
      "roundrect_left": "|",
      "roundrect_left_dashed": "|",
      "roundrect_right": "|",
      "roundrect_right_dashed": "|",
      "roundrect_top": "-",
      "roundrect_top_dashed": "-",
      "roundrect_top_left": "/",
      "roundrect_top_right": "\\",
      "separator": "-",
      "tee_left": "|",
      "tee_right": "|"
    });
    // Characters to use in drawing diagrams.  See setFormatting(), PARTS_ASCII, and PARTS_UNICODE.
    __publicField(_TextDiagram, "parts", _TextDiagram.PARTS_UNICODE);
    let TextDiagram = _TextDiagram;
    function unnull(...args) {
      return args.reduce(function(sofar, x) {
        return sofar !== void 0 ? sofar : x;
      });
    }
    function determineGaps(outer, inner) {
      var diff = outer - inner;
      switch (Options$1.INTERNAL_ALIGNMENT) {
        case "left":
          return [0, diff];
        case "right":
          return [diff, 0];
        default:
          return [diff / 2, diff / 2];
      }
    }
    function wrapString(value2) {
      return value2 instanceof FakeSVG ? value2 : new Terminal("" + value2);
    }
    function max$1(iter, func = (x) => x) {
      return Math.max.apply(null, iter.map(func));
    }
    function SVG(name2, attrs, text) {
      attrs = attrs || {};
      text = text || "";
      var el = document.createElementNS("http://www.w3.org/2000/svg", name2);
      for (var attr in attrs) {
        if (attr === "xlink:href")
          el.setAttributeNS("http://www.w3.org/1999/xlink", "href", attrs[attr]);
        else
          el.setAttribute(attr, attrs[attr]);
      }
      el.textContent = text;
      return el;
    }
    function escapeString(string) {
      return string.replace(/[*_\`\[\]<&]/g, function(charString) {
        return "&#" + charString.charCodeAt(0) + ";";
      });
    }
    function* enumerate(iter) {
      var count = 0;
      for (const x of iter) {
        yield [count, x];
        count++;
      }
    }
    function generateSteps(rootPattern, records) {
      const steps = [];
      let currentPattern = rootPattern;
      records.forEach((record, index) => {
        const from = currentPattern;
        const to = record.pattern;
        const prevRecord = records[index - 1];
        currentPattern = to;
        if (prevRecord != null && prevRecord.ast != null && record.ast != null && prevRecord.ast.endIndex === record.ast.endIndex) {
          steps.push({
            type: "match",
            pattern: to,
            record,
            path: generatePath(to)
          });
          return;
        }
        const path = getPathFromPatternToPattern(from, to);
        const isSibling = to.parent === from.parent;
        if (!isSibling) {
          path.forEach((pattern2) => {
            var _a2;
            if (pattern2.type === "repeat" || pattern2.type === "infinite-repeat" || pattern2.type === "finite-repeat" || pattern2.type === "optional" || pattern2.type === "reference" || ((_a2 = pattern2.parent) == null ? void 0 : _a2.type) === "optional" && record.error != null) {
              return;
            }
            steps.push({
              type: "move",
              pattern: pattern2,
              record,
              path: generatePath(pattern2)
            });
            if (pattern2 === to) {
              steps.push({
                type: record.ast == null ? "error" : "match",
                pattern: pattern2,
                record,
                path: generatePath(pattern2)
              });
            }
          });
        } else {
          steps.push({
            type: "move",
            pattern: to,
            record,
            path: generatePath(to)
          }, {
            type: record.ast == null ? "error" : "match",
            pattern: to,
            record,
            path: generatePath(to)
          });
        }
      });
      return steps;
    }
    function generatePath(fromPattern) {
      var _a2;
      const pathParts = [];
      let pattern2 = fromPattern;
      while (pattern2 != null) {
        const childIndex = ((_a2 = pattern2.parent) == null ? void 0 : _a2.children.indexOf(pattern2)) || 0;
        pathParts.unshift(pattern2.id, String(childIndex));
        pattern2 = pattern2.parent;
      }
      return pathParts.join("_");
    }
    function getPathFromPatternToPattern(from, to) {
      const fromPatternPath = [];
      const fromAncestorMap = /* @__PURE__ */ new Map();
      const toPatternPath = [];
      const toAncestorMap = /* @__PURE__ */ new Map();
      let onPattern = from.parent;
      while (onPattern != null) {
        fromAncestorMap.set(onPattern, true);
        fromPatternPath.push(onPattern);
        onPattern = onPattern.parent;
      }
      onPattern = to;
      while (onPattern != null) {
        toAncestorMap.set(onPattern, true);
        if (fromAncestorMap.has(onPattern)) {
          const index = fromPatternPath.indexOf(onPattern);
          const patternPath = fromPatternPath.slice(0, index);
          patternPath.push(...toPatternPath);
          return patternPath;
        }
        toPatternPath.unshift(onPattern);
        onPattern = onPattern.parent;
      }
      return [];
    }
    const charMap = {
      "\r": "\\r",
      "\n": "\\n",
      "	": "\\t",
      " ": " "
    };
    class DiagramPresenter {
      constructor() {
        __publicField(this, "_patterns");
        __publicField(this, "_viewingPatterns");
        __publicField(this, "_diagrams");
        __publicField(this, "_classNames");
        __publicField(this, "_expandedPatternPaths");
        __publicField(this, "_focusNodePath");
        this._patterns = new Signal({});
        this._viewingPatterns = new Signal([]);
        this._diagrams = new Signal(this._buildDiagrams([]));
        this._classNames = /* @__PURE__ */ new Map();
        this._expandedPatternPaths = /* @__PURE__ */ new Map();
        this._focusNodePath = new Signal(null);
      }
      get patterns() {
        return this._patterns.broadcast;
      }
      get viewingPatternBroadcast() {
        return this._viewingPatterns.broadcast;
      }
      get diagramsBroadcast() {
        return this._diagrams.broadcast;
      }
      get focusNodePathBroadcast() {
        return this._focusNodePath.broadcast;
      }
      _buildDiagram(pattern2) {
        switch (pattern2.type) {
          case "literal": {
            const diagram2 = new Diagram(new Group(this._buildPattern(pattern2), pattern2.name));
            diagram2.attrs.id = pattern2.id;
            return diagram2;
          }
          case "regex": {
            const diagram2 = new Diagram(new Group(`/${pattern2.regex}/`, pattern2.name));
            diagram2.attrs.id = pattern2.id;
            return diagram2;
          }
          case "not": {
            const diagram2 = new Diagram(new Group(this._buildPattern(pattern2), pattern2.name));
            diagram2.attrs.id = pattern2.id;
            return diagram2;
          }
          case "optional": {
            const diagram2 = new Diagram(new Group(this._buildPattern(pattern2), pattern2.name));
            diagram2.attrs.id = pattern2.id;
            return diagram2;
          }
          case "options": {
            const children = pattern2.children.map((p) => this._buildPattern(p));
            const options = new Choice(0, ...children);
            options.attrs.id = pattern2.id;
            const diagram2 = new Diagram(new Group(options, pattern2.name));
            diagram2.attrs.id = pattern2.id;
            return diagram2;
          }
          case "context": {
            return this._buildPattern(pattern2.children[pattern2.children.length - 1]);
          }
          case "reference": {
            const diagram2 = new Diagram(new Group(this._buildPattern(pattern2), pattern2.name));
            diagram2.attrs.id = pattern2.id;
            return diagram2;
          }
          case "sequence": {
            const children = pattern2.children.map((p) => this._buildPattern(p));
            const sequence = new Sequence$1(...children);
            sequence.attrs.id = pattern2.id;
            const diagram2 = new Diagram(new Group(sequence, pattern2.name));
            diagram2.attrs.id = pattern2.id;
            return diagram2;
          }
          case "finite-repeat": {
            const children = pattern2.children[0].children.map((p) => this._buildPattern(p));
            const repeat = new OneOrMore(...children);
            repeat.attrs.id = pattern2.id;
            const diagram2 = new Diagram(new Group(repeat, pattern2.name));
            diagram2.attrs.id = pattern2.id;
            return diagram2;
          }
          case "infinite-repeat": {
            const children = pattern2.children[0].children.map((p) => this._buildPattern(p));
            const repeat = new OneOrMore(...children);
            repeat.attrs.id = pattern2.id;
            const diagram2 = new Diagram(new Group(repeat, pattern2.name));
            diagram2.attrs.id = pattern2.id;
            return diagram2;
          }
        }
        throw new Error("Unknown pattern.");
      }
      _buildDiagrams(patterns) {
        return patterns.map((pattern2) => {
          return this._buildDiagram(pattern2);
        });
      }
      _buildPattern(pattern2) {
        switch (pattern2.type) {
          case "literal": {
            const text = this.replaceSpecialCharacters(pattern2.token);
            const path = generatePath(pattern2);
            const terminalOptions = {};
            const classNames2 = this._classNames.get(path);
            if (classNames2 != null) {
              terminalOptions.cls = classNames2;
            }
            const terminal = new Terminal(text, terminalOptions);
            terminal.attrs.id = generatePath(pattern2);
            terminal.attrs["data-type"] = "literal";
            return terminal;
          }
          case "regex": {
            const path = generatePath(pattern2);
            if (this._expandedPatternPaths.get(path)) {
              const text = pattern2.regex;
              const terminalOptions = {};
              const classNames2 = this._classNames.get(path);
              if (classNames2 != null) {
                terminalOptions.cls = classNames2;
              }
              const terminal = new Terminal(text, terminalOptions);
              terminal.attrs.id = generatePath(pattern2);
              terminal.attrs["data-type"] = "regex";
              return terminal;
            } else {
              const text = pattern2.name;
              const termninalOptions = {};
              const classNames2 = this._classNames.get(path);
              if (classNames2 != null) {
                termninalOptions.cls = classNames2;
              }
              const terminal = new Terminal(text, termninalOptions);
              terminal.attrs.id = generatePath(pattern2);
              terminal.attrs["data-type"] = "regex";
              return terminal;
            }
          }
          case "not": {
            const text = pattern2.name;
            const path = generatePath(pattern2);
            const terminalOptions = {};
            const classNames2 = this._classNames.get(path);
            if (classNames2 != null) {
              terminalOptions.cls = classNames2;
            }
            const terminal = new Terminal(text, terminalOptions);
            terminal.attrs.id = generatePath(pattern2);
            terminal.attrs["data-type"] = "not";
            return terminal;
          }
          case "optional": {
            const optional = new Optional$1(this._buildPattern(pattern2.children[0]));
            optional.attrs["data-type"] = "optional";
            return optional;
          }
          case "options": {
            const text = pattern2.name;
            const path = generatePath(pattern2);
            if (this._expandedPatternPaths.get(path)) {
              const children = pattern2.children.map((p) => this._buildPattern(p));
              const options = new Choice(0, ...children);
              options.attrs.id = pattern2.id;
              const terminalOptions = {};
              const classNames2 = this._classNames.get(path);
              if (classNames2 != null) {
                terminalOptions.cls = classNames2;
              }
              const label = new Terminal(`${text}:`, terminalOptions);
              label.attrs.id = path;
              label.attrs["data-group"] = "true";
              label.attrs["data-type"] = "options";
              const group = new Sequence$1(label, options);
              group.attrs.id = path;
              group.attrs["data-group"] = "true";
              return group;
            } else {
              const terminalOptions = {};
              const classNames2 = this._classNames.get(path);
              if (classNames2 != null) {
                terminalOptions.cls = classNames2;
              }
              const terminal = new Terminal(text, terminalOptions);
              terminal.attrs.id = path;
              terminal.attrs["data-type"] = "options";
              return terminal;
            }
          }
          case "context": {
            return this._buildPattern(pattern2.children[pattern2.children.length - 1]);
          }
          case "reference": {
            const path = generatePath(pattern2);
            if (this._expandedPatternPaths.get(path)) {
              const refPattern = pattern2._getPatternSafely();
              this._expandedPatternPaths.set(generatePath(refPattern), true);
              const node = this._buildPattern(refPattern);
              node.attrs["data-reference-path"] = path;
              return node;
            } else {
              const terminalOptions = {};
              const classNames2 = this._classNames.get(path);
              if (classNames2 != null) {
                terminalOptions.cls = classNames2;
              }
              const terminal = new Terminal(pattern2.name, terminalOptions);
              terminal.attrs.id = generatePath(pattern2);
              terminal.attrs["data-type"] = "reference";
              return terminal;
            }
          }
          case "sequence": {
            const text = pattern2.name;
            const path = generatePath(pattern2);
            if (this._expandedPatternPaths.get(path)) {
              const children = pattern2.children.map((p) => this._buildPattern(p));
              const sequence = new Sequence$1(...children);
              const terminalOptions = {};
              const classNames2 = this._classNames.get(path);
              if (classNames2 != null) {
                terminalOptions.cls = classNames2;
              }
              const label = new Terminal(`${text}:`, terminalOptions);
              label.attrs.id = path;
              label.attrs["data-group"] = "true";
              label.attrs["data-type"] = "sequence";
              const group = new Sequence$1(label, sequence);
              group.attrs.id = path;
              return group;
            } else {
              const terminalOptions = {};
              const classNames2 = this._classNames.get(path);
              if (classNames2 != null) {
                terminalOptions.cls = classNames2;
              }
              const terminal = new Terminal(text, terminalOptions);
              terminal.attrs.id = path;
              terminal.attrs["data-type"] = "sequence";
              return terminal;
            }
          }
          case "finite-repeat": {
            const children = pattern2.children[0].children.map((p) => this._buildPattern(p));
            const repeat = new OneOrMore(...children);
            repeat.attrs.id = generatePath(pattern2);
            repeat.attrs["data-type"] = "repeat";
            return repeat;
          }
          case "infinite-repeat": {
            const children = pattern2.children[0].children.map((p) => this._buildPattern(p));
            const repeat = new OneOrMore(...children);
            repeat.attrs.id = generatePath(pattern2);
            repeat.attrs["data-type"] = "repeat";
            return repeat;
          }
        }
      }
      replaceSpecialCharacters(value2) {
        return value2.replace(/[\s\S]/g, (char) => {
          return charMap[char] == null ? char : charMap[char];
        });
      }
      selectPattern(patterns) {
        this._viewingPatterns.set(patterns);
        this._diagrams.set(this._buildDiagrams(patterns));
      }
      setClass(customClass) {
        this._classNames.set(customClass.patternPath, customClass.className);
        this._diagrams.set(this._buildDiagrams(this._viewingPatterns.get()));
      }
      setClasses(customClasses) {
        customClasses.forEach((customClass) => {
          this._classNames.set(customClass.patternPath, customClass.className);
        });
        this._diagrams.set(this._buildDiagrams(this._viewingPatterns.get()));
      }
      clearClasses() {
        this._classNames.clear();
        this._diagrams.set(this._buildDiagrams(this._viewingPatterns.get()));
      }
      expandPatternPath(patternPath) {
        const parts = patternPath.split("_");
        for (let x = 1; x < parts.length; x++) {
          const path = parts.slice(0, x).join("_");
          this._expandedPatternPaths.set(path, true);
        }
        this._diagrams.set(this._buildDiagrams(this._viewingPatterns.get()));
      }
      collapsePatternPath(patternPath) {
        this._expandedPatternPaths.set(patternPath, false);
        this._diagrams.set(this._buildDiagrams(this._viewingPatterns.get()));
      }
      togglePatternPath(patternPath) {
        const currentValue = Boolean(this._expandedPatternPaths.get(patternPath));
        this._expandedPatternPaths.set(patternPath, !currentValue);
        this._diagrams.set(this._buildDiagrams(this._viewingPatterns.get()));
      }
      focusPath(path) {
        this._focusNodePath.set(path);
      }
    }
    function defaultVisitor(node) {
      return node;
    }
    let Node$1 = class Node2 {
      get type() {
        return this._type;
      }
      get name() {
        return this._name;
      }
      get firstIndex() {
        return this._firstIndex;
      }
      get lastIndex() {
        return this._lastIndex;
      }
      get startIndex() {
        return this._firstIndex;
      }
      get endIndex() {
        return this._lastIndex + 1;
      }
      get parent() {
        return this._parent;
      }
      get children() {
        return this._children;
      }
      get hasChildren() {
        return this._children.length > 0;
      }
      get isLeaf() {
        return !this.hasChildren;
      }
      get value() {
        return this.toString();
      }
      constructor(type, name2, firstIndex, lastIndex, children = [], value2 = "") {
        this._type = type;
        this._name = name2;
        this._firstIndex = firstIndex;
        this._lastIndex = lastIndex;
        this._parent = null;
        this._children = children;
        this._value = value2;
        this._children.forEach((c) => c._parent = this);
      }
      removeChild(node) {
        const index = this._children.indexOf(node);
        if (index > -1) {
          this._children.splice(index, 1);
          node._parent = null;
        }
      }
      findChildIndex(node) {
        return this._children.indexOf(node);
      }
      spliceChildren(index, deleteCount, ...items) {
        const removedItems = this._children.splice(index, deleteCount, ...items);
        removedItems.forEach((i) => i._parent = null);
        items.forEach((i) => i._parent = this);
        return removedItems;
      }
      removeAllChildren() {
        this.spliceChildren(0, this._children.length);
      }
      replaceChild(newNode, referenceNode) {
        const index = this.findChildIndex(referenceNode);
        if (index > -1) {
          this.spliceChildren(index, 1, newNode);
        }
      }
      replaceWith(newNode) {
        if (this._parent != null) {
          this._parent.replaceChild(newNode, this);
        }
      }
      insertBefore(newNode, referenceNode) {
        newNode._parent = this;
        if (referenceNode == null) {
          this._children.push(newNode);
          return;
        }
        const index = this.findChildIndex(referenceNode);
        if (index > -1) {
          this._children.splice(index, 0, newNode);
        }
      }
      appendChild(newNode) {
        this.append(newNode);
      }
      append(...nodes) {
        nodes.forEach((newNode) => {
          newNode._parent = this;
          this._children.push(newNode);
        });
      }
      nextSibling() {
        if (this._parent == null) {
          return null;
        }
        const children = this._parent._children;
        const index = children.indexOf(this);
        if (index > -1 && index < children.length - 1) {
          return children[index + 1];
        }
        return null;
      }
      previousSibling() {
        if (this._parent == null) {
          return null;
        }
        const children = this._parent._children;
        const index = children.indexOf(this);
        if (index > -1 && index > 0) {
          return children[index - 1];
        }
        return null;
      }
      find(predicate) {
        return this.findAll(predicate)[0] || null;
      }
      findAll(predicate) {
        const matches = [];
        this.walkUp((n) => {
          if (predicate(n)) {
            matches.push(n);
          }
        });
        return matches;
      }
      findAncestor(predicate) {
        let parent = this._parent;
        while (parent != null) {
          if (predicate(parent)) {
            return parent;
          }
          parent = parent._parent;
        }
        return null;
      }
      walkUp(callback) {
        const childrenCopy = this._children.slice();
        childrenCopy.forEach((c) => c.walkUp(callback));
        callback(this);
      }
      walkDown(callback) {
        const childrenCopy = this._children.slice();
        callback(this);
        childrenCopy.forEach((c) => c.walkDown(callback));
      }
      walkBreadthFirst(callback) {
        const queue = [this];
        while (queue.length > 0) {
          const current = queue.shift();
          callback(current);
          queue.push(...current.children);
        }
      }
      transform(visitors) {
        const childrenCopy = this._children.slice();
        const visitor = visitors[this.name] == null ? defaultVisitor : visitors[this.name];
        const children = childrenCopy.map((c) => c.transform(visitors));
        this.removeAllChildren();
        this.append(...children);
        return visitor(this);
      }
      flatten() {
        const nodes = [];
        this.walkDown((node) => {
          if (!node.hasChildren) {
            nodes.push(node);
          }
        });
        return nodes;
      }
      reduce() {
        const value2 = this.toString();
        this.removeAllChildren();
        this._value = value2;
      }
      remove() {
        if (this._parent != null) {
          this._parent.removeChild(this);
        }
      }
      clone() {
        return new Node2(this._type, this._name, this._firstIndex, this._lastIndex, this._children.map((c) => c.clone()), this._value);
      }
      normalize(startIndex = this._firstIndex) {
        let length = 0;
        if (this.children.length === 0) {
          length = this._value.length;
        } else {
          length = this.children.reduce((acc, c) => acc + c.normalize(acc + startIndex), startIndex);
        }
        this._firstIndex = startIndex;
        this._lastIndex = Math.max(startIndex + length - 1, 0);
        return length;
      }
      toString() {
        if (this._children.length === 0) {
          return this._value;
        }
        return this._children.map((c) => c.toString()).join("");
      }
      toCycleFreeObject() {
        return {
          type: this._type,
          name: this._name,
          value: this.toString(),
          startIndex: this.startIndex,
          endIndex: this.endIndex,
          children: this._children.map((c) => c.toCycleFreeObject())
        };
      }
      toJson(space) {
        return JSON.stringify(this.toCycleFreeObject(), null, space);
      }
      isEqual(node) {
        return node.toJson(0) === this.toJson(0);
      }
      static createValueNode(name2, value2) {
        return new Node2("custom-value-node", name2, 0, 0, [], value2);
      }
      static createNode(name2, children) {
        const value2 = children.map((c) => c.toString()).join("");
        return new Node2("custom-node", name2, 0, 0, children, value2);
      }
    };
    function __awaiter(thisArg, _arguments, P, generator) {
      function adopt(value2) {
        return value2 instanceof P ? value2 : new P(function(resolve) {
          resolve(value2);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value2) {
          try {
            step(generator.next(value2));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value2) {
          try {
            step(generator["throw"](value2));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, [])).next());
      });
    }
    typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    class ParseError {
      constructor(startIndex, endIndex, pattern2) {
        this.startIndex = startIndex;
        this.endIndex = endIndex;
        this.pattern = pattern2;
      }
    }
    class CursorHistory {
      constructor() {
        this._isRecording = false;
        this._leafMatches = [{ pattern: null, node: null }];
        this._furthestError = null;
        this._currentError = null;
        this._rootMatch = { pattern: null, node: null };
        this._patterns = [];
        this._nodes = [];
        this._errors = [];
        this._records = [];
      }
      get isRecording() {
        return this._isRecording;
      }
      get rootMatch() {
        return this._rootMatch;
      }
      get leafMatch() {
        return this._leafMatches[this._leafMatches.length - 1];
      }
      get leafMatches() {
        return this._leafMatches;
      }
      get furthestError() {
        return this._furthestError;
      }
      get errors() {
        return this._errors;
      }
      get error() {
        return this._currentError;
      }
      get records() {
        return this._records;
      }
      get nodes() {
        return this._nodes;
      }
      get patterns() {
        return this._patterns;
      }
      recordMatch(pattern2, node) {
        if (this._isRecording) {
          this._patterns.push(pattern2);
          this._nodes.push(node);
          this._records.push({
            pattern: pattern2,
            ast: node,
            error: null
          });
        }
        this._rootMatch.pattern = pattern2;
        this._rootMatch.node = node;
        const leafMatch = this._leafMatches[this._leafMatches.length - 1];
        const isFurthestMatch = leafMatch.node === null || node.lastIndex > leafMatch.node.lastIndex;
        const isSameIndexMatch = leafMatch.node === null || node.lastIndex === leafMatch.node.lastIndex;
        if (isFurthestMatch) {
          const match2 = this._leafMatches.pop();
          match2.pattern = pattern2;
          match2.node = node;
          this._leafMatches.length = 0;
          this._leafMatches.push(match2);
        } else if (isSameIndexMatch) {
          const isAncestor = this._leafMatches.some((m) => {
            var _a2;
            let parent = (_a2 = m.pattern) === null || _a2 === void 0 ? void 0 : _a2.parent;
            while (parent != null) {
              if (parent === pattern2.parent) {
                return true;
              }
              parent = parent.parent;
            }
            return false;
          });
          if (!isAncestor) {
            this._leafMatches.unshift({ pattern: pattern2, node });
          }
        }
      }
      recordErrorAt(startIndex, endIndex, pattern2) {
        const error = new ParseError(startIndex, endIndex, pattern2);
        this._currentError = error;
        if (this._furthestError === null || endIndex > this._furthestError.endIndex) {
          this._furthestError = error;
        }
        if (this._isRecording) {
          this._errors.push(error);
          this.records.push({
            pattern: pattern2,
            ast: null,
            error
          });
        }
      }
      startRecording() {
        this._isRecording = true;
      }
      stopRecording() {
        this._isRecording = false;
      }
      resolveError() {
        this._currentError = null;
      }
    }
    let Cursor$1 = class Cursor {
      get text() {
        return this._text;
      }
      get isOnFirst() {
        return this._index === 0;
      }
      get isOnLast() {
        return this._index === this.getLastIndex();
      }
      get isRecording() {
        return this._history.isRecording;
      }
      get rootMatch() {
        return this._history.rootMatch;
      }
      get allMatchedNodes() {
        return this._history.nodes;
      }
      get allMatchedPatterns() {
        return this._history.patterns;
      }
      get leafMatch() {
        return this._history.leafMatch;
      }
      get leafMatches() {
        return this._history.leafMatches;
      }
      get furthestError() {
        return this._history.furthestError;
      }
      get error() {
        return this._history.error;
      }
      get errors() {
        return this._history.errors;
      }
      get records() {
        return this._history.records;
      }
      get index() {
        return this._index;
      }
      get length() {
        return this._length;
      }
      get hasError() {
        return this._history.error != null;
      }
      get currentChar() {
        return this._text[this._index];
      }
      constructor(text) {
        this._text = text;
        this._index = 0;
        this._length = [...text].length;
        this._history = new CursorHistory();
      }
      hasNext() {
        return this._index + 1 < this._length;
      }
      next() {
        if (this.hasNext()) {
          this._index++;
        }
      }
      hasPrevious() {
        return this._index - 1 >= 0;
      }
      previous() {
        if (this.hasPrevious()) {
          this._index--;
        }
      }
      moveTo(position) {
        if (position >= 0 && position < this._length) {
          this._index = position;
        }
      }
      moveToFirstChar() {
        this._index = 0;
      }
      moveToLastChar() {
        this._index = this.getLastIndex();
      }
      getLastIndex() {
        return this._length - 1;
      }
      getChars(first, last) {
        return this._text.slice(first, last + 1);
      }
      recordMatch(pattern2, node) {
        this._history.recordMatch(pattern2, node);
      }
      recordErrorAt(startIndex, endIndex, onPattern) {
        this._history.recordErrorAt(startIndex, endIndex, onPattern);
      }
      resolveError() {
        this._history.resolveError();
      }
      startRecording() {
        this._history.startRecording();
      }
      stopRecording() {
        this._history.stopRecording();
      }
    };
    let idIndex$9 = 0;
    class Literal {
      get id() {
        return this._id;
      }
      get type() {
        return this._type;
      }
      get name() {
        return this._name;
      }
      get token() {
        return this._token;
      }
      get parent() {
        return this._parent;
      }
      set parent(pattern2) {
        this._parent = pattern2;
      }
      get children() {
        return [];
      }
      constructor(name2, value2) {
        if (value2.length === 0) {
          throw new Error("Value Cannot be empty.");
        }
        this._id = `literal-${idIndex$9++}`;
        this._type = "literal";
        this._name = name2;
        this._token = value2;
        this._runes = Array.from(value2);
        this._parent = null;
        this._firstIndex = 0;
        this._lastIndex = 0;
        this._endIndex = 0;
      }
      test(text, record = false) {
        const cursor = new Cursor$1(text);
        record && cursor.startRecording();
        const ast = this.parse(cursor);
        return (ast === null || ast === void 0 ? void 0 : ast.value) === text;
      }
      exec(text, record = false) {
        const cursor = new Cursor$1(text);
        record && cursor.startRecording();
        const ast = this.parse(cursor);
        return {
          ast: (ast === null || ast === void 0 ? void 0 : ast.value) === text ? ast : null,
          cursor
        };
      }
      parse(cursor) {
        this._firstIndex = cursor.index;
        const passed = this._tryToParse(cursor);
        if (passed) {
          cursor.resolveError();
          const node = this._createNode();
          cursor.recordMatch(this, node);
          return node;
        }
        cursor.recordErrorAt(this._firstIndex, this._endIndex, this);
        return null;
      }
      _tryToParse(cursor) {
        let passed = false;
        const literalRuneLength = this._runes.length;
        for (let i = 0; i < literalRuneLength; i++) {
          const literalRune = this._runes[i];
          const cursorRune = cursor.currentChar;
          if (literalRune !== cursorRune) {
            this._endIndex = cursor.index;
            break;
          }
          if (i + 1 === literalRuneLength) {
            this._lastIndex = this._firstIndex + this._token.length - 1;
            passed = true;
            break;
          }
          if (!cursor.hasNext()) {
            this._endIndex = cursor.index + 1;
            break;
          }
          cursor.next();
        }
        return passed;
      }
      _createNode() {
        return new Node$1("literal", this._name, this._firstIndex, this._lastIndex, void 0, this._token);
      }
      clone(name2 = this._name) {
        const clone = new Literal(name2, this._token);
        clone._id = this._id;
        return clone;
      }
      getTokens() {
        return [this._token];
      }
      getTokensAfter(_lastMatched) {
        return [];
      }
      getNextTokens() {
        if (this.parent == null) {
          return [];
        }
        return this.parent.getTokensAfter(this);
      }
      getPatterns() {
        return [this];
      }
      getPatternsAfter() {
        return [];
      }
      getNextPatterns() {
        if (this.parent == null) {
          return [];
        }
        return this.parent.getPatternsAfter(this);
      }
      find(_predicate) {
        return null;
      }
      isEqual(pattern2) {
        return pattern2.type === this.type && pattern2._token === this._token;
      }
    }
    let idIndex$8 = 0;
    class Regex {
      get id() {
        return this._id;
      }
      get type() {
        return this._type;
      }
      get name() {
        return this._name;
      }
      get regex() {
        return this._originalRegexString;
      }
      get parent() {
        return this._parent;
      }
      set parent(pattern2) {
        this._parent = pattern2;
      }
      get children() {
        return [];
      }
      constructor(name2, regex) {
        this._node = null;
        this._cursor = null;
        this._firstIndex = -1;
        this._substring = "";
        this._tokens = [];
        this._id = `regex-${idIndex$8++}`;
        this._type = "regex";
        this._name = name2;
        this._parent = null;
        this._originalRegexString = regex;
        this._regex = new RegExp(`^${regex}`, "g");
        this.assertArguments();
      }
      assertArguments() {
        if (this._originalRegexString.length < 1) {
          throw new Error("Invalid Arguments: The regex string argument needs to be at least one character long.");
        }
        if (this._originalRegexString.charAt(0) === "^") {
          throw new Error("Invalid Arguments: The regex string cannot start with a '^' because it is expected to be in the middle of a string.");
        }
        if (this._originalRegexString.charAt(this._originalRegexString.length - 1) === "$") {
          throw new Error("Invalid Arguments: The regex string cannot end with a '$' because it is expected to be in the middle of a string.");
        }
      }
      test(text) {
        const cursor = new Cursor$1(text);
        const ast = this.parse(cursor);
        return (ast === null || ast === void 0 ? void 0 : ast.value) === text;
      }
      exec(text, record = false) {
        const cursor = new Cursor$1(text);
        record && cursor.startRecording();
        const ast = this.parse(cursor);
        return {
          ast: (ast === null || ast === void 0 ? void 0 : ast.value) === text ? ast : null,
          cursor
        };
      }
      parse(cursor) {
        this._firstIndex = cursor.index;
        this.resetState(cursor);
        this.tryToParse(cursor);
        return this._node;
      }
      resetState(cursor) {
        this._cursor = cursor;
        this._regex.lastIndex = 0;
        this._substring = this._cursor.text.substr(this._cursor.index);
        this._node = null;
      }
      tryToParse(cursor) {
        const result = this._regex.exec(this._substring);
        if (result != null && result.index === 0) {
          this.processResult(cursor, result);
        } else {
          this.processError(cursor);
        }
      }
      processResult(cursor, result) {
        const currentIndex = cursor.index;
        const newIndex = currentIndex + result[0].length - 1;
        this._node = new Node$1("regex", this._name, currentIndex, newIndex, void 0, result[0]);
        cursor.moveTo(newIndex);
        cursor.recordMatch(this, this._node);
      }
      processError(cursor) {
        cursor.recordErrorAt(this._firstIndex, this._firstIndex, this);
        this._node = null;
      }
      clone(name2 = this._name) {
        const clone = new Regex(name2, this._originalRegexString);
        clone._tokens = this._tokens.slice();
        clone._id = this._id;
        return clone;
      }
      getTokens() {
        return this._tokens;
      }
      getTokensAfter(_childReference) {
        return [];
      }
      getNextTokens() {
        if (this.parent == null) {
          return [];
        }
        return this.parent.getTokensAfter(this);
      }
      getPatterns() {
        return [this];
      }
      getPatternsAfter(_childReference) {
        return [];
      }
      getNextPatterns() {
        if (this.parent == null) {
          return [];
        }
        return this.parent.getPatternsAfter(this);
      }
      find(_predicate) {
        return null;
      }
      setTokens(tokens) {
        this._tokens = tokens;
      }
      isEqual(pattern2) {
        return pattern2.type === this.type && pattern2._originalRegexString === this._originalRegexString;
      }
    }
    function findPattern(pattern2, predicate) {
      let children = [];
      if (pattern2.type === "reference") {
        children = [];
      } else {
        children = pattern2.children;
      }
      for (const child of children) {
        const result = findPattern(child, predicate);
        if (result !== null) {
          return result;
        }
      }
      if (predicate(pattern2)) {
        return pattern2;
      } else {
        return null;
      }
    }
    let idIndex$7 = 0;
    class Reference {
      get id() {
        return this._id;
      }
      get type() {
        return this._type;
      }
      get name() {
        return this._name;
      }
      get parent() {
        return this._parent;
      }
      set parent(pattern2) {
        this._parent = pattern2;
      }
      get children() {
        return this._children;
      }
      constructor(name2) {
        this._id = `reference-${idIndex$7++}`;
        this._type = "reference";
        this._name = name2;
        this._parent = null;
        this._pattern = null;
        this._cachedPattern = null;
        this._children = [];
      }
      test(text) {
        const cursor = new Cursor$1(text);
        const ast = this.parse(cursor);
        return (ast === null || ast === void 0 ? void 0 : ast.value) === text;
      }
      exec(text, record = false) {
        const cursor = new Cursor$1(text);
        record && cursor.startRecording();
        const ast = this.parse(cursor);
        return {
          ast: (ast === null || ast === void 0 ? void 0 : ast.value) === text ? ast : null,
          cursor
        };
      }
      parse(cursor) {
        return this._getPatternSafely().parse(cursor);
      }
      _getPatternSafely() {
        if (this._pattern === null) {
          let pattern2 = null;
          if (this._cachedPattern == null) {
            pattern2 = this._findPattern();
          } else {
            pattern2 = this._cachedPattern;
          }
          if (pattern2 === null) {
            throw new Error(`Couldn't find '${this._name}' pattern within tree.`);
          }
          const clonedPattern = pattern2.clone();
          clonedPattern.parent = this;
          this._pattern = clonedPattern;
          this._children = [this._pattern];
        }
        return this._pattern;
      }
      _findPattern() {
        let pattern2 = this._parent;
        while (pattern2 != null) {
          if (pattern2.type !== "context") {
            pattern2 = pattern2.parent;
            continue;
          }
          const foundPattern = pattern2.getPatternWithinContext(this.name);
          if (foundPattern != null) {
            return foundPattern;
          }
          pattern2 = pattern2.parent;
        }
        const root2 = this._getRoot();
        return findPattern(root2, (pattern3) => {
          return pattern3.name === this._name && pattern3.type !== "reference" && pattern3.type !== "context";
        });
      }
      _getRoot() {
        let node = this;
        while (true) {
          const parent = node.parent;
          if (parent == null) {
            break;
          } else {
            node = parent;
          }
        }
        return node;
      }
      getTokens() {
        return this._getPatternSafely().getTokens();
      }
      getTokensAfter(_lastMatched) {
        if (this._parent == null) {
          return [];
        }
        return this._parent.getTokensAfter(this);
      }
      getNextTokens() {
        if (this.parent == null) {
          return [];
        }
        return this.parent.getTokensAfter(this);
      }
      getPatterns() {
        return this._getPatternSafely().getPatterns();
      }
      getPatternsAfter(_childReference) {
        if (this._parent == null) {
          return [];
        }
        return this._parent.getPatternsAfter(this);
      }
      getNextPatterns() {
        if (this.parent == null) {
          return [];
        }
        return this.parent.getPatternsAfter(this);
      }
      find(_predicate) {
        return null;
      }
      clone(name2 = this._name) {
        const clone = new Reference(name2);
        clone._id = this._id;
        if (this._pattern != null) {
          clone._cachedPattern = this._pattern;
        }
        return clone;
      }
      isEqual(pattern2) {
        return pattern2.type === this.type && pattern2.name === this.name;
      }
    }
    function clonePatterns(patterns) {
      return patterns.map((p) => p.clone());
    }
    class DepthCache {
      constructor() {
        this._depthMap = {};
      }
      getDepth(name2, cursorIndex) {
        if (this._depthMap[name2] == null) {
          this._depthMap[name2] = {};
        }
        if (this._depthMap[name2][cursorIndex] == null) {
          this._depthMap[name2][cursorIndex] = 0;
        }
        return this._depthMap[name2][cursorIndex];
      }
      incrementDepth(name2, cursorIndex) {
        const depth = this.getDepth(name2, cursorIndex);
        this._depthMap[name2][cursorIndex] = depth + 1;
      }
      decrementDepth(name2, cursorIndex) {
        const depth = this.getDepth(name2, cursorIndex);
        this._depthMap[name2][cursorIndex] = depth - 1;
      }
    }
    const depthCache$1 = new DepthCache();
    let idIndex$6 = 0;
    class Options {
      get id() {
        return this._id;
      }
      get type() {
        return this._type;
      }
      get name() {
        return this._name;
      }
      get parent() {
        return this._parent;
      }
      set parent(pattern2) {
        this._parent = pattern2;
      }
      get children() {
        return this._children;
      }
      constructor(name2, options, isGreedy = false) {
        if (options.length === 0) {
          throw new Error("Need at least one pattern with an 'or' pattern.");
        }
        const children = clonePatterns(options);
        this._assignChildrenToParent(children);
        this._id = `options-${idIndex$6++}`;
        this._type = "options";
        this._name = name2;
        this._parent = null;
        this._children = children;
        this._firstIndex = 0;
        this._isGreedy = isGreedy;
      }
      _assignChildrenToParent(children) {
        for (const child of children) {
          child.parent = this;
        }
      }
      test(text) {
        const cursor = new Cursor$1(text);
        const ast = this.parse(cursor);
        return (ast === null || ast === void 0 ? void 0 : ast.value) === text;
      }
      exec(text, record = false) {
        const cursor = new Cursor$1(text);
        record && cursor.startRecording();
        const ast = this.parse(cursor);
        return {
          ast: (ast === null || ast === void 0 ? void 0 : ast.value) === text ? ast : null,
          cursor
        };
      }
      parse(cursor) {
        this._firstIndex = cursor.index;
        depthCache$1.incrementDepth(this._id, this._firstIndex);
        this._firstIndex = cursor.index;
        const node = this._tryToParse(cursor);
        depthCache$1.decrementDepth(this._id, this._firstIndex);
        if (node != null) {
          cursor.moveTo(node.lastIndex);
          cursor.resolveError();
          return node;
        }
        cursor.recordErrorAt(this._firstIndex, this._firstIndex, this);
        return null;
      }
      _tryToParse(cursor) {
        if (depthCache$1.getDepth(this._id, this._firstIndex) > 2) {
          cursor.recordErrorAt(this._firstIndex, this._firstIndex, this);
          return null;
        }
        const results = [];
        for (const pattern2 of this._children) {
          cursor.moveTo(this._firstIndex);
          let result = null;
          result = pattern2.parse(cursor);
          if (this._isGreedy) {
            results.push(result);
          }
          if (result != null && !this._isGreedy) {
            return result;
          }
          cursor.resolveError();
        }
        const nonNullResults = results.filter((r) => r != null);
        nonNullResults.sort((a, b) => b.endIndex - a.endIndex);
        return nonNullResults[0] || null;
      }
      getTokens() {
        const tokens = [];
        for (const child of this._children) {
          tokens.push(...child.getTokens());
        }
        return tokens;
      }
      getTokensAfter(_childReference) {
        if (this._parent === null) {
          return [];
        }
        return this._parent.getTokensAfter(this);
      }
      getNextTokens() {
        if (this._parent == null) {
          return [];
        }
        return this._parent.getTokensAfter(this);
      }
      getPatterns() {
        const patterns = [];
        for (const pattern2 of this._children) {
          patterns.push(...pattern2.getPatterns());
        }
        return patterns;
      }
      getPatternsAfter(_childReference) {
        if (this._parent === null) {
          return [];
        }
        return this._parent.getPatternsAfter(this);
      }
      getNextPatterns() {
        if (this.parent == null) {
          return [];
        }
        return this.parent.getPatternsAfter(this);
      }
      find(predicate) {
        return findPattern(this, predicate);
      }
      clone(name2 = this._name) {
        const or = new Options(name2, this._children, this._isGreedy);
        or._id = this._id;
        return or;
      }
      isEqual(pattern2) {
        return pattern2.type === this.type && this.children.every((c, index) => c.isEqual(pattern2.children[index]));
      }
    }
    let idIndex$5 = 0;
    class FiniteRepeat {
      get id() {
        return this._id;
      }
      get type() {
        return this._type;
      }
      get name() {
        return this._name;
      }
      get parent() {
        return this._parent;
      }
      set parent(value2) {
        this._parent = value2;
      }
      get children() {
        return this._children;
      }
      get min() {
        return this._min;
      }
      get max() {
        return this._max;
      }
      constructor(name2, pattern2, options = {}) {
        this._id = `finite-repeat-${idIndex$5++}`;
        this._type = "finite-repeat";
        this._name = name2;
        this._parent = null;
        this._children = [];
        this._hasDivider = options.divider != null;
        this._min = options.min != null ? Math.max(options.min, 1) : 1;
        this._max = Math.max(this.min, options.max || this.min);
        this._trimDivider = options.trimDivider == null ? false : options.trimDivider;
        for (let i = 0; i < this._max; i++) {
          const child = pattern2.clone();
          child.parent = this;
          this._children.push(child);
          if (options.divider != null && (i < this._max - 1 || !this._trimDivider)) {
            const divider2 = options.divider.clone();
            divider2.parent = this;
            this._children.push(divider2);
          }
        }
      }
      parse(cursor) {
        const startIndex = cursor.index;
        const nodes = [];
        const modulo = this._hasDivider ? 2 : 1;
        let matchCount = 0;
        for (let i = 0; i < this._children.length; i++) {
          const childPattern = this._children[i];
          const runningIndex = cursor.index;
          const node = childPattern.parse(cursor);
          if (cursor.hasError) {
            break;
          }
          if (i % modulo === 0 && !cursor.hasError) {
            matchCount++;
          }
          if (node == null) {
            cursor.moveTo(runningIndex);
          } else {
            nodes.push(node);
            if (cursor.hasNext()) {
              cursor.next();
            } else {
              break;
            }
          }
        }
        if (this._trimDivider && this._hasDivider) {
          const isDividerLastMatch = this.children.length > 1 && nodes[nodes.length - 1].name === this.children[1].name;
          if (isDividerLastMatch) {
            const node = nodes.pop();
            cursor.moveTo(node.firstIndex);
          }
        }
        if (matchCount < this._min) {
          const lastIndex2 = cursor.index;
          cursor.moveTo(startIndex);
          cursor.recordErrorAt(startIndex, lastIndex2, this);
          return null;
        }
        if (nodes.length === 0 && !cursor.hasError) {
          cursor.moveTo(startIndex);
          return null;
        }
        const firstIndex = nodes[0].firstIndex;
        const lastIndex = nodes[nodes.length - 1].lastIndex;
        cursor.resolveError();
        cursor.moveTo(lastIndex);
        return new Node$1(this._type, this.name, firstIndex, lastIndex, nodes);
      }
      test(text) {
        const cursor = new Cursor$1(text);
        const ast = this.parse(cursor);
        return (ast === null || ast === void 0 ? void 0 : ast.value) === text;
      }
      exec(text, record = false) {
        const cursor = new Cursor$1(text);
        record && cursor.startRecording();
        const ast = this.parse(cursor);
        return {
          ast: (ast === null || ast === void 0 ? void 0 : ast.value) === text ? ast : null,
          cursor
        };
      }
      clone(name2 = this._name) {
        let min2 = this._min;
        let max2 = this._max;
        const clone = new FiniteRepeat(name2, this._children[0], {
          divider: this._hasDivider ? this._children[1] : void 0,
          min: min2,
          max: max2,
          trimDivider: this._trimDivider
        });
        clone._id = this._id;
        return clone;
      }
      getTokens() {
        return this._children[0].getTokens();
      }
      getTokensAfter(childReference) {
        const patterns = this.getPatternsAfter(childReference);
        const tokens = [];
        patterns.forEach((p) => tokens.push(...p.getTokens()));
        return tokens;
      }
      getNextTokens() {
        if (this._parent == null) {
          return [];
        }
        return this._parent.getTokensAfter(this);
      }
      getPatterns() {
        return this._children[0].getPatterns();
      }
      getPatternsAfter(childReference) {
        const childIndex = this._children.indexOf(childReference);
        if (childIndex === -1) {
          return [];
        }
        if (childIndex === this._children.length - 1) {
          if (this._parent == null) {
            return [];
          } else {
            return this._parent.getPatternsAfter(this);
          }
        }
        const nextChild = this._children[childIndex + 1];
        return nextChild.getPatterns();
      }
      getNextPatterns() {
        if (this._parent == null) {
          return [];
        }
        return this._parent.getPatternsAfter(this);
      }
      find(predicate) {
        return findPattern(this, predicate);
      }
      isEqual(pattern2) {
        return pattern2.type === this.type && this.children.every((c, index) => c.isEqual(pattern2.children[index]));
      }
    }
    let idIndex$4 = 0;
    class InfiniteRepeat {
      get id() {
        return this._id;
      }
      get type() {
        return this._type;
      }
      get name() {
        return this._name;
      }
      get parent() {
        return this._parent;
      }
      set parent(pattern2) {
        this._parent = pattern2;
      }
      get children() {
        return this._children;
      }
      get min() {
        return this._min;
      }
      constructor(name2, pattern2, options = {}) {
        const min2 = options.min != null ? Math.max(options.min, 1) : 1;
        const divider2 = options.divider;
        let children;
        if (divider2 != null) {
          children = [pattern2.clone(), divider2.clone()];
        } else {
          children = [pattern2.clone()];
        }
        this._assignChildrenToParent(children);
        this._id = `infinite-repeat-${idIndex$4++}`;
        this._type = "infinite-repeat";
        this._name = name2;
        this._min = min2;
        this._parent = null;
        this._children = children;
        this._pattern = children[0];
        this._divider = children[1];
        this._firstIndex = -1;
        this._nodes = [];
        this._trimDivider = options.trimDivider == null ? false : options.trimDivider;
      }
      _assignChildrenToParent(children) {
        for (const child of children) {
          child.parent = this;
        }
      }
      test(text) {
        const cursor = new Cursor$1(text);
        const ast = this.parse(cursor);
        return (ast === null || ast === void 0 ? void 0 : ast.value) === text;
      }
      exec(text, record = false) {
        const cursor = new Cursor$1(text);
        record && cursor.startRecording();
        const ast = this.parse(cursor);
        return {
          ast: (ast === null || ast === void 0 ? void 0 : ast.value) === text ? ast : null,
          cursor
        };
      }
      parse(cursor) {
        this._firstIndex = cursor.index;
        this._nodes = [];
        const passed = this._tryToParse(cursor);
        if (passed) {
          cursor.resolveError();
          const node = this._createNode(cursor);
          if (node != null) {
            cursor.moveTo(node.lastIndex);
            cursor.recordMatch(this, node);
          }
          return node;
        }
        if (this._min > 0) {
          return null;
        }
        cursor.resolveError();
        return null;
      }
      _meetsMin() {
        if (this._divider != null) {
          return Math.ceil(this._nodes.length / 2) >= this._min;
        }
        return this._nodes.length >= this._min;
      }
      _tryToParse(cursor) {
        const firstIndex = cursor.index;
        let passed = false;
        while (true) {
          const runningCursorIndex = cursor.index;
          const repeatNode = this._pattern.parse(cursor);
          const hasError = cursor.hasError;
          const hasNoErrorAndNoResult = !cursor.hasError && repeatNode == null;
          const hasDivider = this._divider != null;
          const hasNoDivider = !hasDivider;
          if (hasError) {
            const lastValidNode = this._getLastValidNode();
            if (lastValidNode != null) {
              passed = true;
            } else {
              cursor.moveTo(runningCursorIndex);
              cursor.recordErrorAt(firstIndex, runningCursorIndex, this._pattern);
              passed = false;
            }
            break;
          } else {
            if (hasNoErrorAndNoResult && hasNoDivider) {
              break;
            }
            if (repeatNode != null) {
              this._nodes.push(repeatNode);
              if (!cursor.hasNext()) {
                passed = true;
                break;
              }
              cursor.next();
            }
            if (this._divider != null) {
              const dividerStartIndex = cursor.index;
              const dividerNode = this._divider.parse(cursor);
              if (cursor.hasError) {
                passed = true;
                break;
              } else {
                if (dividerNode == null) {
                  cursor.moveTo(dividerStartIndex);
                  if (repeatNode == null) {
                    passed = true;
                    break;
                  }
                } else {
                  this._nodes.push(dividerNode);
                  if (!cursor.hasNext()) {
                    passed = true;
                    break;
                  }
                  cursor.next();
                }
              }
            }
          }
        }
        const hasMinimum = this._meetsMin();
        if (hasMinimum) {
          return passed;
        } else if (!hasMinimum && passed) {
          cursor.recordErrorAt(firstIndex, cursor.index, this);
          cursor.moveTo(this._firstIndex);
          return false;
        }
        return passed;
      }
      _createNode(cursor) {
        var _a2;
        const hasDivider = this._divider != null;
        if (hasDivider && this._trimDivider && this._nodes[this._nodes.length - 1].name === ((_a2 = this._divider) === null || _a2 === void 0 ? void 0 : _a2.name)) {
          const dividerNode = this._nodes.pop();
          cursor.moveTo(dividerNode.firstIndex);
        }
        if (this._nodes.length === 0) {
          cursor.moveTo(this._firstIndex);
          return null;
        }
        const lastIndex = this._nodes[this._nodes.length - 1].lastIndex;
        cursor.moveTo(lastIndex);
        return new Node$1(this._type, this._name, this._firstIndex, lastIndex, this._nodes);
      }
      _getLastValidNode() {
        const nodes = this._nodes.filter((node) => node !== null);
        if (nodes.length === 0) {
          return null;
        }
        return nodes[nodes.length - 1];
      }
      getTokens() {
        return this._pattern.getTokens();
      }
      getTokensAfter(childReference) {
        const patterns = this.getPatternsAfter(childReference);
        const tokens = [];
        patterns.forEach((p) => tokens.push(...p.getTokens()));
        return tokens;
      }
      getNextTokens() {
        if (this._parent == null) {
          return [];
        }
        return this._parent.getTokensAfter(this);
      }
      getPatterns() {
        return this._pattern.getPatterns();
      }
      getPatternsAfter(childReference) {
        let index = -1;
        const patterns = [];
        for (let i = 0; i < this._children.length; i++) {
          if (this._children[i] === childReference) {
            index = i;
          }
        }
        if (index === -1) {
          return [];
        }
        if (index === 0 && this._divider) {
          patterns.push(this._children[1]);
          if (this._parent) {
            patterns.push(...this._parent.getPatternsAfter(this));
          }
        }
        if (index === 1) {
          patterns.push(this._children[0]);
        }
        if (index === 0 && !this._divider && this._parent) {
          patterns.push(this._children[0]);
          patterns.push(...this._parent.getPatternsAfter(this));
        }
        return patterns;
      }
      getNextPatterns() {
        if (this._parent == null) {
          return [];
        }
        return this._parent.getPatternsAfter(this);
      }
      find(predicate) {
        return findPattern(this, predicate);
      }
      clone(name2 = this._name) {
        let min2 = this._min;
        const clone = new InfiniteRepeat(name2, this._pattern, {
          divider: this._divider == null ? void 0 : this._divider,
          min: min2,
          trimDivider: this._trimDivider
        });
        clone._id = this._id;
        return clone;
      }
      isEqual(pattern2) {
        return pattern2.type === this.type && this.children.every((c, index) => c.isEqual(pattern2.children[index]));
      }
    }
    let idIndex$3 = 0;
    class Repeat {
      get id() {
        return this._id;
      }
      get type() {
        return this._repeatPattern.type;
      }
      get name() {
        return this._repeatPattern.name;
      }
      get parent() {
        return this._parent;
      }
      set parent(value2) {
        this._parent = value2;
      }
      get children() {
        return this._children;
      }
      get min() {
        return this._options.min;
      }
      get max() {
        return this._options.max;
      }
      constructor(name2, pattern2, options = {}) {
        this._id = `repeat-${idIndex$3++}`;
        this._pattern = pattern2;
        this._parent = null;
        this._options = Object.assign(Object.assign({}, options), { min: options.min == null ? 1 : options.min, max: options.max == null ? Infinity : options.max });
        if (this._options.max !== Infinity) {
          this._repeatPattern = new FiniteRepeat(name2, pattern2, this._options);
        } else {
          this._repeatPattern = new InfiniteRepeat(name2, pattern2, this._options);
        }
        this._children = [this._repeatPattern];
        this._repeatPattern.parent = this;
      }
      parse(cursor) {
        return this._repeatPattern.parse(cursor);
      }
      exec(text) {
        return this._repeatPattern.exec(text);
      }
      test(text) {
        return this._repeatPattern.test(text);
      }
      clone(name2 = this.name) {
        let min2 = this._options.min;
        const clone = new Repeat(name2, this._pattern, Object.assign(Object.assign({}, this._options), { min: min2 }));
        clone._id = this._id;
        return clone;
      }
      getTokens() {
        return this._repeatPattern.getTokens();
      }
      getTokensAfter(_childReference) {
        if (this._parent == null) {
          return [];
        }
        return this._parent.getTokensAfter(this);
      }
      getNextTokens() {
        if (this._parent == null) {
          return [];
        }
        return this._parent.getTokensAfter(this);
      }
      getPatterns() {
        return this._repeatPattern.getPatterns();
      }
      getPatternsAfter(_childReference) {
        if (this._parent == null) {
          return [];
        }
        return this._parent.getPatternsAfter(this);
      }
      getNextPatterns() {
        if (this._parent == null) {
          return [];
        }
        return this._parent.getPatternsAfter(this);
      }
      find(predicate) {
        return this._repeatPattern.find(predicate);
      }
      isEqual(pattern2) {
        return pattern2.type === this.type && this.children.every((c, index) => c.isEqual(pattern2.children[index]));
      }
    }
    const comment = new Regex("comment", "#[^\r\n]+");
    comment.setTokens(["# "]);
    function filterOutNull(nodes) {
      const filteredNodes = [];
      for (const node of nodes) {
        if (node !== null) {
          filteredNodes.push(node);
        }
      }
      return filteredNodes;
    }
    const depthCache = new DepthCache();
    let idIndex$2 = 0;
    class Sequence {
      get id() {
        return this._id;
      }
      get type() {
        return this._type;
      }
      get name() {
        return this._name;
      }
      get parent() {
        return this._parent;
      }
      set parent(pattern2) {
        this._parent = pattern2;
      }
      get children() {
        return this._children;
      }
      constructor(name2, sequence) {
        if (sequence.length === 0) {
          throw new Error("Need at least one pattern with a 'sequence' pattern.");
        }
        const children = clonePatterns(sequence);
        this._assignChildrenToParent(children);
        this._id = `sequence-${idIndex$2++}`;
        this._type = "sequence";
        this._name = name2;
        this._parent = null;
        this._children = children;
        this._firstIndex = -1;
        this._nodes = [];
      }
      _assignChildrenToParent(children) {
        for (const child of children) {
          child.parent = this;
        }
      }
      test(text) {
        const cursor = new Cursor$1(text);
        const ast = this.parse(cursor);
        return (ast === null || ast === void 0 ? void 0 : ast.value) === text;
      }
      exec(text, record = false) {
        const cursor = new Cursor$1(text);
        record && cursor.startRecording();
        const ast = this.parse(cursor);
        return {
          ast: (ast === null || ast === void 0 ? void 0 : ast.value) === text ? ast : null,
          cursor
        };
      }
      parse(cursor) {
        this._firstIndex = cursor.index;
        depthCache.incrementDepth(this._id, this._firstIndex);
        this._nodes = [];
        const passed = this.tryToParse(cursor);
        depthCache.decrementDepth(this._id, this._firstIndex);
        if (passed) {
          const node = this.createNode(cursor);
          if (node !== null) {
            cursor.recordMatch(this, node);
          }
          return node;
        }
        return null;
      }
      tryToParse(cursor) {
        if (depthCache.getDepth(this._id, this._firstIndex) > 1) {
          cursor.recordErrorAt(this._firstIndex, this._firstIndex, this);
          return false;
        }
        let passed = false;
        for (let i = 0; i < this._children.length; i++) {
          const runningCursorIndex = cursor.index;
          const nextPatternIndex = i + 1;
          const hasMorePatterns = nextPatternIndex < this._children.length;
          const node = this._children[i].parse(cursor);
          const hasNoError = !cursor.hasError;
          const hadMatch = node !== null;
          if (hasNoError) {
            this._nodes.push(node);
            if (hasMorePatterns) {
              if (hadMatch) {
                if (cursor.hasNext()) {
                  cursor.next();
                  continue;
                } else {
                  if (this.areRemainingPatternsOptional(i)) {
                    passed = true;
                    break;
                  }
                  cursor.recordErrorAt(this._firstIndex, cursor.index + 1, this);
                  break;
                }
              } else {
                cursor.moveTo(runningCursorIndex);
                continue;
              }
            } else {
              const lastNode = this.getLastValidNode();
              if (lastNode === null) {
                cursor.recordErrorAt(this._firstIndex, cursor.index, this);
                break;
              }
              passed = true;
              break;
            }
          } else {
            cursor.moveTo(this._firstIndex);
            break;
          }
        }
        return passed;
      }
      getLastValidNode() {
        const nodes = filterOutNull(this._nodes);
        if (nodes.length === 0) {
          return null;
        }
        return nodes[nodes.length - 1];
      }
      areRemainingPatternsOptional(fromIndex) {
        const startOnIndex = fromIndex + 1;
        const length = this._children.length;
        for (let i = startOnIndex; i < length; i++) {
          const pattern2 = this._children[i];
          if (pattern2.type !== "optional") {
            return false;
          }
        }
        return true;
      }
      createNode(cursor) {
        const children = filterOutNull(this._nodes);
        const lastIndex = children[children.length - 1].lastIndex;
        cursor.moveTo(lastIndex);
        return new Node$1("sequence", this._name, this._firstIndex, lastIndex, children);
      }
      getTokens() {
        const tokens = [];
        for (const child of this._children) {
          tokens.push(...child.getTokens());
          if (child.type !== "optional" && child.type !== "not") {
            break;
          }
        }
        return tokens;
      }
      getTokensAfter(childReference) {
        const patterns = this.getPatternsAfter(childReference);
        const tokens = [];
        patterns.forEach((p) => tokens.push(...p.getTokens()));
        return tokens;
      }
      getNextTokens() {
        if (this.parent == null) {
          return [];
        }
        return this.parent.getTokensAfter(this);
      }
      getPatterns() {
        const patterns = [];
        for (const child of this._children) {
          patterns.push(...child.getPatterns());
          if (child.type !== "optional" && child.type !== "not") {
            break;
          }
        }
        return patterns;
      }
      getPatternsAfter(childReference) {
        const patterns = [];
        let nextSiblingIndex = -1;
        let index = -1;
        for (let i = 0; i < this._children.length; i++) {
          if (this._children[i] === childReference) {
            nextSiblingIndex = i + 1;
            index = i;
            break;
          }
        }
        if (index === -1) {
          return [];
        }
        if (nextSiblingIndex === this._children.length && this._parent !== null) {
          return this._parent.getPatternsAfter(this);
        }
        for (let i = nextSiblingIndex; i < this._children.length; i++) {
          const child = this._children[i];
          patterns.push(child);
          if (child.type !== "optional") {
            break;
          }
          if (i === this._children.length - 1 && this._parent !== null) {
            patterns.push(...this._parent.getPatternsAfter(this));
          }
        }
        return patterns;
      }
      getNextPatterns() {
        if (this.parent == null) {
          return [];
        }
        return this.parent.getPatternsAfter(this);
      }
      find(predicate) {
        return findPattern(this, predicate);
      }
      clone(name2 = this._name) {
        const clone = new Sequence(name2, this._children);
        clone._id = this._id;
        return clone;
      }
      isEqual(pattern2) {
        return pattern2.type === this.type && this.children.every((c, index) => c.isEqual(pattern2.children[index]));
      }
    }
    const literal = new Regex("literal", '"(?:\\\\.|[^"\\\\])*"');
    literal.setTokens(["[LITERAL]"]);
    const tabs$1 = new Regex("tabs", "\\t+");
    tabs$1.setTokens(["	"]);
    const spaces$1 = new Regex("spaces", "[ ]+");
    spaces$1.setTokens([" "]);
    const newLine$1 = new Regex("new-line", "(\\r?\\n)+");
    newLine$1.setTokens(["\n"]);
    const lineSpaces$1 = new Repeat("line-spaces", new Options("line-space", [tabs$1, spaces$1]));
    const allSpaces = new Regex("all-spaces", "\\s+");
    allSpaces.setTokens([" "]);
    const name$1 = new Regex("name", "[a-zA-Z_-]+[a-zA-Z0-9_-]*");
    const regexLiteral = new Regex("regex-literal", "/(\\\\/|[^/\\n\\r])*/");
    regexLiteral.setTokens(["[REGEX_EXPRESSION]"]);
    const patternName$3 = name$1.clone("pattern-name");
    const anonymousLiterals = new Options("anonymous-literals", [
      literal,
      regexLiteral,
      patternName$3,
      new Reference("repeat-literal")
    ]);
    const anonymousWrappedLiterals = new Options("anonymous-wrapped-literals", [
      new Reference("options-literal"),
      new Reference("sequence-literal"),
      new Reference("complex-anonymous-pattern")
    ]);
    let idIndex$1 = 0;
    class Optional {
      get id() {
        return this._id;
      }
      get type() {
        return this._type;
      }
      get name() {
        return this._name;
      }
      get parent() {
        return this._parent;
      }
      set parent(pattern2) {
        this._parent = pattern2;
      }
      get children() {
        return this._children;
      }
      constructor(name2, pattern2) {
        this._id = `optional-${idIndex$1++}`;
        this._type = "optional";
        this._name = name2;
        this._parent = null;
        this._children = [pattern2.clone()];
        this._children[0].parent = this;
      }
      test(text) {
        const cursor = new Cursor$1(text);
        this.parse(cursor);
        return !cursor.hasError;
      }
      exec(text, record = false) {
        const cursor = new Cursor$1(text);
        record && cursor.startRecording();
        const ast = this.parse(cursor);
        return {
          ast: (ast === null || ast === void 0 ? void 0 : ast.value) === text ? ast : null,
          cursor
        };
      }
      parse(cursor) {
        const firstIndex = cursor.index;
        const node = this._children[0].parse(cursor);
        if (cursor.hasError) {
          cursor.resolveError();
          cursor.moveTo(firstIndex);
          return null;
        } else {
          return node;
        }
      }
      clone(name2 = this._name) {
        const optional = new Optional(name2, this._children[0]);
        optional._id = this._id;
        return optional;
      }
      getTokens() {
        return this._children[0].getTokens();
      }
      getTokensAfter(_childReference) {
        const parent = this._parent;
        if (parent != null) {
          return parent.getTokensAfter(this);
        }
        return [];
      }
      getNextTokens() {
        if (this.parent == null) {
          return [];
        }
        return this.parent.getTokensAfter(this);
      }
      getPatterns() {
        return this._children[0].getPatterns();
      }
      getPatternsAfter(_childReference) {
        const parent = this._parent;
        if (parent != null) {
          return parent.getPatternsAfter(this);
        }
        return [];
      }
      getNextPatterns() {
        if (this.parent == null) {
          return [];
        }
        return this.parent.getPatternsAfter(this);
      }
      find(predicate) {
        return predicate(this._children[0]) ? this._children[0] : null;
      }
      isEqual(pattern2) {
        return pattern2.type === this.type && this.children.every((c, index) => c.isEqual(pattern2.children[index]));
      }
    }
    const inlinePatternOpenParen = new Literal("anonymous-pattern-open-paren", "(");
    const inlinePatternCloseParen = new Literal("anonymous-pattern-close-paren", ")");
    const optionalLineSpaces$3 = new Optional("optional-line-spaces", lineSpaces$1);
    const complexAnonymousPattern = new Sequence("complex-anonymous-pattern", [
      inlinePatternOpenParen,
      optionalLineSpaces$3,
      anonymousWrappedLiterals,
      optionalLineSpaces$3,
      inlinePatternCloseParen
    ]);
    const anonymousPattern = new Options("anonymous-pattern", [
      anonymousLiterals,
      complexAnonymousPattern
    ]);
    const optionalSpaces$3 = new Optional("optional-spaces", spaces$1);
    const openBracket$1 = new Literal("repeat-open-bracket", "{");
    const closeBracket$1 = new Literal("repeat-close-bracket", "}");
    const comma = new Literal("comma", ",");
    const integer = new Regex("integer", "([1-9][0-9]*)|0");
    integer.setTokens(["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]);
    const min = new Optional("optional-min", integer.clone("min"));
    const max = new Optional("optional-max", integer.clone("max"));
    const trimKeyword = new Literal("trim-keyword", "trim");
    const trimFlag = new Optional("optional-trim-flag", new Sequence("trim-flag", [lineSpaces$1, trimKeyword]));
    const bounds = new Sequence("bounds", [
      openBracket$1,
      optionalSpaces$3,
      min,
      optionalSpaces$3,
      comma,
      optionalSpaces$3,
      max,
      closeBracket$1
    ]);
    const exactCount = new Sequence("exact-count", [
      openBracket$1,
      optionalSpaces$3,
      integer,
      optionalSpaces$3,
      closeBracket$1
    ]);
    const quantifierShorthand = new Regex("quantifier-shorthand", "\\*|\\+");
    quantifierShorthand.setTokens(["*", "+"]);
    const quantifier = new Options("quantifier", [
      quantifierShorthand,
      exactCount,
      bounds
    ]);
    const openParen = new Literal("repeat-open-paren", "(");
    const closeParen = new Literal("repeat-close-paren", ")");
    const dividerComma = new Regex("divider-comma", "\\s*,\\s*");
    dividerComma.setTokens([", "]);
    const patternName$2 = name$1.clone("pattern-name");
    const repeatPattern = new Options("repeat-pattern", [patternName$2, anonymousPattern]);
    const repeatDividerPattern = repeatPattern.clone("repeat-divider-pattern");
    const repeatDividerSection = new Sequence("repeat-divider-section", [dividerComma, repeatDividerPattern, trimFlag]);
    const repeatOptionalDividerSection = new Optional("repeat-optional-divider-section", repeatDividerSection);
    const repeatLiteral = new Sequence("repeat-literal", [
      openParen,
      optionalSpaces$3,
      repeatPattern,
      repeatOptionalDividerSection,
      optionalSpaces$3,
      closeParen,
      new Sequence("quantifier-section", [quantifier])
    ]);
    const optionalNot = new Optional("optional-not", new Literal("not", "!"));
    const optionalIsOptional$1 = new Optional("optional-is-optional", new Literal("is-optional", "?"));
    const patternName$1 = name$1.clone("pattern-name");
    const patterns$2 = new Options("and-patterns", [patternName$1, anonymousPattern]);
    const pattern$1 = new Sequence("and-child-pattern", [
      optionalNot,
      patterns$2,
      optionalIsOptional$1
    ]);
    const divider$1 = new Regex("and-divider", "\\s*[+]\\s*");
    divider$1.setTokens([" + "]);
    const sequenceLiteral = new Repeat("sequence-literal", pattern$1, { divider: divider$1, min: 2, trimDivider: true });
    const patternName = name$1.clone("pattern-name");
    patternName.setTokens(["[PATTERN_NAME]"]);
    const patterns$1 = new Options("options-patterns", [patternName, anonymousPattern]);
    const defaultDivider = new Regex("default-divider", "\\s*[|]\\s*");
    defaultDivider.setTokens(["|"]);
    const greedyDivider = new Regex("greedy-divider", "\\s*[<][|][>]\\s*");
    greedyDivider.setTokens(["<|>"]);
    const divider = new Options("options-divider", [defaultDivider, greedyDivider]);
    const optionsLiteral = new Repeat("options-literal", patterns$1, { divider, min: 2, trimDivider: true });
    const aliasLiteral = name$1.clone("alias-literal");
    aliasLiteral.setTokens(["[ALIAS_LITERAL]"]);
    const optionalIsOptional = new Optional("optional-flag", new Literal("is-optional", "?"));
    const configurableAnonymousPattern = new Sequence("configurable-anonymous-pattern", [anonymousPattern, optionalIsOptional]);
    const pattern = new Options("pattern", [
      literal,
      regexLiteral,
      repeatLiteral,
      aliasLiteral,
      optionsLiteral,
      sequenceLiteral,
      configurableAnonymousPattern
    ], true);
    const optionalSpaces$2 = new Optional("optional-spaces", spaces$1);
    const assignOperator = new Literal("assign-operator", "=");
    const assignStatement = new Sequence("assign-statement", [
      optionalSpaces$2,
      name$1,
      optionalSpaces$2,
      assignOperator,
      optionalSpaces$2,
      pattern
    ]);
    const statement = new Options("statement", [assignStatement, name$1.clone("export-name")]);
    const bodyLineContent = new Options("body-line-content", [
      comment,
      statement
    ]);
    const optionalLineSpaces$2 = new Optional("optional-line-spaces", lineSpaces$1);
    const bodyLine = new Sequence("body-line", [
      optionalLineSpaces$2,
      new Optional("optional-body-line-content", bodyLineContent),
      optionalLineSpaces$2
    ]);
    const body = new Optional("optional-body", new Repeat("body", bodyLine, { divider: newLine$1 }));
    const optionalSpaces$1 = new Optional("optional-spaces", allSpaces);
    const optionalLineSpaces$1 = new Optional("optional-line-spaces", lineSpaces$1);
    const importNameDivider = new Regex("import-name-divider", "(\\s+)?,(\\s+)?");
    importNameDivider.setTokens([", "]);
    const name = new Regex("import-name", "[^}\\s,]+");
    name.setTokens(["[IMPORT_NAME]"]);
    const importKeyword = new Literal("import", "import");
    const useParamsKeyword = new Literal("use-params", "use params");
    const asKeyword = new Literal("as", "as");
    const fromKeyword = new Literal("from", "from");
    const openBracket = new Literal("open-bracket", "{");
    const closeBracket = new Literal("close-bracket", "}");
    const importNameAlias = name.clone("import-name-alias");
    const importAlias = new Sequence("import-alias", [name, lineSpaces$1, asKeyword, lineSpaces$1, importNameAlias]);
    const importedNames = new Repeat("imported-names", new Options("import-names", [importAlias, name]), { divider: importNameDivider });
    const paramName = name.clone("param-name");
    const paramNames = new Repeat("param-names", paramName, { divider: importNameDivider });
    const resource = literal.clone("resource");
    const useParams = new Sequence("import-params", [
      useParamsKeyword,
      optionalLineSpaces$1,
      openBracket,
      optionalSpaces$1,
      paramNames,
      optionalSpaces$1,
      closeBracket
    ]);
    const withParamsKeyword = new Literal("with-params", "with params");
    const withParamsStatement = new Optional("optional-with-params-statement", new Sequence("with-params-statement", [
      withParamsKeyword,
      optionalLineSpaces$1,
      openBracket,
      optionalSpaces$1,
      body,
      optionalSpaces$1,
      closeBracket
    ]));
    const importFromStatement = new Sequence("import-from", [
      importKeyword,
      optionalLineSpaces$1,
      openBracket,
      optionalSpaces$1,
      importedNames,
      optionalSpaces$1,
      closeBracket,
      optionalLineSpaces$1,
      fromKeyword,
      optionalLineSpaces$1,
      resource,
      optionalLineSpaces$1,
      withParamsStatement
    ]);
    const importStatement = new Options("import-statement", [
      useParams,
      importFromStatement
    ]);
    const tabs = new Regex("tabs", "\\t+");
    const spaces = new Regex("spaces", "[ ]+");
    const newLine = new Regex("new-line", "(\\r?\\n)+");
    spaces.setTokens([" "]);
    tabs.setTokens(["	"]);
    newLine.setTokens(["\n"]);
    const lineSpaces = new Repeat("line-spaces", new Options("line-space", [tabs, spaces]));
    const optionalLineSpaces = new Optional("optional-line-spaces", lineSpaces);
    const headLineContent = new Options("head-line-content", [
      comment,
      importStatement
    ]);
    const headLine = new Sequence("head-line-content", [
      optionalLineSpaces,
      headLineContent,
      optionalLineSpaces
    ]);
    const head = new Optional("optional-head", new Repeat("head", headLine, { divider: newLine }));
    const optionalSpaces = new Optional("optional-spaces", allSpaces);
    const grammar = new Sequence("grammar", [
      optionalSpaces,
      head,
      optionalSpaces,
      body,
      optionalSpaces
    ]);
    let idIndex = 0;
    class Not {
      get id() {
        return this._id;
      }
      get type() {
        return this._type;
      }
      get name() {
        return this._name;
      }
      get parent() {
        return this._parent;
      }
      set parent(pattern2) {
        this._parent = pattern2;
      }
      get children() {
        return this._children;
      }
      constructor(name2, pattern2) {
        this._id = `not-${idIndex++}`;
        this._type = "not";
        this._name = name2;
        this._parent = null;
        this._children = [pattern2.clone()];
        this._children[0].parent = this;
      }
      test(text) {
        const cursor = new Cursor$1(text);
        this.parse(cursor);
        return !cursor.hasError;
      }
      exec(text, record = false) {
        const cursor = new Cursor$1(text);
        record && cursor.startRecording();
        const ast = this.parse(cursor);
        return {
          ast: (ast === null || ast === void 0 ? void 0 : ast.value) === text ? ast : null,
          cursor
        };
      }
      parse(cursor) {
        const firstIndex = cursor.index;
        this._children[0].parse(cursor);
        if (cursor.hasError) {
          cursor.resolveError();
          cursor.moveTo(firstIndex);
        } else {
          cursor.moveTo(firstIndex);
          cursor.resolveError();
          cursor.recordErrorAt(firstIndex, firstIndex, this);
        }
        return null;
      }
      clone(name2 = this._name) {
        const not = new Not(name2, this._children[0]);
        not._id = this._id;
        return not;
      }
      getTokens() {
        const parent = this._parent;
        if (parent != null) {
          return parent.getTokensAfter(this);
        }
        return [];
      }
      getTokensAfter(_childReference) {
        const parent = this._parent;
        if (parent != null) {
          return parent.getTokensAfter(this);
        }
        return [];
      }
      getNextTokens() {
        if (this.parent == null) {
          return [];
        }
        return this.parent.getTokensAfter(this);
      }
      getPatterns() {
        return [...this.getNextPatterns().map((p) => p.getPatterns()).flat()];
      }
      getPatternsAfter(_childReference) {
        const parent = this._parent;
        if (parent != null) {
          return parent.getPatternsAfter(this);
        }
        return [];
      }
      getNextPatterns() {
        if (this.parent == null) {
          return [];
        }
        return this.parent.getPatternsAfter(this);
      }
      find(predicate) {
        return predicate(this._children[0]) ? this._children[0] : null;
      }
      isEqual(pattern2) {
        return pattern2.type === this.type && this.children.every((c, index) => c.isEqual(pattern2.children[index]));
      }
    }
    const defaultOptions$1 = { greedyPatternNames: [], customTokens: {} };
    class AutoComplete {
      constructor(pattern2, options = defaultOptions$1) {
        this._pattern = pattern2;
        this._options = options;
        this._text = "";
      }
      suggestForWithCursor(cursor) {
        cursor.moveTo(0);
        this._cursor = cursor;
        this._text = cursor.text;
        this._cursor.startRecording();
        if (cursor.length === 0) {
          return {
            isComplete: false,
            options: this._createSuggestionsFromRoot(),
            error: new ParseError(0, 0, this._pattern),
            errorAtIndex: 0,
            cursor,
            ast: null
          };
        }
        let errorAtIndex = null;
        let error = null;
        const ast = this._pattern.parse(this._cursor);
        const isComplete = (ast === null || ast === void 0 ? void 0 : ast.value) === this._text;
        const options = this._getAllOptions();
        if (!isComplete && options.length > 0 && !this._cursor.hasError) {
          const startIndex = options.reduce((lowestIndex, o) => {
            return Math.min(lowestIndex, o.startIndex);
          }, Infinity);
          const endIndex = cursor.getLastIndex() + 1;
          error = new ParseError(startIndex, endIndex, this._pattern);
          errorAtIndex = startIndex;
        } else if (!isComplete && options.length === 0 && ast != null) {
          const startIndex = ast.endIndex;
          const endIndex = cursor.getLastIndex() + 1;
          error = new ParseError(startIndex, endIndex, this._pattern);
          errorAtIndex = startIndex;
        } else if (!isComplete && this._cursor.hasError && this._cursor.furthestError != null) {
          errorAtIndex = this._cursor.furthestError.endIndex;
          error = this._cursor.furthestError;
          errorAtIndex = options.reduce((errorAtIndex2, option2) => Math.max(errorAtIndex2, option2.startIndex), errorAtIndex);
        }
        return {
          isComplete,
          options,
          error,
          errorAtIndex,
          cursor,
          ast
        };
      }
      suggestFor(text) {
        return this.suggestForWithCursor(new Cursor$1(text));
      }
      _getAllOptions() {
        const errorMatches = this._getOptionsFromErrors();
        const leafMatches = this._cursor.leafMatches.map((m) => this._createSuggestionsFromMatch(m)).flat();
        const finalResults = [];
        [...leafMatches, ...errorMatches].forEach((m) => {
          const index = finalResults.findIndex((f) => m.text === f.text);
          if (index === -1) {
            finalResults.push(m);
          }
        });
        return finalResults;
      }
      _getOptionsFromErrors() {
        const errors = this._cursor.errors.filter((e) => e.endIndex === this._cursor.length);
        const suggestions2 = errors.map((e) => {
          const tokens = this._getTokensForPattern(e.pattern);
          const adjustedTokens = tokens.map((t) => t.slice(e.endIndex - e.startIndex));
          return this._createSuggestions(e.endIndex, adjustedTokens);
        });
        return suggestions2.flat();
      }
      _createSuggestionsFromRoot() {
        const suggestions2 = [];
        const tokens = this._pattern.getTokens();
        for (const token of tokens) {
          if (suggestions2.findIndex((s) => s.text === token) === -1) {
            suggestions2.push(this._createSuggestion("", token));
          }
        }
        return suggestions2;
      }
      _createSuggestionsFromMatch(match2) {
        if (match2.pattern == null) {
          return this._createSuggestions(-1, this._getTokensForPattern(this._pattern));
        }
        const leafPattern = match2.pattern;
        const parent = match2.pattern.parent;
        if (parent !== null && match2.node != null) {
          const patterns = leafPattern.getNextPatterns();
          const tokens = patterns.reduce((acc, pattern2) => {
            acc.push(...this._getTokensForPattern(pattern2));
            return acc;
          }, []);
          return this._createSuggestions(match2.node.lastIndex, tokens);
        } else {
          return [];
        }
      }
      _getTokensForPattern(pattern2) {
        const augmentedTokens = this._getAugmentedTokens(pattern2);
        if (this._options.greedyPatternNames != null && this._options.greedyPatternNames.includes(pattern2.name)) {
          const nextPatterns = pattern2.getNextPatterns();
          const tokens = [];
          const nextPatternTokens = nextPatterns.reduce((acc, pattern3) => {
            acc.push(...this._getTokensForPattern(pattern3));
            return acc;
          }, []);
          for (let token of augmentedTokens) {
            for (let nextPatternToken of nextPatternTokens) {
              tokens.push(token + nextPatternToken);
            }
          }
          return tokens;
        } else {
          return augmentedTokens;
        }
      }
      _getAugmentedTokens(pattern2) {
        const customTokensMap = this._options.customTokens || {};
        const leafPatterns = pattern2.getPatterns();
        const tokens = customTokensMap[pattern2.name] || [];
        leafPatterns.forEach((p) => {
          const augmentedTokens = customTokensMap[p.name] || [];
          tokens.push(...p.getTokens(), ...augmentedTokens);
        });
        return tokens;
      }
      _createSuggestions(lastIndex, tokens) {
        let substring = lastIndex === -1 ? "" : this._cursor.getChars(0, lastIndex);
        const suggestionStrings = [];
        const options = [];
        for (const token of tokens) {
          const suggestion2 = substring + token;
          const startsWith = suggestion2.startsWith(substring);
          const alreadyExist = suggestionStrings.includes(suggestion2);
          const isSameAsText = suggestion2 === this._text;
          if (startsWith && !alreadyExist && !isSameAsText) {
            suggestionStrings.push(suggestion2);
            options.push(this._createSuggestion(this._cursor.text, suggestion2));
          }
        }
        const reducedOptions = getFurthestOptions(options);
        reducedOptions.sort((a, b) => a.text.localeCompare(b.text));
        return reducedOptions;
      }
      _createSuggestion(fullText, suggestion2) {
        const furthestMatch = findMatchIndex(suggestion2, fullText);
        const text = suggestion2.slice(furthestMatch);
        return {
          text,
          startIndex: furthestMatch
        };
      }
      static suggestFor(text, pattern2, options) {
        return new AutoComplete(pattern2, options).suggestFor(text);
      }
      static suggestForWithCursor(cursor, pattern2, options) {
        return new AutoComplete(pattern2, options).suggestForWithCursor(cursor);
      }
    }
    function findMatchIndex(str1, str2) {
      let matchCount = 0;
      let minLength = str1.length;
      if (str2.length < minLength) {
        minLength = str2.length;
      }
      for (let i = 0; i < minLength; i++) {
        if (str1[i] === str2[i]) {
          matchCount++;
        } else {
          break;
        }
      }
      return matchCount;
    }
    function getFurthestOptions(options) {
      let furthestOptions = [];
      let furthestIndex = -1;
      for (const option2 of options) {
        if (option2.startIndex > furthestIndex) {
          furthestIndex = option2.startIndex;
          furthestOptions = [];
        }
        if (option2.startIndex === furthestIndex) {
          furthestOptions.push(option2);
        }
      }
      return furthestOptions;
    }
    let contextId = 0;
    class Context {
      get id() {
        return this._id;
      }
      get type() {
        return this._type;
      }
      get name() {
        return this._name;
      }
      get parent() {
        return this._parent;
      }
      set parent(pattern2) {
        this._parent = pattern2;
      }
      get children() {
        return this._children;
      }
      getPatternWithinContext(name2) {
        return this._patterns[name2] || null;
      }
      getPatternsWithinContext() {
        return Object.assign({}, this._patterns);
      }
      constructor(name2, pattern2, context = []) {
        this._id = `context-${contextId++}`;
        this._type = "context";
        this._name = name2;
        this._parent = null;
        this._patterns = {};
        const clonedPattern = pattern2.clone();
        context.forEach((p) => this._patterns[p.name] = p);
        clonedPattern.parent = this;
        this._pattern = clonedPattern;
        this._children = [clonedPattern];
      }
      parse(cursor) {
        return this._pattern.parse(cursor);
      }
      exec(text, record) {
        return this._pattern.exec(text, record);
      }
      test(text, record) {
        return this._pattern.test(text, record);
      }
      clone(name2 = this._name) {
        const clone = new Context(name2, this._pattern, Object.values(this._patterns));
        return clone;
      }
      getTokens() {
        return this._pattern.getTokens();
      }
      getTokensAfter(childReference) {
        return this._pattern.getTokensAfter(childReference);
      }
      getNextTokens() {
        return this._pattern.getNextTokens();
      }
      getPatterns() {
        return this._pattern.getPatterns();
      }
      getPatternsAfter(childReference) {
        return this._pattern.getPatternsAfter(childReference);
      }
      getNextPatterns() {
        return this._pattern.getNextPatterns();
      }
      find(predicate) {
        return this._pattern.find(predicate);
      }
      isEqual(pattern2) {
        return pattern2.type === this.type && this.children.every((c, index) => c.isEqual(pattern2.children[index]));
      }
    }
    let anonymousIndexId = 0;
    const patternNodes = {
      "literal": true,
      "regex-literal": true,
      "options-literal": true,
      "sequence-literal": true,
      "repeat-literal": true,
      "alias-literal": true,
      "configurable-anonymous-pattern": true
    };
    class ParseContext {
      constructor(params) {
        this.patternsByName = /* @__PURE__ */ new Map();
        this.importedPatternsByName = /* @__PURE__ */ new Map();
        this.paramsByName = /* @__PURE__ */ new Map();
        params.forEach((p) => this.paramsByName.set(p.name, p));
      }
    }
    function defaultImportResolver(_path, _basePath) {
      throw new Error("No import resolver supplied.");
    }
    class Grammar {
      constructor(options = {}) {
        this._params = (options === null || options === void 0 ? void 0 : options.params) == null ? [] : options.params;
        this._originResource = (options === null || options === void 0 ? void 0 : options.originResource) == null ? null : options.originResource;
        this._resolveImport = options.resolveImport == null ? defaultImportResolver : options.resolveImport;
        this._parseContext = new ParseContext(this._params);
        this._autoComplete = new AutoComplete(grammar, {
          greedyPatternNames: ["spaces", "optional-spaces", "whitespace", "new-line"],
          customTokens: {
            "regex-literal": ["[Regular Expression]"],
            "literal": ["[String]"],
            "name": ["[Pattern Name]"],
            "pattern-name": ["[Pattern Name]"]
          }
        });
      }
      import(path) {
        return __awaiter(this, void 0, void 0, function* () {
          const grammarFile = yield this._resolveImport(path, null);
          const grammar2 = new Grammar({
            resolveImport: this._resolveImport,
            originResource: grammarFile.resource,
            params: this._params
          });
          return grammar2.parse(grammarFile.expression);
        });
      }
      parse(expression) {
        return __awaiter(this, void 0, void 0, function* () {
          this._parseContext = new ParseContext(this._params);
          const ast = this._tryToParse(expression);
          yield this._resolveImports(ast);
          this._buildPatterns(ast);
          return this._buildPatternRecord();
        });
      }
      _buildPatternRecord() {
        const patterns = {};
        const allPatterns = Array.from(this._parseContext.patternsByName.values());
        allPatterns.forEach((p) => {
          patterns[p.name] = new Context(p.name, p, allPatterns.filter((o) => o !== p));
        });
        return patterns;
      }
      parseString(expression) {
        this._parseContext = new ParseContext(this._params);
        const ast = this._tryToParse(expression);
        if (this._hasImports(ast)) {
          throw new Error("Cannot use imports on parseString, use parse instead.");
        }
        this._buildPatterns(ast);
        return this._buildPatternRecord();
      }
      _tryToParse(expression) {
        const { ast, cursor, options, isComplete } = this._autoComplete.suggestFor(expression);
        if (!isComplete) {
          const text = (cursor === null || cursor === void 0 ? void 0 : cursor.text) || "";
          const index = options.reduce((num, o) => Math.max(o.startIndex, num), 0);
          const foundText = text.slice(Math.max(index - 10, 0), index + 10);
          const expectedTexts = "'" + options.map((o) => {
            const startText = text.slice(Math.max(o.startIndex - 10), o.startIndex);
            return startText + o.text;
          }).join("' or '") + "'";
          const message = `[Parse Error] Found: '${foundText}', expected: ${expectedTexts}.`;
          throw new Error(message);
        }
        return ast;
      }
      _hasImports(ast) {
        const importBlock = ast.find((n) => n.name === "import-block");
        if (importBlock == null) {
          return false;
        }
        return importBlock && importBlock.children.length > 0;
      }
      _buildPatterns(ast) {
        const body2 = ast.find((n) => n.name === "body" && n.findAncestor((n2) => n2.name === "head") == null);
        if (body2 == null) {
          return;
        }
        const statements = body2.findAll((n) => n.name === "assign-statement");
        statements.forEach((n) => {
          const patternNode = n.children.find((n2) => patternNodes[n2.name] != null);
          if (patternNode == null) {
            return;
          }
          switch (patternNode.name) {
            case "literal": {
              this._saveLiteral(n);
              break;
            }
            case "regex-literal": {
              this._saveRegex(n);
              break;
            }
            case "options-literal": {
              this._saveOptions(n);
              break;
            }
            case "sequence-literal": {
              this._saveSequence(n);
              break;
            }
            case "repeat-literal": {
              this._saveRepeat(n);
              break;
            }
            case "alias-literal": {
              this._saveAlias(n);
              break;
            }
            case "configurable-anonymous-pattern": {
              this._saveConfigurableAnonymous(n);
              break;
            }
          }
        });
        body2.findAll((n) => n.name === "export-name").forEach((n) => {
          const pattern2 = this._getPattern(n.value).clone();
          this._parseContext.patternsByName.set(n.value, pattern2);
        });
      }
      _saveLiteral(statementNode) {
        const nameNode = statementNode.find((n) => n.name === "name");
        const literalNode = statementNode.find((n) => n.name === "literal");
        const name2 = nameNode.value;
        const literal2 = this._buildLiteral(name2, literalNode);
        this._parseContext.patternsByName.set(name2, literal2);
      }
      _buildLiteral(name2, node) {
        return new Literal(name2, this._resolveStringValue(node.value));
      }
      _resolveStringValue(value2) {
        return value2.replace(/\\n/g, "\n").replace(/\\r/g, "\r").replace(/\\t/g, "	").replace(/\\b/g, "\b").replace(/\\f/g, "\f").replace(/\\v/g, "\v").replace(/\\0/g, "\0").replace(/\\x([0-9A-Fa-f]{2})/g, (_, hex) => String.fromCharCode(parseInt(hex, 16))).replace(/\\u([0-9A-Fa-f]{4})/g, (_, hex) => String.fromCharCode(parseInt(hex, 16))).replace(/\\(.)/g, "$1").slice(1, -1);
      }
      _saveRegex(statementNode) {
        const nameNode = statementNode.find((n) => n.name === "name");
        const regexNode = statementNode.find((n) => n.name === "regex-literal");
        const name2 = nameNode.value;
        const regex = this._buildRegex(name2, regexNode);
        this._parseContext.patternsByName.set(name2, regex);
      }
      _buildRegex(name2, node) {
        const value2 = node.value.slice(1, node.value.length - 1);
        return new Regex(name2, value2);
      }
      _saveOptions(statementNode) {
        const nameNode = statementNode.find((n) => n.name === "name");
        const name2 = nameNode.value;
        const optionsNode = statementNode.find((n) => n.name === "options-literal");
        const options = this._buildOptions(name2, optionsNode);
        this._parseContext.patternsByName.set(name2, options);
      }
      _buildOptions(name2, node) {
        const patternNodes2 = node.children.filter((n) => n.name !== "default-divider" && n.name !== "greedy-divider");
        const isGreedy = node.find((n) => n.name === "greedy-divider") != null;
        const patterns = patternNodes2.map((n) => this._buildPattern(n));
        const or = new Options(name2, patterns, isGreedy);
        return or;
      }
      _buildPattern(node) {
        const type = node.name;
        const name2 = `anonymous-pattern-${anonymousIndexId++}`;
        switch (type) {
          case "pattern-name": {
            return this._getPattern(node.value).clone();
          }
          case "literal": {
            return this._buildLiteral(node.value.slice(1, -1), node);
          }
          case "regex-literal": {
            return this._buildRegex(node.value.slice(1, -1), node);
          }
          case "repeat-literal": {
            return this._buildRepeat(name2, node);
          }
          case "options-literal": {
            return this._buildOptions(name2, node);
          }
          case "sequence-literal": {
            return this._buildSequence(name2, node);
          }
          case "complex-anonymous-pattern": {
            return this._buildComplexAnonymousPattern(node);
          }
        }
        throw new Error(`Couldn't build node: ${node.name}.`);
      }
      _saveSequence(statementNode) {
        const nameNode = statementNode.find((n) => n.name === "name");
        const name2 = nameNode.value;
        const sequenceNode = statementNode.find((n) => n.name === "sequence-literal");
        const sequence = this._buildSequence(name2, sequenceNode);
        this._parseContext.patternsByName.set(name2, sequence);
      }
      _buildSequence(name2, node) {
        const patternNodes2 = node.children.filter((n) => n.name !== "and-divider");
        const patterns = patternNodes2.map((n) => {
          const patternNode = n.children[0].name === "not" ? n.children[1] : n.children[0];
          const isNot = n.find((n2) => n2.name === "not") != null;
          const isOptional = n.find((n2) => n2.name === "is-optional");
          const pattern2 = this._buildPattern(patternNode);
          const finalPattern = isOptional ? new Optional(pattern2.name, pattern2) : pattern2;
          if (isNot) {
            return new Not(`not-${finalPattern.name}`, finalPattern);
          }
          return finalPattern;
        });
        return new Sequence(name2, patterns);
      }
      _saveRepeat(statementNode) {
        const nameNode = statementNode.find((n) => n.name === "name");
        const name2 = nameNode.value;
        const repeatNode = statementNode.find((n) => n.name === "repeat-literal");
        const repeat = this._buildRepeat(name2, repeatNode);
        this._parseContext.patternsByName.set(name2, repeat);
      }
      _buildRepeat(name2, repeatNode) {
        let isOptional = false;
        const bounds2 = repeatNode.find((n) => n.name === "bounds");
        const exactCount2 = repeatNode.find((n) => n.name === "exact-count");
        const quantifier2 = repeatNode.find((n) => n.name === "quantifier-shorthand");
        const trimDivider = repeatNode.find((n) => n.name === "trim-flag") != null;
        const patterNode = repeatNode.children[1].type === "spaces" ? repeatNode.children[2] : repeatNode.children[1];
        const pattern2 = this._buildPattern(patterNode);
        const dividerSectionNode = repeatNode.find((n) => n.name === "repeat-divider-section");
        const options = {
          min: 1,
          max: Infinity
        };
        if (trimDivider) {
          options.trimDivider = trimDivider;
        }
        if (dividerSectionNode != null) {
          const dividerNode = dividerSectionNode.children[1];
          options.divider = this._buildPattern(dividerNode);
        }
        if (bounds2 != null) {
          const minNode = bounds2.find((p) => p.name === "min");
          const maxNode = bounds2.find((p) => p.name === "max");
          const min2 = minNode == null ? 0 : Number(minNode.value);
          const max2 = maxNode == null ? Infinity : Number(maxNode.value);
          options.min = min2;
          options.max = max2;
        } else if (exactCount2 != null) {
          const integerNode = exactCount2.find((p) => p.name === "integer");
          const integer2 = Number(integerNode.value);
          options.min = integer2;
          options.max = integer2;
        } else if (quantifier2 != null) {
          const type = quantifier2.value;
          if (type === "+") {
            options.min = 1;
            options.max = Infinity;
          } else {
            isOptional = true;
          }
        }
        return isOptional ? new Optional(name2, new Repeat(name2, pattern2, options)) : new Repeat(name2, pattern2, options);
      }
      _saveConfigurableAnonymous(node) {
        const nameNode = node.find((n) => n.name === "name");
        const name2 = nameNode.value;
        const anonymousNode = node.find((n) => n.name === "complex-anonymous-pattern");
        const isOptional = node.children[1] != null;
        const anonymous = isOptional ? new Optional(name2, this._buildPattern(anonymousNode)) : this._buildPattern(anonymousNode);
        this._parseContext.patternsByName.set(name2, anonymous);
      }
      _buildComplexAnonymousPattern(node) {
        const wrappedNode = node.children[1].name === "line-spaces" ? node.children[2] : node.children[1];
        return this._buildPattern(wrappedNode);
      }
      _resolveImports(ast) {
        return __awaiter(this, void 0, void 0, function* () {
          const parseContext = this._parseContext;
          const importStatements = ast.findAll((n) => n.name === "import-from");
          for (const importStatement2 of importStatements) {
            const resourceNode = importStatement2.find((n) => n.name === "resource");
            const params = this._getParams(importStatement2);
            const resource2 = resourceNode.value.slice(1, -1);
            const grammarFile = yield this._resolveImport(resource2, this._originResource || null);
            const grammar2 = new Grammar({
              resolveImport: this._resolveImport,
              originResource: grammarFile.resource,
              params
            });
            try {
              const patterns = yield grammar2.parse(grammarFile.expression);
              const importStatements2 = importStatement2.findAll((n) => n.name === "import-name" || n.name === "import-alias");
              importStatements2.forEach((node) => {
                var _a2, _b;
                if (node.name === "import-name" && ((_a2 = node.parent) === null || _a2 === void 0 ? void 0 : _a2.name) === "import-alias") {
                  return;
                }
                if (node.name === "import-name" && ((_b = node.parent) === null || _b === void 0 ? void 0 : _b.name) !== "import-alias") {
                  const importName = node.value;
                  if (parseContext.importedPatternsByName.has(importName)) {
                    throw new Error(`'${importName}' was already used within another import.`);
                  }
                  const pattern2 = patterns[importName];
                  if (pattern2 == null) {
                    throw new Error(`Couldn't find pattern with name: ${importName}, from import: ${resource2}.`);
                  }
                  parseContext.importedPatternsByName.set(importName, pattern2);
                } else {
                  const importNameNode = node.find((n) => n.name === "import-name");
                  const importName = importNameNode.value;
                  const aliasNode = node.find((n) => n.name === "import-name-alias");
                  const alias = aliasNode.value;
                  if (parseContext.importedPatternsByName.has(alias)) {
                    throw new Error(`'${alias}' was already used within another import.`);
                  }
                  const pattern2 = patterns[importName];
                  if (pattern2 == null) {
                    throw new Error(`Couldn't find pattern with name: ${importName}, from import: ${resource2}.`);
                  }
                  parseContext.importedPatternsByName.set(alias, pattern2.clone(alias));
                }
              });
            } catch (e) {
              throw new Error(`Failed loading expression from: "${resource2}". Error details: "${e.message}"`);
            }
          }
        });
      }
      _getParams(importStatement2) {
        let params = [];
        const paramsStatement = importStatement2.find((n) => n.name === "with-params-statement");
        if (paramsStatement != null) {
          const statements = paramsStatement.find((n) => n.name === "body");
          if (statements != null) {
            const expression = statements.toString();
            const importedValues = Array.from(this._parseContext.importedPatternsByName.values());
            const grammar2 = new Grammar({
              params: [...importedValues, ...this._parseContext.paramsByName.values()],
              originResource: this._originResource,
              resolveImport: this._resolveImport
            });
            const patterns = grammar2.parseString(expression);
            params = Array.from(Object.values(patterns));
          }
        }
        return params;
      }
      _getPattern(name2) {
        let pattern2 = this._parseContext.patternsByName.get(name2);
        if (pattern2 == null) {
          pattern2 = this._parseContext.importedPatternsByName.get(name2);
        }
        if (pattern2 == null) {
          pattern2 = this._parseContext.paramsByName.get(name2);
        }
        if (pattern2 == null) {
          return new Reference(name2);
        }
        return pattern2;
      }
      _saveAlias(statementNode) {
        const nameNode = statementNode.find((n) => n.name === "name");
        const aliasNode = statementNode.find((n) => n.name === "alias-literal");
        const aliasName = aliasNode.value;
        const name2 = nameNode.value;
        const alias = this._getPattern(aliasName).clone(name2);
        this._parseContext.patternsByName.set(name2, alias);
      }
      static parse(expression, options) {
        const grammar2 = new Grammar(options);
        return grammar2.parse(expression);
      }
      static import(path, options) {
        const grammar2 = new Grammar(options);
        return grammar2.import(path);
      }
      static parseString(expression, options) {
        const grammar2 = new Grammar(options);
        return grammar2.parseString(expression);
      }
    }
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function initCloneArray(array) {
      var length = array.length, result = new array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    var reFlags = /\w*$/;
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    var boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]";
    var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag$1:
          return cloneArrayBuffer(object);
        case boolTag$1:
        case dateTag$1:
          return new Ctor(+object);
        case dataViewTag$1:
          return cloneDataView(object, isDeep);
        case float32Tag$1:
        case float64Tag$1:
        case int8Tag$1:
        case int16Tag$1:
        case int32Tag$1:
        case uint8Tag$1:
        case uint8ClampedTag$1:
        case uint16Tag$1:
        case uint32Tag$1:
          return cloneTypedArray(object, isDeep);
        case mapTag$2:
          return new Ctor();
        case numberTag$1:
        case stringTag$1:
          return new Ctor(object);
        case regexpTag$1:
          return cloneRegExp(object);
        case setTag$2:
          return new Ctor();
        case symbolTag$1:
          return cloneSymbol(object);
      }
    }
    var mapTag$1 = "[object Map]";
    function baseIsMap(value2) {
      return isObjectLike(value2) && getTag(value2) == mapTag$1;
    }
    var nodeIsMap = nodeUtil && nodeUtil.isMap;
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
    var setTag$1 = "[object Set]";
    function baseIsSet(value2) {
      return isObjectLike(value2) && getTag(value2) == setTag$1;
    }
    var nodeIsSet = nodeUtil && nodeUtil.isSet;
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
    var CLONE_DEEP_FLAG$1 = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$1 = 4;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    function baseClone(value2, bitmask, customizer, key, object, stack) {
      var result, isDeep = bitmask & CLONE_DEEP_FLAG$1, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG$1;
      if (result !== void 0) {
        return result;
      }
      if (!isObject(value2)) {
        return value2;
      }
      var isArr = isArray(value2);
      if (isArr) {
        result = initCloneArray(value2);
        if (!isDeep) {
          return copyArray(value2, result);
        }
      } else {
        var tag = getTag(value2), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value2)) {
          return cloneBuffer(value2, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          result = isFlat || isFunc ? {} : initCloneObject(value2);
          if (!isDeep) {
            return isFlat ? copySymbolsIn(value2, baseAssignIn(result, value2)) : copySymbols(value2, baseAssign(result, value2));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value2 : {};
          }
          result = initCloneByTag(value2, tag, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value2);
      if (stacked) {
        return stacked;
      }
      stack.set(value2, result);
      if (isSet(value2)) {
        value2.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value2, stack));
        });
      } else if (isMap(value2)) {
        value2.forEach(function(subValue, key2) {
          result.set(key2, baseClone(subValue, bitmask, customizer, key2, value2, stack));
        });
      }
      var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
      var props = isArr ? void 0 : keysFunc(value2);
      arrayEach(props || value2, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value2[key2];
        }
        assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value2, stack));
      });
      return result;
    }
    var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
    function cloneDeep(value2) {
      return baseClone(value2, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }
    function isEqual$1(value2, other) {
      return baseIsEqual(value2, other);
    }
    var Scope = /* @__PURE__ */ ((Scope2) => (Scope2[Scope2.TYPE = 3] = "TYPE", Scope2[Scope2.LEVEL = 12] = "LEVEL", Scope2[Scope2.ATTRIBUTE = 13] = "ATTRIBUTE", Scope2[Scope2.BLOT = 14] = "BLOT", Scope2[Scope2.INLINE = 7] = "INLINE", Scope2[Scope2.BLOCK = 11] = "BLOCK", Scope2[Scope2.BLOCK_BLOT = 10] = "BLOCK_BLOT", Scope2[Scope2.INLINE_BLOT = 6] = "INLINE_BLOT", Scope2[Scope2.BLOCK_ATTRIBUTE = 9] = "BLOCK_ATTRIBUTE", Scope2[Scope2.INLINE_ATTRIBUTE = 5] = "INLINE_ATTRIBUTE", Scope2[Scope2.ANY = 15] = "ANY", Scope2))(Scope || {});
    class Attributor {
      constructor(attrName, keyName, options = {}) {
        this.attrName = attrName, this.keyName = keyName;
        const attributeBit = Scope.TYPE & Scope.ATTRIBUTE;
        this.scope = options.scope != null ? (
          // Ignore type bits, force attribute bit
          options.scope & Scope.LEVEL | attributeBit
        ) : Scope.ATTRIBUTE, options.whitelist != null && (this.whitelist = options.whitelist);
      }
      static keys(node) {
        return Array.from(node.attributes).map((item) => item.name);
      }
      add(node, value2) {
        return this.canAdd(node, value2) ? (node.setAttribute(this.keyName, value2), true) : false;
      }
      canAdd(_node, value2) {
        return this.whitelist == null ? true : typeof value2 == "string" ? this.whitelist.indexOf(value2.replace(/["']/g, "")) > -1 : this.whitelist.indexOf(value2) > -1;
      }
      remove(node) {
        node.removeAttribute(this.keyName);
      }
      value(node) {
        const value2 = node.getAttribute(this.keyName);
        return this.canAdd(node, value2) && value2 ? value2 : "";
      }
    }
    class ParchmentError extends Error {
      constructor(message) {
        message = "[Parchment] " + message, super(message), this.message = message, this.name = this.constructor.name;
      }
    }
    const _Registry = class _Registry2 {
      constructor() {
        this.attributes = {}, this.classes = {}, this.tags = {}, this.types = {};
      }
      static find(node, bubble2 = false) {
        if (node == null)
          return null;
        if (this.blots.has(node))
          return this.blots.get(node) || null;
        if (bubble2) {
          let parentNode = null;
          try {
            parentNode = node.parentNode;
          } catch {
            return null;
          }
          return this.find(parentNode, bubble2);
        }
        return null;
      }
      create(scroll, input2, value2) {
        const match2 = this.query(input2);
        if (match2 == null)
          throw new ParchmentError(`Unable to create ${input2} blot`);
        const blotClass = match2, node = (
          // @ts-expect-error Fix me later
          input2 instanceof Node || input2.nodeType === Node.TEXT_NODE ? input2 : blotClass.create(value2)
        ), blot = new blotClass(scroll, node, value2);
        return _Registry2.blots.set(blot.domNode, blot), blot;
      }
      find(node, bubble2 = false) {
        return _Registry2.find(node, bubble2);
      }
      query(query, scope = Scope.ANY) {
        let match2;
        return typeof query == "string" ? match2 = this.types[query] || this.attributes[query] : query instanceof Text || query.nodeType === Node.TEXT_NODE ? match2 = this.types.text : typeof query == "number" ? query & Scope.LEVEL & Scope.BLOCK ? match2 = this.types.block : query & Scope.LEVEL & Scope.INLINE && (match2 = this.types.inline) : query instanceof Element && ((query.getAttribute("class") || "").split(/\s+/).some((name2) => (match2 = this.classes[name2], !!match2)), match2 = match2 || this.tags[query.tagName]), match2 == null ? null : "scope" in match2 && scope & Scope.LEVEL & match2.scope && scope & Scope.TYPE & match2.scope ? match2 : null;
      }
      register(...definitions) {
        return definitions.map((definition) => {
          const isBlot = "blotName" in definition, isAttr = "attrName" in definition;
          if (!isBlot && !isAttr)
            throw new ParchmentError("Invalid definition");
          if (isBlot && definition.blotName === "abstract")
            throw new ParchmentError("Cannot register abstract class");
          const key = isBlot ? definition.blotName : isAttr ? definition.attrName : void 0;
          return this.types[key] = definition, isAttr ? typeof definition.keyName == "string" && (this.attributes[definition.keyName] = definition) : isBlot && (definition.className && (this.classes[definition.className] = definition), definition.tagName && (Array.isArray(definition.tagName) ? definition.tagName = definition.tagName.map((tagName) => tagName.toUpperCase()) : definition.tagName = definition.tagName.toUpperCase(), (Array.isArray(definition.tagName) ? definition.tagName : [definition.tagName]).forEach((tag) => {
            (this.tags[tag] == null || definition.className == null) && (this.tags[tag] = definition);
          }))), definition;
        });
      }
    };
    _Registry.blots = /* @__PURE__ */ new WeakMap();
    let Registry = _Registry;
    function match(node, prefix) {
      return (node.getAttribute("class") || "").split(/\s+/).filter((name2) => name2.indexOf(`${prefix}-`) === 0);
    }
    class ClassAttributor extends Attributor {
      static keys(node) {
        return (node.getAttribute("class") || "").split(/\s+/).map((name2) => name2.split("-").slice(0, -1).join("-"));
      }
      add(node, value2) {
        return this.canAdd(node, value2) ? (this.remove(node), node.classList.add(`${this.keyName}-${value2}`), true) : false;
      }
      remove(node) {
        match(node, this.keyName).forEach((name2) => {
          node.classList.remove(name2);
        }), node.classList.length === 0 && node.removeAttribute("class");
      }
      value(node) {
        const value2 = (match(node, this.keyName)[0] || "").slice(this.keyName.length + 1);
        return this.canAdd(node, value2) ? value2 : "";
      }
    }
    const ClassAttributor$1 = ClassAttributor;
    function camelize(name2) {
      const parts = name2.split("-"), rest = parts.slice(1).map((part) => part[0].toUpperCase() + part.slice(1)).join("");
      return parts[0] + rest;
    }
    class StyleAttributor extends Attributor {
      static keys(node) {
        return (node.getAttribute("style") || "").split(";").map((value2) => value2.split(":")[0].trim());
      }
      add(node, value2) {
        return this.canAdd(node, value2) ? (node.style[camelize(this.keyName)] = value2, true) : false;
      }
      remove(node) {
        node.style[camelize(this.keyName)] = "", node.getAttribute("style") || node.removeAttribute("style");
      }
      value(node) {
        const value2 = node.style[camelize(this.keyName)];
        return this.canAdd(node, value2) ? value2 : "";
      }
    }
    const StyleAttributor$1 = StyleAttributor;
    class AttributorStore {
      constructor(domNode) {
        this.attributes = {}, this.domNode = domNode, this.build();
      }
      attribute(attribute, value2) {
        value2 ? attribute.add(this.domNode, value2) && (attribute.value(this.domNode) != null ? this.attributes[attribute.attrName] = attribute : delete this.attributes[attribute.attrName]) : (attribute.remove(this.domNode), delete this.attributes[attribute.attrName]);
      }
      build() {
        this.attributes = {};
        const blot = Registry.find(this.domNode);
        if (blot == null)
          return;
        const attributes = Attributor.keys(this.domNode), classes = ClassAttributor$1.keys(this.domNode), styles2 = StyleAttributor$1.keys(this.domNode);
        attributes.concat(classes).concat(styles2).forEach((name2) => {
          const attr = blot.scroll.query(name2, Scope.ATTRIBUTE);
          attr instanceof Attributor && (this.attributes[attr.attrName] = attr);
        });
      }
      copy(target) {
        Object.keys(this.attributes).forEach((key) => {
          const value2 = this.attributes[key].value(this.domNode);
          target.format(key, value2);
        });
      }
      move(target) {
        this.copy(target), Object.keys(this.attributes).forEach((key) => {
          this.attributes[key].remove(this.domNode);
        }), this.attributes = {};
      }
      values() {
        return Object.keys(this.attributes).reduce(
          (attributes, name2) => (attributes[name2] = this.attributes[name2].value(this.domNode), attributes),
          {}
        );
      }
    }
    const AttributorStore$1 = AttributorStore, _ShadowBlot = class _ShadowBlot {
      constructor(scroll, domNode) {
        this.scroll = scroll, this.domNode = domNode, Registry.blots.set(domNode, this), this.prev = null, this.next = null;
      }
      static create(rawValue) {
        if (this.tagName == null)
          throw new ParchmentError("Blot definition missing tagName");
        let node, value2;
        return Array.isArray(this.tagName) ? (typeof rawValue == "string" ? (value2 = rawValue.toUpperCase(), parseInt(value2, 10).toString() === value2 && (value2 = parseInt(value2, 10))) : typeof rawValue == "number" && (value2 = rawValue), typeof value2 == "number" ? node = document.createElement(this.tagName[value2 - 1]) : value2 && this.tagName.indexOf(value2) > -1 ? node = document.createElement(value2) : node = document.createElement(this.tagName[0])) : node = document.createElement(this.tagName), this.className && node.classList.add(this.className), node;
      }
      // Hack for accessing inherited static methods
      get statics() {
        return this.constructor;
      }
      attach() {
      }
      clone() {
        const domNode = this.domNode.cloneNode(false);
        return this.scroll.create(domNode);
      }
      detach() {
        this.parent != null && this.parent.removeChild(this), Registry.blots.delete(this.domNode);
      }
      deleteAt(index, length) {
        this.isolate(index, length).remove();
      }
      formatAt(index, length, name2, value2) {
        const blot = this.isolate(index, length);
        if (this.scroll.query(name2, Scope.BLOT) != null && value2)
          blot.wrap(name2, value2);
        else if (this.scroll.query(name2, Scope.ATTRIBUTE) != null) {
          const parent = this.scroll.create(this.statics.scope);
          blot.wrap(parent), parent.format(name2, value2);
        }
      }
      insertAt(index, value2, def) {
        const blot = def == null ? this.scroll.create("text", value2) : this.scroll.create(value2, def), ref = this.split(index);
        this.parent.insertBefore(blot, ref || void 0);
      }
      isolate(index, length) {
        const target = this.split(index);
        if (target == null)
          throw new Error("Attempt to isolate at end");
        return target.split(length), target;
      }
      length() {
        return 1;
      }
      offset(root2 = this.parent) {
        return this.parent == null || this === root2 ? 0 : this.parent.children.offset(this) + this.parent.offset(root2);
      }
      optimize(_context) {
        this.statics.requiredContainer && !(this.parent instanceof this.statics.requiredContainer) && this.wrap(this.statics.requiredContainer.blotName);
      }
      remove() {
        this.domNode.parentNode != null && this.domNode.parentNode.removeChild(this.domNode), this.detach();
      }
      replaceWith(name2, value2) {
        const replacement = typeof name2 == "string" ? this.scroll.create(name2, value2) : name2;
        return this.parent != null && (this.parent.insertBefore(replacement, this.next || void 0), this.remove()), replacement;
      }
      split(index, _force) {
        return index === 0 ? this : this.next;
      }
      update(_mutations, _context) {
      }
      wrap(name2, value2) {
        const wrapper = typeof name2 == "string" ? this.scroll.create(name2, value2) : name2;
        if (this.parent != null && this.parent.insertBefore(wrapper, this.next || void 0), typeof wrapper.appendChild != "function")
          throw new ParchmentError(`Cannot wrap ${name2}`);
        return wrapper.appendChild(this), wrapper;
      }
    };
    _ShadowBlot.blotName = "abstract";
    let ShadowBlot = _ShadowBlot;
    const _LeafBlot = class _LeafBlot extends ShadowBlot {
      /**
       * Returns the value represented by domNode if it is this Blot's type
       * No checking that domNode can represent this Blot type is required so
       * applications needing it should check externally before calling.
       */
      static value(_domNode) {
        return true;
      }
      /**
       * Given location represented by node and offset from DOM Selection Range,
       * return index to that location.
       */
      index(node, offset) {
        return this.domNode === node || this.domNode.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY ? Math.min(offset, 1) : -1;
      }
      /**
       * Given index to location within blot, return node and offset representing
       * that location, consumable by DOM Selection Range
       */
      position(index, _inclusive) {
        let offset = Array.from(this.parent.domNode.childNodes).indexOf(this.domNode);
        return index > 0 && (offset += 1), [this.parent.domNode, offset];
      }
      /**
       * Return value represented by this blot
       * Should not change without interaction from API or
       * user change detectable by update()
       */
      value() {
        return {
          [this.statics.blotName]: this.statics.value(this.domNode) || true
        };
      }
    };
    _LeafBlot.scope = Scope.INLINE_BLOT;
    let LeafBlot = _LeafBlot;
    const LeafBlot$1 = LeafBlot;
    class LinkedList {
      constructor() {
        this.head = null, this.tail = null, this.length = 0;
      }
      append(...nodes) {
        if (this.insertBefore(nodes[0], null), nodes.length > 1) {
          const rest = nodes.slice(1);
          this.append(...rest);
        }
      }
      at(index) {
        const next = this.iterator();
        let cur = next();
        for (; cur && index > 0; )
          index -= 1, cur = next();
        return cur;
      }
      contains(node) {
        const next = this.iterator();
        let cur = next();
        for (; cur; ) {
          if (cur === node)
            return true;
          cur = next();
        }
        return false;
      }
      indexOf(node) {
        const next = this.iterator();
        let cur = next(), index = 0;
        for (; cur; ) {
          if (cur === node)
            return index;
          index += 1, cur = next();
        }
        return -1;
      }
      insertBefore(node, refNode) {
        node != null && (this.remove(node), node.next = refNode, refNode != null ? (node.prev = refNode.prev, refNode.prev != null && (refNode.prev.next = node), refNode.prev = node, refNode === this.head && (this.head = node)) : this.tail != null ? (this.tail.next = node, node.prev = this.tail, this.tail = node) : (node.prev = null, this.head = this.tail = node), this.length += 1);
      }
      offset(target) {
        let index = 0, cur = this.head;
        for (; cur != null; ) {
          if (cur === target)
            return index;
          index += cur.length(), cur = cur.next;
        }
        return -1;
      }
      remove(node) {
        this.contains(node) && (node.prev != null && (node.prev.next = node.next), node.next != null && (node.next.prev = node.prev), node === this.head && (this.head = node.next), node === this.tail && (this.tail = node.prev), this.length -= 1);
      }
      iterator(curNode = this.head) {
        return () => {
          const ret = curNode;
          return curNode != null && (curNode = curNode.next), ret;
        };
      }
      find(index, inclusive = false) {
        const next = this.iterator();
        let cur = next();
        for (; cur; ) {
          const length = cur.length();
          if (index < length || inclusive && index === length && (cur.next == null || cur.next.length() !== 0))
            return [cur, index];
          index -= length, cur = next();
        }
        return [null, 0];
      }
      forEach(callback) {
        const next = this.iterator();
        let cur = next();
        for (; cur; )
          callback(cur), cur = next();
      }
      forEachAt(index, length, callback) {
        if (length <= 0)
          return;
        const [startNode, offset] = this.find(index);
        let curIndex = index - offset;
        const next = this.iterator(startNode);
        let cur = next();
        for (; cur && curIndex < index + length; ) {
          const curLength = cur.length();
          index > curIndex ? callback(
            cur,
            index - curIndex,
            Math.min(length, curIndex + curLength - index)
          ) : callback(cur, 0, Math.min(curLength, index + length - curIndex)), curIndex += curLength, cur = next();
        }
      }
      map(callback) {
        return this.reduce((memo, cur) => (memo.push(callback(cur)), memo), []);
      }
      reduce(callback, memo) {
        const next = this.iterator();
        let cur = next();
        for (; cur; )
          memo = callback(memo, cur), cur = next();
        return memo;
      }
    }
    function makeAttachedBlot(node, scroll) {
      const found = scroll.find(node);
      if (found)
        return found;
      try {
        return scroll.create(node);
      } catch {
        const blot = scroll.create(Scope.INLINE);
        return Array.from(node.childNodes).forEach((child) => {
          blot.domNode.appendChild(child);
        }), node.parentNode && node.parentNode.replaceChild(blot.domNode, node), blot.attach(), blot;
      }
    }
    const _ParentBlot = class _ParentBlot2 extends ShadowBlot {
      constructor(scroll, domNode) {
        super(scroll, domNode), this.uiNode = null, this.build();
      }
      appendChild(other) {
        this.insertBefore(other);
      }
      attach() {
        super.attach(), this.children.forEach((child) => {
          child.attach();
        });
      }
      attachUI(node) {
        this.uiNode != null && this.uiNode.remove(), this.uiNode = node, _ParentBlot2.uiClass && this.uiNode.classList.add(_ParentBlot2.uiClass), this.uiNode.setAttribute("contenteditable", "false"), this.domNode.insertBefore(this.uiNode, this.domNode.firstChild);
      }
      /**
       * Called during construction, should fill its own children LinkedList.
       */
      build() {
        this.children = new LinkedList(), Array.from(this.domNode.childNodes).filter((node) => node !== this.uiNode).reverse().forEach((node) => {
          try {
            const child = makeAttachedBlot(node, this.scroll);
            this.insertBefore(child, this.children.head || void 0);
          } catch (err) {
            if (err instanceof ParchmentError)
              return;
            throw err;
          }
        });
      }
      deleteAt(index, length) {
        if (index === 0 && length === this.length())
          return this.remove();
        this.children.forEachAt(index, length, (child, offset, childLength) => {
          child.deleteAt(offset, childLength);
        });
      }
      descendant(criteria, index = 0) {
        const [child, offset] = this.children.find(index);
        return criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria ? [child, offset] : child instanceof _ParentBlot2 ? child.descendant(criteria, offset) : [null, -1];
      }
      descendants(criteria, index = 0, length = Number.MAX_VALUE) {
        let descendants = [], lengthLeft = length;
        return this.children.forEachAt(
          index,
          length,
          (child, childIndex, childLength) => {
            (criteria.blotName == null && criteria(child) || criteria.blotName != null && child instanceof criteria) && descendants.push(child), child instanceof _ParentBlot2 && (descendants = descendants.concat(
              child.descendants(criteria, childIndex, lengthLeft)
            )), lengthLeft -= childLength;
          }
        ), descendants;
      }
      detach() {
        this.children.forEach((child) => {
          child.detach();
        }), super.detach();
      }
      enforceAllowedChildren() {
        let done = false;
        this.children.forEach((child) => {
          done || this.statics.allowedChildren.some(
            (def) => child instanceof def
          ) || (child.statics.scope === Scope.BLOCK_BLOT ? (child.next != null && this.splitAfter(child), child.prev != null && this.splitAfter(child.prev), child.parent.unwrap(), done = true) : child instanceof _ParentBlot2 ? child.unwrap() : child.remove());
        });
      }
      formatAt(index, length, name2, value2) {
        this.children.forEachAt(index, length, (child, offset, childLength) => {
          child.formatAt(offset, childLength, name2, value2);
        });
      }
      insertAt(index, value2, def) {
        const [child, offset] = this.children.find(index);
        if (child)
          child.insertAt(offset, value2, def);
        else {
          const blot = def == null ? this.scroll.create("text", value2) : this.scroll.create(value2, def);
          this.appendChild(blot);
        }
      }
      insertBefore(childBlot, refBlot) {
        childBlot.parent != null && childBlot.parent.children.remove(childBlot);
        let refDomNode = null;
        this.children.insertBefore(childBlot, refBlot || null), childBlot.parent = this, refBlot != null && (refDomNode = refBlot.domNode), (this.domNode.parentNode !== childBlot.domNode || this.domNode.nextSibling !== refDomNode) && this.domNode.insertBefore(childBlot.domNode, refDomNode), childBlot.attach();
      }
      length() {
        return this.children.reduce((memo, child) => memo + child.length(), 0);
      }
      moveChildren(targetParent, refNode) {
        this.children.forEach((child) => {
          targetParent.insertBefore(child, refNode);
        });
      }
      optimize(context) {
        if (super.optimize(context), this.enforceAllowedChildren(), this.uiNode != null && this.uiNode !== this.domNode.firstChild && this.domNode.insertBefore(this.uiNode, this.domNode.firstChild), this.children.length === 0)
          if (this.statics.defaultChild != null) {
            const child = this.scroll.create(this.statics.defaultChild.blotName);
            this.appendChild(child);
          } else
            this.remove();
      }
      path(index, inclusive = false) {
        const [child, offset] = this.children.find(index, inclusive), position = [[this, index]];
        return child instanceof _ParentBlot2 ? position.concat(child.path(offset, inclusive)) : (child != null && position.push([child, offset]), position);
      }
      removeChild(child) {
        this.children.remove(child);
      }
      replaceWith(name2, value2) {
        const replacement = typeof name2 == "string" ? this.scroll.create(name2, value2) : name2;
        return replacement instanceof _ParentBlot2 && this.moveChildren(replacement), super.replaceWith(replacement);
      }
      split(index, force = false) {
        if (!force) {
          if (index === 0)
            return this;
          if (index === this.length())
            return this.next;
        }
        const after = this.clone();
        return this.parent && this.parent.insertBefore(after, this.next || void 0), this.children.forEachAt(index, this.length(), (child, offset, _length) => {
          const split = child.split(offset, force);
          split != null && after.appendChild(split);
        }), after;
      }
      splitAfter(child) {
        const after = this.clone();
        for (; child.next != null; )
          after.appendChild(child.next);
        return this.parent && this.parent.insertBefore(after, this.next || void 0), after;
      }
      unwrap() {
        this.parent && this.moveChildren(this.parent, this.next || void 0), this.remove();
      }
      update(mutations, _context) {
        const addedNodes = [], removedNodes = [];
        mutations.forEach((mutation) => {
          mutation.target === this.domNode && mutation.type === "childList" && (addedNodes.push(...mutation.addedNodes), removedNodes.push(...mutation.removedNodes));
        }), removedNodes.forEach((node) => {
          if (node.parentNode != null && // @ts-expect-error Fix me later
          node.tagName !== "IFRAME" && document.body.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY)
            return;
          const blot = this.scroll.find(node);
          blot != null && (blot.domNode.parentNode == null || blot.domNode.parentNode === this.domNode) && blot.detach();
        }), addedNodes.filter((node) => node.parentNode === this.domNode && node !== this.uiNode).sort((a, b) => a === b ? 0 : a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING ? 1 : -1).forEach((node) => {
          let refBlot = null;
          node.nextSibling != null && (refBlot = this.scroll.find(node.nextSibling));
          const blot = makeAttachedBlot(node, this.scroll);
          (blot.next !== refBlot || blot.next == null) && (blot.parent != null && blot.parent.removeChild(this), this.insertBefore(blot, refBlot || void 0));
        }), this.enforceAllowedChildren();
      }
    };
    _ParentBlot.uiClass = "";
    let ParentBlot = _ParentBlot;
    const ParentBlot$1 = ParentBlot;
    function isEqual(obj1, obj2) {
      if (Object.keys(obj1).length !== Object.keys(obj2).length)
        return false;
      for (const prop in obj1)
        if (obj1[prop] !== obj2[prop])
          return false;
      return true;
    }
    const _InlineBlot = class _InlineBlot2 extends ParentBlot$1 {
      static create(value2) {
        return super.create(value2);
      }
      static formats(domNode, scroll) {
        const match2 = scroll.query(_InlineBlot2.blotName);
        if (!(match2 != null && domNode.tagName === match2.tagName)) {
          if (typeof this.tagName == "string")
            return true;
          if (Array.isArray(this.tagName))
            return domNode.tagName.toLowerCase();
        }
      }
      constructor(scroll, domNode) {
        super(scroll, domNode), this.attributes = new AttributorStore$1(this.domNode);
      }
      format(name2, value2) {
        if (name2 === this.statics.blotName && !value2)
          this.children.forEach((child) => {
            child instanceof _InlineBlot2 || (child = child.wrap(_InlineBlot2.blotName, true)), this.attributes.copy(child);
          }), this.unwrap();
        else {
          const format = this.scroll.query(name2, Scope.INLINE);
          if (format == null)
            return;
          format instanceof Attributor ? this.attributes.attribute(format, value2) : value2 && (name2 !== this.statics.blotName || this.formats()[name2] !== value2) && this.replaceWith(name2, value2);
        }
      }
      formats() {
        const formats = this.attributes.values(), format = this.statics.formats(this.domNode, this.scroll);
        return format != null && (formats[this.statics.blotName] = format), formats;
      }
      formatAt(index, length, name2, value2) {
        this.formats()[name2] != null || this.scroll.query(name2, Scope.ATTRIBUTE) ? this.isolate(index, length).format(name2, value2) : super.formatAt(index, length, name2, value2);
      }
      optimize(context) {
        super.optimize(context);
        const formats = this.formats();
        if (Object.keys(formats).length === 0)
          return this.unwrap();
        const next = this.next;
        next instanceof _InlineBlot2 && next.prev === this && isEqual(formats, next.formats()) && (next.moveChildren(this), next.remove());
      }
      replaceWith(name2, value2) {
        const replacement = super.replaceWith(name2, value2);
        return this.attributes.copy(replacement), replacement;
      }
      update(mutations, context) {
        super.update(mutations, context), mutations.some(
          (mutation) => mutation.target === this.domNode && mutation.type === "attributes"
        ) && this.attributes.build();
      }
      wrap(name2, value2) {
        const wrapper = super.wrap(name2, value2);
        return wrapper instanceof _InlineBlot2 && this.attributes.move(wrapper), wrapper;
      }
    };
    _InlineBlot.allowedChildren = [_InlineBlot, LeafBlot$1], _InlineBlot.blotName = "inline", _InlineBlot.scope = Scope.INLINE_BLOT, _InlineBlot.tagName = "SPAN";
    let InlineBlot = _InlineBlot;
    const InlineBlot$1 = InlineBlot, _BlockBlot = class _BlockBlot2 extends ParentBlot$1 {
      static create(value2) {
        return super.create(value2);
      }
      static formats(domNode, scroll) {
        const match2 = scroll.query(_BlockBlot2.blotName);
        if (!(match2 != null && domNode.tagName === match2.tagName)) {
          if (typeof this.tagName == "string")
            return true;
          if (Array.isArray(this.tagName))
            return domNode.tagName.toLowerCase();
        }
      }
      constructor(scroll, domNode) {
        super(scroll, domNode), this.attributes = new AttributorStore$1(this.domNode);
      }
      format(name2, value2) {
        const format = this.scroll.query(name2, Scope.BLOCK);
        format != null && (format instanceof Attributor ? this.attributes.attribute(format, value2) : name2 === this.statics.blotName && !value2 ? this.replaceWith(_BlockBlot2.blotName) : value2 && (name2 !== this.statics.blotName || this.formats()[name2] !== value2) && this.replaceWith(name2, value2));
      }
      formats() {
        const formats = this.attributes.values(), format = this.statics.formats(this.domNode, this.scroll);
        return format != null && (formats[this.statics.blotName] = format), formats;
      }
      formatAt(index, length, name2, value2) {
        this.scroll.query(name2, Scope.BLOCK) != null ? this.format(name2, value2) : super.formatAt(index, length, name2, value2);
      }
      insertAt(index, value2, def) {
        if (def == null || this.scroll.query(value2, Scope.INLINE) != null)
          super.insertAt(index, value2, def);
        else {
          const after = this.split(index);
          if (after != null) {
            const blot = this.scroll.create(value2, def);
            after.parent.insertBefore(blot, after);
          } else
            throw new Error("Attempt to insertAt after block boundaries");
        }
      }
      replaceWith(name2, value2) {
        const replacement = super.replaceWith(name2, value2);
        return this.attributes.copy(replacement), replacement;
      }
      update(mutations, context) {
        super.update(mutations, context), mutations.some(
          (mutation) => mutation.target === this.domNode && mutation.type === "attributes"
        ) && this.attributes.build();
      }
    };
    _BlockBlot.blotName = "block", _BlockBlot.scope = Scope.BLOCK_BLOT, _BlockBlot.tagName = "P", _BlockBlot.allowedChildren = [
      InlineBlot$1,
      _BlockBlot,
      LeafBlot$1
    ];
    let BlockBlot = _BlockBlot;
    const BlockBlot$1 = BlockBlot, _ContainerBlot = class _ContainerBlot extends ParentBlot$1 {
      checkMerge() {
        return this.next !== null && this.next.statics.blotName === this.statics.blotName;
      }
      deleteAt(index, length) {
        super.deleteAt(index, length), this.enforceAllowedChildren();
      }
      formatAt(index, length, name2, value2) {
        super.formatAt(index, length, name2, value2), this.enforceAllowedChildren();
      }
      insertAt(index, value2, def) {
        super.insertAt(index, value2, def), this.enforceAllowedChildren();
      }
      optimize(context) {
        super.optimize(context), this.children.length > 0 && this.next != null && this.checkMerge() && (this.next.moveChildren(this), this.next.remove());
      }
    };
    _ContainerBlot.blotName = "container", _ContainerBlot.scope = Scope.BLOCK_BLOT;
    let ContainerBlot = _ContainerBlot;
    const ContainerBlot$1 = ContainerBlot;
    class EmbedBlot extends LeafBlot$1 {
      static formats(_domNode, _scroll) {
      }
      format(name2, value2) {
        super.formatAt(0, this.length(), name2, value2);
      }
      formatAt(index, length, name2, value2) {
        index === 0 && length === this.length() ? this.format(name2, value2) : super.formatAt(index, length, name2, value2);
      }
      formats() {
        return this.statics.formats(this.domNode, this.scroll);
      }
    }
    const EmbedBlot$1 = EmbedBlot, OBSERVER_CONFIG = {
      attributes: true,
      characterData: true,
      characterDataOldValue: true,
      childList: true,
      subtree: true
    }, MAX_OPTIMIZE_ITERATIONS = 100, _ScrollBlot = class _ScrollBlot extends ParentBlot$1 {
      constructor(registry, node) {
        super(null, node), this.registry = registry, this.scroll = this, this.build(), this.observer = new MutationObserver((mutations) => {
          this.update(mutations);
        }), this.observer.observe(this.domNode, OBSERVER_CONFIG), this.attach();
      }
      create(input2, value2) {
        return this.registry.create(this, input2, value2);
      }
      find(node, bubble2 = false) {
        const blot = this.registry.find(node, bubble2);
        return blot ? blot.scroll === this ? blot : bubble2 ? this.find(blot.scroll.domNode.parentNode, true) : null : null;
      }
      query(query, scope = Scope.ANY) {
        return this.registry.query(query, scope);
      }
      register(...definitions) {
        return this.registry.register(...definitions);
      }
      build() {
        this.scroll != null && super.build();
      }
      detach() {
        super.detach(), this.observer.disconnect();
      }
      deleteAt(index, length) {
        this.update(), index === 0 && length === this.length() ? this.children.forEach((child) => {
          child.remove();
        }) : super.deleteAt(index, length);
      }
      formatAt(index, length, name2, value2) {
        this.update(), super.formatAt(index, length, name2, value2);
      }
      insertAt(index, value2, def) {
        this.update(), super.insertAt(index, value2, def);
      }
      optimize(mutations = [], context = {}) {
        super.optimize(context);
        const mutationsMap = context.mutationsMap || /* @__PURE__ */ new WeakMap();
        let records = Array.from(this.observer.takeRecords());
        for (; records.length > 0; )
          mutations.push(records.pop());
        const mark = (blot, markParent = true) => {
          blot == null || blot === this || blot.domNode.parentNode != null && (mutationsMap.has(blot.domNode) || mutationsMap.set(blot.domNode, []), markParent && mark(blot.parent));
        }, optimize = (blot) => {
          mutationsMap.has(blot.domNode) && (blot instanceof ParentBlot$1 && blot.children.forEach(optimize), mutationsMap.delete(blot.domNode), blot.optimize(context));
        };
        let remaining = mutations;
        for (let i = 0; remaining.length > 0; i += 1) {
          if (i >= MAX_OPTIMIZE_ITERATIONS)
            throw new Error("[Parchment] Maximum optimize iterations reached");
          for (remaining.forEach((mutation) => {
            const blot = this.find(mutation.target, true);
            blot != null && (blot.domNode === mutation.target && (mutation.type === "childList" ? (mark(this.find(mutation.previousSibling, false)), Array.from(mutation.addedNodes).forEach((node) => {
              const child = this.find(node, false);
              mark(child, false), child instanceof ParentBlot$1 && child.children.forEach((grandChild) => {
                mark(grandChild, false);
              });
            })) : mutation.type === "attributes" && mark(blot.prev)), mark(blot));
          }), this.children.forEach(optimize), remaining = Array.from(this.observer.takeRecords()), records = remaining.slice(); records.length > 0; )
            mutations.push(records.pop());
        }
      }
      update(mutations, context = {}) {
        mutations = mutations || this.observer.takeRecords();
        const mutationsMap = /* @__PURE__ */ new WeakMap();
        mutations.map((mutation) => {
          const blot = this.find(mutation.target, true);
          return blot == null ? null : mutationsMap.has(blot.domNode) ? (mutationsMap.get(blot.domNode).push(mutation), null) : (mutationsMap.set(blot.domNode, [mutation]), blot);
        }).forEach((blot) => {
          blot != null && blot !== this && mutationsMap.has(blot.domNode) && blot.update(mutationsMap.get(blot.domNode) || [], context);
        }), context.mutationsMap = mutationsMap, mutationsMap.has(this.domNode) && super.update(mutationsMap.get(this.domNode), context), this.optimize(mutations, context);
      }
    };
    _ScrollBlot.blotName = "scroll", _ScrollBlot.defaultChild = BlockBlot$1, _ScrollBlot.allowedChildren = [BlockBlot$1, ContainerBlot$1], _ScrollBlot.scope = Scope.BLOCK_BLOT, _ScrollBlot.tagName = "DIV";
    let ScrollBlot = _ScrollBlot;
    const ScrollBlot$1 = ScrollBlot, _TextBlot = class _TextBlot2 extends LeafBlot$1 {
      static create(value2) {
        return document.createTextNode(value2);
      }
      static value(domNode) {
        return domNode.data;
      }
      constructor(scroll, node) {
        super(scroll, node), this.text = this.statics.value(this.domNode);
      }
      deleteAt(index, length) {
        this.domNode.data = this.text = this.text.slice(0, index) + this.text.slice(index + length);
      }
      index(node, offset) {
        return this.domNode === node ? offset : -1;
      }
      insertAt(index, value2, def) {
        def == null ? (this.text = this.text.slice(0, index) + value2 + this.text.slice(index), this.domNode.data = this.text) : super.insertAt(index, value2, def);
      }
      length() {
        return this.text.length;
      }
      optimize(context) {
        super.optimize(context), this.text = this.statics.value(this.domNode), this.text.length === 0 ? this.remove() : this.next instanceof _TextBlot2 && this.next.prev === this && (this.insertAt(this.length(), this.next.value()), this.next.remove());
      }
      position(index, _inclusive = false) {
        return [this.domNode, index];
      }
      split(index, force = false) {
        if (!force) {
          if (index === 0)
            return this;
          if (index === this.length())
            return this.next;
        }
        const after = this.scroll.create(this.domNode.splitText(index));
        return this.parent.insertBefore(after, this.next || void 0), this.text = this.statics.value(this.domNode), after;
      }
      update(mutations, _context) {
        mutations.some((mutation) => mutation.type === "characterData" && mutation.target === this.domNode) && (this.text = this.statics.value(this.domNode));
      }
      value() {
        return this.text;
      }
    };
    _TextBlot.blotName = "text", _TextBlot.scope = Scope.INLINE_BLOT;
    let TextBlot = _TextBlot;
    const TextBlot$1 = TextBlot;
    const Parchment = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
      __proto__: null,
      Attributor,
      AttributorStore: AttributorStore$1,
      BlockBlot: BlockBlot$1,
      ClassAttributor: ClassAttributor$1,
      ContainerBlot: ContainerBlot$1,
      EmbedBlot: EmbedBlot$1,
      InlineBlot: InlineBlot$1,
      LeafBlot: LeafBlot$1,
      ParentBlot: ParentBlot$1,
      Registry,
      Scope,
      ScrollBlot: ScrollBlot$1,
      StyleAttributor: StyleAttributor$1,
      TextBlot: TextBlot$1
    }, Symbol.toStringTag, { value: "Module" }));
    var Delta$1 = { exports: {} };
    var diff_1;
    var hasRequiredDiff;
    function requireDiff() {
      if (hasRequiredDiff) return diff_1;
      hasRequiredDiff = 1;
      var DIFF_DELETE = -1;
      var DIFF_INSERT = 1;
      var DIFF_EQUAL = 0;
      function diff_main(text1, text2, cursor_pos, cleanup, _fix_unicode) {
        if (text1 === text2) {
          if (text1) {
            return [[DIFF_EQUAL, text1]];
          }
          return [];
        }
        if (cursor_pos != null) {
          var editdiff = find_cursor_edit_diff(text1, text2, cursor_pos);
          if (editdiff) {
            return editdiff;
          }
        }
        var commonlength = diff_commonPrefix(text1, text2);
        var commonprefix = text1.substring(0, commonlength);
        text1 = text1.substring(commonlength);
        text2 = text2.substring(commonlength);
        commonlength = diff_commonSuffix(text1, text2);
        var commonsuffix = text1.substring(text1.length - commonlength);
        text1 = text1.substring(0, text1.length - commonlength);
        text2 = text2.substring(0, text2.length - commonlength);
        var diffs = diff_compute_(text1, text2);
        if (commonprefix) {
          diffs.unshift([DIFF_EQUAL, commonprefix]);
        }
        if (commonsuffix) {
          diffs.push([DIFF_EQUAL, commonsuffix]);
        }
        diff_cleanupMerge(diffs, _fix_unicode);
        if (cleanup) {
          diff_cleanupSemantic(diffs);
        }
        return diffs;
      }
      function diff_compute_(text1, text2) {
        var diffs;
        if (!text1) {
          return [[DIFF_INSERT, text2]];
        }
        if (!text2) {
          return [[DIFF_DELETE, text1]];
        }
        var longtext = text1.length > text2.length ? text1 : text2;
        var shorttext = text1.length > text2.length ? text2 : text1;
        var i = longtext.indexOf(shorttext);
        if (i !== -1) {
          diffs = [
            [DIFF_INSERT, longtext.substring(0, i)],
            [DIFF_EQUAL, shorttext],
            [DIFF_INSERT, longtext.substring(i + shorttext.length)]
          ];
          if (text1.length > text2.length) {
            diffs[0][0] = diffs[2][0] = DIFF_DELETE;
          }
          return diffs;
        }
        if (shorttext.length === 1) {
          return [
            [DIFF_DELETE, text1],
            [DIFF_INSERT, text2]
          ];
        }
        var hm = diff_halfMatch_(text1, text2);
        if (hm) {
          var text1_a = hm[0];
          var text1_b = hm[1];
          var text2_a = hm[2];
          var text2_b = hm[3];
          var mid_common = hm[4];
          var diffs_a = diff_main(text1_a, text2_a);
          var diffs_b = diff_main(text1_b, text2_b);
          return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
        }
        return diff_bisect_(text1, text2);
      }
      function diff_bisect_(text1, text2) {
        var text1_length = text1.length;
        var text2_length = text2.length;
        var max_d = Math.ceil((text1_length + text2_length) / 2);
        var v_offset = max_d;
        var v_length = 2 * max_d;
        var v1 = new Array(v_length);
        var v2 = new Array(v_length);
        for (var x = 0; x < v_length; x++) {
          v1[x] = -1;
          v2[x] = -1;
        }
        v1[v_offset + 1] = 0;
        v2[v_offset + 1] = 0;
        var delta = text1_length - text2_length;
        var front = delta % 2 !== 0;
        var k1start = 0;
        var k1end = 0;
        var k2start = 0;
        var k2end = 0;
        for (var d = 0; d < max_d; d++) {
          for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
            var k1_offset = v_offset + k1;
            var x1;
            if (k1 === -d || k1 !== d && v1[k1_offset - 1] < v1[k1_offset + 1]) {
              x1 = v1[k1_offset + 1];
            } else {
              x1 = v1[k1_offset - 1] + 1;
            }
            var y1 = x1 - k1;
            while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) === text2.charAt(y1)) {
              x1++;
              y1++;
            }
            v1[k1_offset] = x1;
            if (x1 > text1_length) {
              k1end += 2;
            } else if (y1 > text2_length) {
              k1start += 2;
            } else if (front) {
              var k2_offset = v_offset + delta - k1;
              if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] !== -1) {
                var x2 = text1_length - v2[k2_offset];
                if (x1 >= x2) {
                  return diff_bisectSplit_(text1, text2, x1, y1);
                }
              }
            }
          }
          for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
            var k2_offset = v_offset + k2;
            var x2;
            if (k2 === -d || k2 !== d && v2[k2_offset - 1] < v2[k2_offset + 1]) {
              x2 = v2[k2_offset + 1];
            } else {
              x2 = v2[k2_offset - 1] + 1;
            }
            var y2 = x2 - k2;
            while (x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) === text2.charAt(text2_length - y2 - 1)) {
              x2++;
              y2++;
            }
            v2[k2_offset] = x2;
            if (x2 > text1_length) {
              k2end += 2;
            } else if (y2 > text2_length) {
              k2start += 2;
            } else if (!front) {
              var k1_offset = v_offset + delta - k2;
              if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] !== -1) {
                var x1 = v1[k1_offset];
                var y1 = v_offset + x1 - k1_offset;
                x2 = text1_length - x2;
                if (x1 >= x2) {
                  return diff_bisectSplit_(text1, text2, x1, y1);
                }
              }
            }
          }
        }
        return [
          [DIFF_DELETE, text1],
          [DIFF_INSERT, text2]
        ];
      }
      function diff_bisectSplit_(text1, text2, x, y) {
        var text1a = text1.substring(0, x);
        var text2a = text2.substring(0, y);
        var text1b = text1.substring(x);
        var text2b = text2.substring(y);
        var diffs = diff_main(text1a, text2a);
        var diffsb = diff_main(text1b, text2b);
        return diffs.concat(diffsb);
      }
      function diff_commonPrefix(text1, text2) {
        if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {
          return 0;
        }
        var pointermin = 0;
        var pointermax = Math.min(text1.length, text2.length);
        var pointermid = pointermax;
        var pointerstart = 0;
        while (pointermin < pointermid) {
          if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
            pointermin = pointermid;
            pointerstart = pointermin;
          } else {
            pointermax = pointermid;
          }
          pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
        }
        if (is_surrogate_pair_start(text1.charCodeAt(pointermid - 1))) {
          pointermid--;
        }
        return pointermid;
      }
      function diff_commonOverlap_(text1, text2) {
        var text1_length = text1.length;
        var text2_length = text2.length;
        if (text1_length == 0 || text2_length == 0) {
          return 0;
        }
        if (text1_length > text2_length) {
          text1 = text1.substring(text1_length - text2_length);
        } else if (text1_length < text2_length) {
          text2 = text2.substring(0, text1_length);
        }
        var text_length = Math.min(text1_length, text2_length);
        if (text1 == text2) {
          return text_length;
        }
        var best = 0;
        var length = 1;
        while (true) {
          var pattern2 = text1.substring(text_length - length);
          var found = text2.indexOf(pattern2);
          if (found == -1) {
            return best;
          }
          length += found;
          if (found == 0 || text1.substring(text_length - length) == text2.substring(0, length)) {
            best = length;
            length++;
          }
        }
      }
      function diff_commonSuffix(text1, text2) {
        if (!text1 || !text2 || text1.slice(-1) !== text2.slice(-1)) {
          return 0;
        }
        var pointermin = 0;
        var pointermax = Math.min(text1.length, text2.length);
        var pointermid = pointermax;
        var pointerend = 0;
        while (pointermin < pointermid) {
          if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
            pointermin = pointermid;
            pointerend = pointermin;
          } else {
            pointermax = pointermid;
          }
          pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
        }
        if (is_surrogate_pair_end(text1.charCodeAt(text1.length - pointermid))) {
          pointermid--;
        }
        return pointermid;
      }
      function diff_halfMatch_(text1, text2) {
        var longtext = text1.length > text2.length ? text1 : text2;
        var shorttext = text1.length > text2.length ? text2 : text1;
        if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
          return null;
        }
        function diff_halfMatchI_(longtext2, shorttext2, i) {
          var seed = longtext2.substring(i, i + Math.floor(longtext2.length / 4));
          var j = -1;
          var best_common = "";
          var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
          while ((j = shorttext2.indexOf(seed, j + 1)) !== -1) {
            var prefixLength = diff_commonPrefix(
              longtext2.substring(i),
              shorttext2.substring(j)
            );
            var suffixLength = diff_commonSuffix(
              longtext2.substring(0, i),
              shorttext2.substring(0, j)
            );
            if (best_common.length < suffixLength + prefixLength) {
              best_common = shorttext2.substring(j - suffixLength, j) + shorttext2.substring(j, j + prefixLength);
              best_longtext_a = longtext2.substring(0, i - suffixLength);
              best_longtext_b = longtext2.substring(i + prefixLength);
              best_shorttext_a = shorttext2.substring(0, j - suffixLength);
              best_shorttext_b = shorttext2.substring(j + prefixLength);
            }
          }
          if (best_common.length * 2 >= longtext2.length) {
            return [
              best_longtext_a,
              best_longtext_b,
              best_shorttext_a,
              best_shorttext_b,
              best_common
            ];
          } else {
            return null;
          }
        }
        var hm1 = diff_halfMatchI_(
          longtext,
          shorttext,
          Math.ceil(longtext.length / 4)
        );
        var hm2 = diff_halfMatchI_(
          longtext,
          shorttext,
          Math.ceil(longtext.length / 2)
        );
        var hm;
        if (!hm1 && !hm2) {
          return null;
        } else if (!hm2) {
          hm = hm1;
        } else if (!hm1) {
          hm = hm2;
        } else {
          hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
        }
        var text1_a, text1_b, text2_a, text2_b;
        if (text1.length > text2.length) {
          text1_a = hm[0];
          text1_b = hm[1];
          text2_a = hm[2];
          text2_b = hm[3];
        } else {
          text2_a = hm[0];
          text2_b = hm[1];
          text1_a = hm[2];
          text1_b = hm[3];
        }
        var mid_common = hm[4];
        return [text1_a, text1_b, text2_a, text2_b, mid_common];
      }
      function diff_cleanupSemantic(diffs) {
        var changes = false;
        var equalities = [];
        var equalitiesLength = 0;
        var lastequality = null;
        var pointer = 0;
        var length_insertions1 = 0;
        var length_deletions1 = 0;
        var length_insertions2 = 0;
        var length_deletions2 = 0;
        while (pointer < diffs.length) {
          if (diffs[pointer][0] == DIFF_EQUAL) {
            equalities[equalitiesLength++] = pointer;
            length_insertions1 = length_insertions2;
            length_deletions1 = length_deletions2;
            length_insertions2 = 0;
            length_deletions2 = 0;
            lastequality = diffs[pointer][1];
          } else {
            if (diffs[pointer][0] == DIFF_INSERT) {
              length_insertions2 += diffs[pointer][1].length;
            } else {
              length_deletions2 += diffs[pointer][1].length;
            }
            if (lastequality && lastequality.length <= Math.max(length_insertions1, length_deletions1) && lastequality.length <= Math.max(length_insertions2, length_deletions2)) {
              diffs.splice(equalities[equalitiesLength - 1], 0, [
                DIFF_DELETE,
                lastequality
              ]);
              diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
              equalitiesLength--;
              equalitiesLength--;
              pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
              length_insertions1 = 0;
              length_deletions1 = 0;
              length_insertions2 = 0;
              length_deletions2 = 0;
              lastequality = null;
              changes = true;
            }
          }
          pointer++;
        }
        if (changes) {
          diff_cleanupMerge(diffs);
        }
        diff_cleanupSemanticLossless(diffs);
        pointer = 1;
        while (pointer < diffs.length) {
          if (diffs[pointer - 1][0] == DIFF_DELETE && diffs[pointer][0] == DIFF_INSERT) {
            var deletion = diffs[pointer - 1][1];
            var insertion = diffs[pointer][1];
            var overlap_length1 = diff_commonOverlap_(deletion, insertion);
            var overlap_length2 = diff_commonOverlap_(insertion, deletion);
            if (overlap_length1 >= overlap_length2) {
              if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {
                diffs.splice(pointer, 0, [
                  DIFF_EQUAL,
                  insertion.substring(0, overlap_length1)
                ]);
                diffs[pointer - 1][1] = deletion.substring(
                  0,
                  deletion.length - overlap_length1
                );
                diffs[pointer + 1][1] = insertion.substring(overlap_length1);
                pointer++;
              }
            } else {
              if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {
                diffs.splice(pointer, 0, [
                  DIFF_EQUAL,
                  deletion.substring(0, overlap_length2)
                ]);
                diffs[pointer - 1][0] = DIFF_INSERT;
                diffs[pointer - 1][1] = insertion.substring(
                  0,
                  insertion.length - overlap_length2
                );
                diffs[pointer + 1][0] = DIFF_DELETE;
                diffs[pointer + 1][1] = deletion.substring(overlap_length2);
                pointer++;
              }
            }
            pointer++;
          }
          pointer++;
        }
      }
      var nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
      var whitespaceRegex_ = /\s/;
      var linebreakRegex_ = /[\r\n]/;
      var blanklineEndRegex_ = /\n\r?\n$/;
      var blanklineStartRegex_ = /^\r?\n\r?\n/;
      function diff_cleanupSemanticLossless(diffs) {
        function diff_cleanupSemanticScore_(one, two) {
          if (!one || !two) {
            return 6;
          }
          var char1 = one.charAt(one.length - 1);
          var char2 = two.charAt(0);
          var nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_);
          var nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_);
          var whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_);
          var whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_);
          var lineBreak1 = whitespace1 && char1.match(linebreakRegex_);
          var lineBreak2 = whitespace2 && char2.match(linebreakRegex_);
          var blankLine1 = lineBreak1 && one.match(blanklineEndRegex_);
          var blankLine2 = lineBreak2 && two.match(blanklineStartRegex_);
          if (blankLine1 || blankLine2) {
            return 5;
          } else if (lineBreak1 || lineBreak2) {
            return 4;
          } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
            return 3;
          } else if (whitespace1 || whitespace2) {
            return 2;
          } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
            return 1;
          }
          return 0;
        }
        var pointer = 1;
        while (pointer < diffs.length - 1) {
          if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
            var equality1 = diffs[pointer - 1][1];
            var edit = diffs[pointer][1];
            var equality2 = diffs[pointer + 1][1];
            var commonOffset = diff_commonSuffix(equality1, edit);
            if (commonOffset) {
              var commonString = edit.substring(edit.length - commonOffset);
              equality1 = equality1.substring(0, equality1.length - commonOffset);
              edit = commonString + edit.substring(0, edit.length - commonOffset);
              equality2 = commonString + equality2;
            }
            var bestEquality1 = equality1;
            var bestEdit = edit;
            var bestEquality2 = equality2;
            var bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
            while (edit.charAt(0) === equality2.charAt(0)) {
              equality1 += edit.charAt(0);
              edit = edit.substring(1) + equality2.charAt(0);
              equality2 = equality2.substring(1);
              var score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
              if (score >= bestScore) {
                bestScore = score;
                bestEquality1 = equality1;
                bestEdit = edit;
                bestEquality2 = equality2;
              }
            }
            if (diffs[pointer - 1][1] != bestEquality1) {
              if (bestEquality1) {
                diffs[pointer - 1][1] = bestEquality1;
              } else {
                diffs.splice(pointer - 1, 1);
                pointer--;
              }
              diffs[pointer][1] = bestEdit;
              if (bestEquality2) {
                diffs[pointer + 1][1] = bestEquality2;
              } else {
                diffs.splice(pointer + 1, 1);
                pointer--;
              }
            }
          }
          pointer++;
        }
      }
      function diff_cleanupMerge(diffs, fix_unicode) {
        diffs.push([DIFF_EQUAL, ""]);
        var pointer = 0;
        var count_delete = 0;
        var count_insert = 0;
        var text_delete = "";
        var text_insert = "";
        var commonlength;
        while (pointer < diffs.length) {
          if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
            diffs.splice(pointer, 1);
            continue;
          }
          switch (diffs[pointer][0]) {
            case DIFF_INSERT:
              count_insert++;
              text_insert += diffs[pointer][1];
              pointer++;
              break;
            case DIFF_DELETE:
              count_delete++;
              text_delete += diffs[pointer][1];
              pointer++;
              break;
            case DIFF_EQUAL:
              var previous_equality = pointer - count_insert - count_delete - 1;
              if (fix_unicode) {
                if (previous_equality >= 0 && ends_with_pair_start(diffs[previous_equality][1])) {
                  var stray = diffs[previous_equality][1].slice(-1);
                  diffs[previous_equality][1] = diffs[previous_equality][1].slice(
                    0,
                    -1
                  );
                  text_delete = stray + text_delete;
                  text_insert = stray + text_insert;
                  if (!diffs[previous_equality][1]) {
                    diffs.splice(previous_equality, 1);
                    pointer--;
                    var k = previous_equality - 1;
                    if (diffs[k] && diffs[k][0] === DIFF_INSERT) {
                      count_insert++;
                      text_insert = diffs[k][1] + text_insert;
                      k--;
                    }
                    if (diffs[k] && diffs[k][0] === DIFF_DELETE) {
                      count_delete++;
                      text_delete = diffs[k][1] + text_delete;
                      k--;
                    }
                    previous_equality = k;
                  }
                }
                if (starts_with_pair_end(diffs[pointer][1])) {
                  var stray = diffs[pointer][1].charAt(0);
                  diffs[pointer][1] = diffs[pointer][1].slice(1);
                  text_delete += stray;
                  text_insert += stray;
                }
              }
              if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
                diffs.splice(pointer, 1);
                break;
              }
              if (text_delete.length > 0 || text_insert.length > 0) {
                if (text_delete.length > 0 && text_insert.length > 0) {
                  commonlength = diff_commonPrefix(text_insert, text_delete);
                  if (commonlength !== 0) {
                    if (previous_equality >= 0) {
                      diffs[previous_equality][1] += text_insert.substring(
                        0,
                        commonlength
                      );
                    } else {
                      diffs.splice(0, 0, [
                        DIFF_EQUAL,
                        text_insert.substring(0, commonlength)
                      ]);
                      pointer++;
                    }
                    text_insert = text_insert.substring(commonlength);
                    text_delete = text_delete.substring(commonlength);
                  }
                  commonlength = diff_commonSuffix(text_insert, text_delete);
                  if (commonlength !== 0) {
                    diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                    text_insert = text_insert.substring(
                      0,
                      text_insert.length - commonlength
                    );
                    text_delete = text_delete.substring(
                      0,
                      text_delete.length - commonlength
                    );
                  }
                }
                var n = count_insert + count_delete;
                if (text_delete.length === 0 && text_insert.length === 0) {
                  diffs.splice(pointer - n, n);
                  pointer = pointer - n;
                } else if (text_delete.length === 0) {
                  diffs.splice(pointer - n, n, [DIFF_INSERT, text_insert]);
                  pointer = pointer - n + 1;
                } else if (text_insert.length === 0) {
                  diffs.splice(pointer - n, n, [DIFF_DELETE, text_delete]);
                  pointer = pointer - n + 1;
                } else {
                  diffs.splice(
                    pointer - n,
                    n,
                    [DIFF_DELETE, text_delete],
                    [DIFF_INSERT, text_insert]
                  );
                  pointer = pointer - n + 2;
                }
              }
              if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {
                diffs[pointer - 1][1] += diffs[pointer][1];
                diffs.splice(pointer, 1);
              } else {
                pointer++;
              }
              count_insert = 0;
              count_delete = 0;
              text_delete = "";
              text_insert = "";
              break;
          }
        }
        if (diffs[diffs.length - 1][1] === "") {
          diffs.pop();
        }
        var changes = false;
        pointer = 1;
        while (pointer < diffs.length - 1) {
          if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
            if (diffs[pointer][1].substring(
              diffs[pointer][1].length - diffs[pointer - 1][1].length
            ) === diffs[pointer - 1][1]) {
              diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(
                0,
                diffs[pointer][1].length - diffs[pointer - 1][1].length
              );
              diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
              diffs.splice(pointer - 1, 1);
              changes = true;
            } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
              diffs[pointer - 1][1] += diffs[pointer + 1][1];
              diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
              diffs.splice(pointer + 1, 1);
              changes = true;
            }
          }
          pointer++;
        }
        if (changes) {
          diff_cleanupMerge(diffs, fix_unicode);
        }
      }
      function is_surrogate_pair_start(charCode) {
        return charCode >= 55296 && charCode <= 56319;
      }
      function is_surrogate_pair_end(charCode) {
        return charCode >= 56320 && charCode <= 57343;
      }
      function starts_with_pair_end(str) {
        return is_surrogate_pair_end(str.charCodeAt(0));
      }
      function ends_with_pair_start(str) {
        return is_surrogate_pair_start(str.charCodeAt(str.length - 1));
      }
      function remove_empty_tuples(tuples) {
        var ret = [];
        for (var i = 0; i < tuples.length; i++) {
          if (tuples[i][1].length > 0) {
            ret.push(tuples[i]);
          }
        }
        return ret;
      }
      function make_edit_splice(before, oldMiddle, newMiddle, after) {
        if (ends_with_pair_start(before) || starts_with_pair_end(after)) {
          return null;
        }
        return remove_empty_tuples([
          [DIFF_EQUAL, before],
          [DIFF_DELETE, oldMiddle],
          [DIFF_INSERT, newMiddle],
          [DIFF_EQUAL, after]
        ]);
      }
      function find_cursor_edit_diff(oldText, newText, cursor_pos) {
        var oldRange = typeof cursor_pos === "number" ? { index: cursor_pos, length: 0 } : cursor_pos.oldRange;
        var newRange = typeof cursor_pos === "number" ? null : cursor_pos.newRange;
        var oldLength = oldText.length;
        var newLength = newText.length;
        if (oldRange.length === 0 && (newRange === null || newRange.length === 0)) {
          var oldCursor = oldRange.index;
          var oldBefore = oldText.slice(0, oldCursor);
          var oldAfter = oldText.slice(oldCursor);
          var maybeNewCursor = newRange ? newRange.index : null;
          editBefore: {
            var newCursor = oldCursor + newLength - oldLength;
            if (maybeNewCursor !== null && maybeNewCursor !== newCursor) {
              break editBefore;
            }
            if (newCursor < 0 || newCursor > newLength) {
              break editBefore;
            }
            var newBefore = newText.slice(0, newCursor);
            var newAfter = newText.slice(newCursor);
            if (newAfter !== oldAfter) {
              break editBefore;
            }
            var prefixLength = Math.min(oldCursor, newCursor);
            var oldPrefix = oldBefore.slice(0, prefixLength);
            var newPrefix = newBefore.slice(0, prefixLength);
            if (oldPrefix !== newPrefix) {
              break editBefore;
            }
            var oldMiddle = oldBefore.slice(prefixLength);
            var newMiddle = newBefore.slice(prefixLength);
            return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldAfter);
          }
          editAfter: {
            if (maybeNewCursor !== null && maybeNewCursor !== oldCursor) {
              break editAfter;
            }
            var cursor = oldCursor;
            var newBefore = newText.slice(0, cursor);
            var newAfter = newText.slice(cursor);
            if (newBefore !== oldBefore) {
              break editAfter;
            }
            var suffixLength = Math.min(oldLength - cursor, newLength - cursor);
            var oldSuffix = oldAfter.slice(oldAfter.length - suffixLength);
            var newSuffix = newAfter.slice(newAfter.length - suffixLength);
            if (oldSuffix !== newSuffix) {
              break editAfter;
            }
            var oldMiddle = oldAfter.slice(0, oldAfter.length - suffixLength);
            var newMiddle = newAfter.slice(0, newAfter.length - suffixLength);
            return make_edit_splice(oldBefore, oldMiddle, newMiddle, oldSuffix);
          }
        }
        if (oldRange.length > 0 && newRange && newRange.length === 0) {
          replaceRange: {
            var oldPrefix = oldText.slice(0, oldRange.index);
            var oldSuffix = oldText.slice(oldRange.index + oldRange.length);
            var prefixLength = oldPrefix.length;
            var suffixLength = oldSuffix.length;
            if (newLength < prefixLength + suffixLength) {
              break replaceRange;
            }
            var newPrefix = newText.slice(0, prefixLength);
            var newSuffix = newText.slice(newLength - suffixLength);
            if (oldPrefix !== newPrefix || oldSuffix !== newSuffix) {
              break replaceRange;
            }
            var oldMiddle = oldText.slice(prefixLength, oldLength - suffixLength);
            var newMiddle = newText.slice(prefixLength, newLength - suffixLength);
            return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldSuffix);
          }
        }
        return null;
      }
      function diff(text1, text2, cursor_pos, cleanup) {
        return diff_main(text1, text2, cursor_pos, cleanup, true);
      }
      diff.INSERT = DIFF_INSERT;
      diff.DELETE = DIFF_DELETE;
      diff.EQUAL = DIFF_EQUAL;
      diff_1 = diff;
      return diff_1;
    }
    var lodash_clonedeep = { exports: {} };
    lodash_clonedeep.exports;
    var hasRequiredLodash_clonedeep;
    function requireLodash_clonedeep() {
      if (hasRequiredLodash_clonedeep) return lodash_clonedeep.exports;
      hasRequiredLodash_clonedeep = 1;
      (function(module2, exports2) {
        var LARGE_ARRAY_SIZE2 = 200;
        var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
        var MAX_SAFE_INTEGER2 = 9007199254740991;
        var argsTag2 = "[object Arguments]", arrayTag2 = "[object Array]", boolTag2 = "[object Boolean]", dateTag2 = "[object Date]", errorTag2 = "[object Error]", funcTag2 = "[object Function]", genTag2 = "[object GeneratorFunction]", mapTag2 = "[object Map]", numberTag2 = "[object Number]", objectTag2 = "[object Object]", promiseTag2 = "[object Promise]", regexpTag2 = "[object RegExp]", setTag2 = "[object Set]", stringTag2 = "[object String]", symbolTag2 = "[object Symbol]", weakMapTag2 = "[object WeakMap]";
        var arrayBufferTag2 = "[object ArrayBuffer]", dataViewTag2 = "[object DataView]", float32Tag2 = "[object Float32Array]", float64Tag2 = "[object Float64Array]", int8Tag2 = "[object Int8Array]", int16Tag2 = "[object Int16Array]", int32Tag2 = "[object Int32Array]", uint8Tag2 = "[object Uint8Array]", uint8ClampedTag2 = "[object Uint8ClampedArray]", uint16Tag2 = "[object Uint16Array]", uint32Tag2 = "[object Uint32Array]";
        var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
        var reFlags2 = /\w*$/;
        var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
        var reIsUint2 = /^(?:0|[1-9]\d*)$/;
        var cloneableTags2 = {};
        cloneableTags2[argsTag2] = cloneableTags2[arrayTag2] = cloneableTags2[arrayBufferTag2] = cloneableTags2[dataViewTag2] = cloneableTags2[boolTag2] = cloneableTags2[dateTag2] = cloneableTags2[float32Tag2] = cloneableTags2[float64Tag2] = cloneableTags2[int8Tag2] = cloneableTags2[int16Tag2] = cloneableTags2[int32Tag2] = cloneableTags2[mapTag2] = cloneableTags2[numberTag2] = cloneableTags2[objectTag2] = cloneableTags2[regexpTag2] = cloneableTags2[setTag2] = cloneableTags2[stringTag2] = cloneableTags2[symbolTag2] = cloneableTags2[uint8Tag2] = cloneableTags2[uint8ClampedTag2] = cloneableTags2[uint16Tag2] = cloneableTags2[uint32Tag2] = true;
        cloneableTags2[errorTag2] = cloneableTags2[funcTag2] = cloneableTags2[weakMapTag2] = false;
        var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
        var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
        var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
        var freeExports2 = exports2 && !exports2.nodeType && exports2;
        var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
        var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
        function addMapEntry(map2, pair) {
          map2.set(pair[0], pair[1]);
          return map2;
        }
        function addSetEntry(set, value2) {
          set.add(value2);
          return set;
        }
        function arrayEach2(array, iteratee) {
          var index = -1, length = array ? array.length : 0;
          while (++index < length) {
            if (iteratee(array[index], index, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayPush2(array, values) {
          var index = -1, length = values.length, offset = array.length;
          while (++index < length) {
            array[offset + index] = values[index];
          }
          return array;
        }
        function arrayReduce(array, iteratee, accumulator, initAccum) {
          var index = -1, length = array ? array.length : 0;
          while (++index < length) {
            accumulator = iteratee(accumulator, array[index], index, array);
          }
          return accumulator;
        }
        function baseTimes2(n, iteratee) {
          var index = -1, result = Array(n);
          while (++index < n) {
            result[index] = iteratee(index);
          }
          return result;
        }
        function getValue2(object, key) {
          return object == null ? void 0 : object[key];
        }
        function isHostObject(value2) {
          var result = false;
          if (value2 != null && typeof value2.toString != "function") {
            try {
              result = !!(value2 + "");
            } catch (e) {
            }
          }
          return result;
        }
        function mapToArray2(map2) {
          var index = -1, result = Array(map2.size);
          map2.forEach(function(value2, key) {
            result[++index] = [key, value2];
          });
          return result;
        }
        function overArg2(func, transform) {
          return function(arg) {
            return func(transform(arg));
          };
        }
        function setToArray2(set) {
          var index = -1, result = Array(set.size);
          set.forEach(function(value2) {
            result[++index] = value2;
          });
          return result;
        }
        var arrayProto2 = Array.prototype, funcProto2 = Function.prototype, objectProto2 = Object.prototype;
        var coreJsData2 = root2["__core-js_shared__"];
        var maskSrcKey2 = function() {
          var uid = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var funcToString2 = funcProto2.toString;
        var hasOwnProperty2 = objectProto2.hasOwnProperty;
        var objectToString2 = objectProto2.toString;
        var reIsNative2 = RegExp(
          "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer3 = moduleExports2 ? root2.Buffer : void 0, Symbol2 = root2.Symbol, Uint8Array3 = root2.Uint8Array, getPrototype2 = overArg2(Object.getPrototypeOf, Object), objectCreate2 = Object.create, propertyIsEnumerable2 = objectProto2.propertyIsEnumerable, splice2 = arrayProto2.splice;
        var nativeGetSymbols2 = Object.getOwnPropertySymbols, nativeIsBuffer2 = Buffer3 ? Buffer3.isBuffer : void 0, nativeKeys2 = overArg2(Object.keys, Object);
        var DataView2 = getNative2(root2, "DataView"), Map2 = getNative2(root2, "Map"), Promise2 = getNative2(root2, "Promise"), Set2 = getNative2(root2, "Set"), WeakMap2 = getNative2(root2, "WeakMap"), nativeCreate2 = getNative2(Object, "create");
        var dataViewCtorString2 = toSource2(DataView2), mapCtorString2 = toSource2(Map2), promiseCtorString2 = toSource2(Promise2), setCtorString2 = toSource2(Set2), weakMapCtorString2 = toSource2(WeakMap2);
        var symbolProto2 = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf2 = symbolProto2 ? symbolProto2.valueOf : void 0;
        function Hash2(entries) {
          var index = -1, length = entries ? entries.length : 0;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear2() {
          this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
        }
        function hashDelete2(key) {
          return this.has(key) && delete this.__data__[key];
        }
        function hashGet2(key) {
          var data = this.__data__;
          if (nativeCreate2) {
            var result = data[key];
            return result === HASH_UNDEFINED2 ? void 0 : result;
          }
          return hasOwnProperty2.call(data, key) ? data[key] : void 0;
        }
        function hashHas2(key) {
          var data = this.__data__;
          return nativeCreate2 ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
        }
        function hashSet2(key, value2) {
          var data = this.__data__;
          data[key] = nativeCreate2 && value2 === void 0 ? HASH_UNDEFINED2 : value2;
          return this;
        }
        Hash2.prototype.clear = hashClear2;
        Hash2.prototype["delete"] = hashDelete2;
        Hash2.prototype.get = hashGet2;
        Hash2.prototype.has = hashHas2;
        Hash2.prototype.set = hashSet2;
        function ListCache2(entries) {
          var index = -1, length = entries ? entries.length : 0;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear2() {
          this.__data__ = [];
        }
        function listCacheDelete2(key) {
          var data = this.__data__, index = assocIndexOf2(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice2.call(data, index, 1);
          }
          return true;
        }
        function listCacheGet2(key) {
          var data = this.__data__, index = assocIndexOf2(data, key);
          return index < 0 ? void 0 : data[index][1];
        }
        function listCacheHas2(key) {
          return assocIndexOf2(this.__data__, key) > -1;
        }
        function listCacheSet2(key, value2) {
          var data = this.__data__, index = assocIndexOf2(data, key);
          if (index < 0) {
            data.push([key, value2]);
          } else {
            data[index][1] = value2;
          }
          return this;
        }
        ListCache2.prototype.clear = listCacheClear2;
        ListCache2.prototype["delete"] = listCacheDelete2;
        ListCache2.prototype.get = listCacheGet2;
        ListCache2.prototype.has = listCacheHas2;
        ListCache2.prototype.set = listCacheSet2;
        function MapCache2(entries) {
          var index = -1, length = entries ? entries.length : 0;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear2() {
          this.__data__ = {
            "hash": new Hash2(),
            "map": new (Map2 || ListCache2)(),
            "string": new Hash2()
          };
        }
        function mapCacheDelete2(key) {
          return getMapData2(this, key)["delete"](key);
        }
        function mapCacheGet2(key) {
          return getMapData2(this, key).get(key);
        }
        function mapCacheHas2(key) {
          return getMapData2(this, key).has(key);
        }
        function mapCacheSet2(key, value2) {
          getMapData2(this, key).set(key, value2);
          return this;
        }
        MapCache2.prototype.clear = mapCacheClear2;
        MapCache2.prototype["delete"] = mapCacheDelete2;
        MapCache2.prototype.get = mapCacheGet2;
        MapCache2.prototype.has = mapCacheHas2;
        MapCache2.prototype.set = mapCacheSet2;
        function Stack2(entries) {
          this.__data__ = new ListCache2(entries);
        }
        function stackClear2() {
          this.__data__ = new ListCache2();
        }
        function stackDelete2(key) {
          return this.__data__["delete"](key);
        }
        function stackGet2(key) {
          return this.__data__.get(key);
        }
        function stackHas2(key) {
          return this.__data__.has(key);
        }
        function stackSet2(key, value2) {
          var cache = this.__data__;
          if (cache instanceof ListCache2) {
            var pairs = cache.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE2 - 1) {
              pairs.push([key, value2]);
              return this;
            }
            cache = this.__data__ = new MapCache2(pairs);
          }
          cache.set(key, value2);
          return this;
        }
        Stack2.prototype.clear = stackClear2;
        Stack2.prototype["delete"] = stackDelete2;
        Stack2.prototype.get = stackGet2;
        Stack2.prototype.has = stackHas2;
        Stack2.prototype.set = stackSet2;
        function arrayLikeKeys2(value2, inherited) {
          var result = isArray2(value2) || isArguments2(value2) ? baseTimes2(value2.length, String) : [];
          var length = result.length, skipIndexes = !!length;
          for (var key in value2) {
            if (hasOwnProperty2.call(value2, key) && !(skipIndexes && (key == "length" || isIndex2(key, length)))) {
              result.push(key);
            }
          }
          return result;
        }
        function assignValue2(object, key, value2) {
          var objValue = object[key];
          if (!(hasOwnProperty2.call(object, key) && eq2(objValue, value2)) || value2 === void 0 && !(key in object)) {
            object[key] = value2;
          }
        }
        function assocIndexOf2(array, key) {
          var length = array.length;
          while (length--) {
            if (eq2(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAssign2(object, source) {
          return object && copyObject2(source, keys2(source), object);
        }
        function baseClone2(value2, isDeep, isFull, customizer, key, object, stack) {
          var result;
          if (customizer) {
            result = object ? customizer(value2, key, object, stack) : customizer(value2);
          }
          if (result !== void 0) {
            return result;
          }
          if (!isObject2(value2)) {
            return value2;
          }
          var isArr = isArray2(value2);
          if (isArr) {
            result = initCloneArray2(value2);
            if (!isDeep) {
              return copyArray2(value2, result);
            }
          } else {
            var tag = getTag2(value2), isFunc = tag == funcTag2 || tag == genTag2;
            if (isBuffer2(value2)) {
              return cloneBuffer2(value2, isDeep);
            }
            if (tag == objectTag2 || tag == argsTag2 || isFunc && !object) {
              if (isHostObject(value2)) {
                return object ? value2 : {};
              }
              result = initCloneObject2(isFunc ? {} : value2);
              if (!isDeep) {
                return copySymbols2(value2, baseAssign2(result, value2));
              }
            } else {
              if (!cloneableTags2[tag]) {
                return object ? value2 : {};
              }
              result = initCloneByTag2(value2, tag, baseClone2, isDeep);
            }
          }
          stack || (stack = new Stack2());
          var stacked = stack.get(value2);
          if (stacked) {
            return stacked;
          }
          stack.set(value2, result);
          if (!isArr) {
            var props = isFull ? getAllKeys2(value2) : keys2(value2);
          }
          arrayEach2(props || value2, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value2[key2];
            }
            assignValue2(result, key2, baseClone2(subValue, isDeep, isFull, customizer, key2, value2, stack));
          });
          return result;
        }
        function baseCreate2(proto) {
          return isObject2(proto) ? objectCreate2(proto) : {};
        }
        function baseGetAllKeys2(object, keysFunc, symbolsFunc) {
          var result = keysFunc(object);
          return isArray2(object) ? result : arrayPush2(result, symbolsFunc(object));
        }
        function baseGetTag2(value2) {
          return objectToString2.call(value2);
        }
        function baseIsNative2(value2) {
          if (!isObject2(value2) || isMasked2(value2)) {
            return false;
          }
          var pattern2 = isFunction2(value2) || isHostObject(value2) ? reIsNative2 : reIsHostCtor2;
          return pattern2.test(toSource2(value2));
        }
        function baseKeys2(object) {
          if (!isPrototype2(object)) {
            return nativeKeys2(object);
          }
          var result = [];
          for (var key in Object(object)) {
            if (hasOwnProperty2.call(object, key) && key != "constructor") {
              result.push(key);
            }
          }
          return result;
        }
        function cloneBuffer2(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var result = new buffer.constructor(buffer.length);
          buffer.copy(result);
          return result;
        }
        function cloneArrayBuffer2(arrayBuffer) {
          var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array3(result).set(new Uint8Array3(arrayBuffer));
          return result;
        }
        function cloneDataView2(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer2(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneMap(map2, isDeep, cloneFunc) {
          var array = isDeep ? cloneFunc(mapToArray2(map2), true) : mapToArray2(map2);
          return arrayReduce(array, addMapEntry, new map2.constructor());
        }
        function cloneRegExp2(regexp) {
          var result = new regexp.constructor(regexp.source, reFlags2.exec(regexp));
          result.lastIndex = regexp.lastIndex;
          return result;
        }
        function cloneSet(set, isDeep, cloneFunc) {
          var array = isDeep ? cloneFunc(setToArray2(set), true) : setToArray2(set);
          return arrayReduce(array, addSetEntry, new set.constructor());
        }
        function cloneSymbol2(symbol) {
          return symbolValueOf2 ? Object(symbolValueOf2.call(symbol)) : {};
        }
        function cloneTypedArray2(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer2(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function copyArray2(source, array) {
          var index = -1, length = source.length;
          array || (array = Array(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function copyObject2(source, props, object, customizer) {
          object || (object = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = void 0;
            assignValue2(object, key, newValue === void 0 ? source[key] : newValue);
          }
          return object;
        }
        function copySymbols2(source, object) {
          return copyObject2(source, getSymbols2(source), object);
        }
        function getAllKeys2(object) {
          return baseGetAllKeys2(object, keys2, getSymbols2);
        }
        function getMapData2(map2, key) {
          var data = map2.__data__;
          return isKeyable2(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getNative2(object, key) {
          var value2 = getValue2(object, key);
          return baseIsNative2(value2) ? value2 : void 0;
        }
        var getSymbols2 = nativeGetSymbols2 ? overArg2(nativeGetSymbols2, Object) : stubArray2;
        var getTag2 = baseGetTag2;
        if (DataView2 && getTag2(new DataView2(new ArrayBuffer(1))) != dataViewTag2 || Map2 && getTag2(new Map2()) != mapTag2 || Promise2 && getTag2(Promise2.resolve()) != promiseTag2 || Set2 && getTag2(new Set2()) != setTag2 || WeakMap2 && getTag2(new WeakMap2()) != weakMapTag2) {
          getTag2 = function(value2) {
            var result = objectToString2.call(value2), Ctor = result == objectTag2 ? value2.constructor : void 0, ctorString = Ctor ? toSource2(Ctor) : void 0;
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString2:
                  return dataViewTag2;
                case mapCtorString2:
                  return mapTag2;
                case promiseCtorString2:
                  return promiseTag2;
                case setCtorString2:
                  return setTag2;
                case weakMapCtorString2:
                  return weakMapTag2;
              }
            }
            return result;
          };
        }
        function initCloneArray2(array) {
          var length = array.length, result = array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
            result.index = array.index;
            result.input = array.input;
          }
          return result;
        }
        function initCloneObject2(object) {
          return typeof object.constructor == "function" && !isPrototype2(object) ? baseCreate2(getPrototype2(object)) : {};
        }
        function initCloneByTag2(object, tag, cloneFunc, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag2:
              return cloneArrayBuffer2(object);
            case boolTag2:
            case dateTag2:
              return new Ctor(+object);
            case dataViewTag2:
              return cloneDataView2(object, isDeep);
            case float32Tag2:
            case float64Tag2:
            case int8Tag2:
            case int16Tag2:
            case int32Tag2:
            case uint8Tag2:
            case uint8ClampedTag2:
            case uint16Tag2:
            case uint32Tag2:
              return cloneTypedArray2(object, isDeep);
            case mapTag2:
              return cloneMap(object, isDeep, cloneFunc);
            case numberTag2:
            case stringTag2:
              return new Ctor(object);
            case regexpTag2:
              return cloneRegExp2(object);
            case setTag2:
              return cloneSet(object, isDeep, cloneFunc);
            case symbolTag2:
              return cloneSymbol2(object);
          }
        }
        function isIndex2(value2, length) {
          length = length == null ? MAX_SAFE_INTEGER2 : length;
          return !!length && (typeof value2 == "number" || reIsUint2.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length);
        }
        function isKeyable2(value2) {
          var type = typeof value2;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value2 !== "__proto__" : value2 === null;
        }
        function isMasked2(func) {
          return !!maskSrcKey2 && maskSrcKey2 in func;
        }
        function isPrototype2(value2) {
          var Ctor = value2 && value2.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
          return value2 === proto;
        }
        function toSource2(func) {
          if (func != null) {
            try {
              return funcToString2.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function cloneDeep2(value2) {
          return baseClone2(value2, true, true);
        }
        function eq2(value2, other) {
          return value2 === other || value2 !== value2 && other !== other;
        }
        function isArguments2(value2) {
          return isArrayLikeObject2(value2) && hasOwnProperty2.call(value2, "callee") && (!propertyIsEnumerable2.call(value2, "callee") || objectToString2.call(value2) == argsTag2);
        }
        var isArray2 = Array.isArray;
        function isArrayLike2(value2) {
          return value2 != null && isLength2(value2.length) && !isFunction2(value2);
        }
        function isArrayLikeObject2(value2) {
          return isObjectLike2(value2) && isArrayLike2(value2);
        }
        var isBuffer2 = nativeIsBuffer2 || stubFalse2;
        function isFunction2(value2) {
          var tag = isObject2(value2) ? objectToString2.call(value2) : "";
          return tag == funcTag2 || tag == genTag2;
        }
        function isLength2(value2) {
          return typeof value2 == "number" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER2;
        }
        function isObject2(value2) {
          var type = typeof value2;
          return !!value2 && (type == "object" || type == "function");
        }
        function isObjectLike2(value2) {
          return !!value2 && typeof value2 == "object";
        }
        function keys2(object) {
          return isArrayLike2(object) ? arrayLikeKeys2(object) : baseKeys2(object);
        }
        function stubArray2() {
          return [];
        }
        function stubFalse2() {
          return false;
        }
        module2.exports = cloneDeep2;
      })(lodash_clonedeep, lodash_clonedeep.exports);
      return lodash_clonedeep.exports;
    }
    var lodash_isequal = { exports: {} };
    lodash_isequal.exports;
    var hasRequiredLodash_isequal;
    function requireLodash_isequal() {
      if (hasRequiredLodash_isequal) return lodash_isequal.exports;
      hasRequiredLodash_isequal = 1;
      (function(module2, exports2) {
        var LARGE_ARRAY_SIZE2 = 200;
        var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
        var COMPARE_PARTIAL_FLAG2 = 1, COMPARE_UNORDERED_FLAG2 = 2;
        var MAX_SAFE_INTEGER2 = 9007199254740991;
        var argsTag2 = "[object Arguments]", arrayTag2 = "[object Array]", asyncTag2 = "[object AsyncFunction]", boolTag2 = "[object Boolean]", dateTag2 = "[object Date]", errorTag2 = "[object Error]", funcTag2 = "[object Function]", genTag2 = "[object GeneratorFunction]", mapTag2 = "[object Map]", numberTag2 = "[object Number]", nullTag2 = "[object Null]", objectTag2 = "[object Object]", promiseTag2 = "[object Promise]", proxyTag2 = "[object Proxy]", regexpTag2 = "[object RegExp]", setTag2 = "[object Set]", stringTag2 = "[object String]", symbolTag2 = "[object Symbol]", undefinedTag2 = "[object Undefined]", weakMapTag2 = "[object WeakMap]";
        var arrayBufferTag2 = "[object ArrayBuffer]", dataViewTag2 = "[object DataView]", float32Tag2 = "[object Float32Array]", float64Tag2 = "[object Float64Array]", int8Tag2 = "[object Int8Array]", int16Tag2 = "[object Int16Array]", int32Tag2 = "[object Int32Array]", uint8Tag2 = "[object Uint8Array]", uint8ClampedTag2 = "[object Uint8ClampedArray]", uint16Tag2 = "[object Uint16Array]", uint32Tag2 = "[object Uint32Array]";
        var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
        var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
        var reIsUint2 = /^(?:0|[1-9]\d*)$/;
        var typedArrayTags2 = {};
        typedArrayTags2[float32Tag2] = typedArrayTags2[float64Tag2] = typedArrayTags2[int8Tag2] = typedArrayTags2[int16Tag2] = typedArrayTags2[int32Tag2] = typedArrayTags2[uint8Tag2] = typedArrayTags2[uint8ClampedTag2] = typedArrayTags2[uint16Tag2] = typedArrayTags2[uint32Tag2] = true;
        typedArrayTags2[argsTag2] = typedArrayTags2[arrayTag2] = typedArrayTags2[arrayBufferTag2] = typedArrayTags2[boolTag2] = typedArrayTags2[dataViewTag2] = typedArrayTags2[dateTag2] = typedArrayTags2[errorTag2] = typedArrayTags2[funcTag2] = typedArrayTags2[mapTag2] = typedArrayTags2[numberTag2] = typedArrayTags2[objectTag2] = typedArrayTags2[regexpTag2] = typedArrayTags2[setTag2] = typedArrayTags2[stringTag2] = typedArrayTags2[weakMapTag2] = false;
        var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
        var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
        var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
        var freeExports2 = exports2 && !exports2.nodeType && exports2;
        var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
        var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
        var freeProcess2 = moduleExports2 && freeGlobal2.process;
        var nodeUtil2 = function() {
          try {
            return freeProcess2 && freeProcess2.binding && freeProcess2.binding("util");
          } catch (e) {
          }
        }();
        var nodeIsTypedArray2 = nodeUtil2 && nodeUtil2.isTypedArray;
        function arrayFilter2(array, predicate) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
          while (++index < length) {
            var value2 = array[index];
            if (predicate(value2, index, array)) {
              result[resIndex++] = value2;
            }
          }
          return result;
        }
        function arrayPush2(array, values) {
          var index = -1, length = values.length, offset = array.length;
          while (++index < length) {
            array[offset + index] = values[index];
          }
          return array;
        }
        function arraySome2(array, predicate) {
          var index = -1, length = array == null ? 0 : array.length;
          while (++index < length) {
            if (predicate(array[index], index, array)) {
              return true;
            }
          }
          return false;
        }
        function baseTimes2(n, iteratee) {
          var index = -1, result = Array(n);
          while (++index < n) {
            result[index] = iteratee(index);
          }
          return result;
        }
        function baseUnary2(func) {
          return function(value2) {
            return func(value2);
          };
        }
        function cacheHas2(cache, key) {
          return cache.has(key);
        }
        function getValue2(object, key) {
          return object == null ? void 0 : object[key];
        }
        function mapToArray2(map2) {
          var index = -1, result = Array(map2.size);
          map2.forEach(function(value2, key) {
            result[++index] = [key, value2];
          });
          return result;
        }
        function overArg2(func, transform) {
          return function(arg) {
            return func(transform(arg));
          };
        }
        function setToArray2(set) {
          var index = -1, result = Array(set.size);
          set.forEach(function(value2) {
            result[++index] = value2;
          });
          return result;
        }
        var arrayProto2 = Array.prototype, funcProto2 = Function.prototype, objectProto2 = Object.prototype;
        var coreJsData2 = root2["__core-js_shared__"];
        var funcToString2 = funcProto2.toString;
        var hasOwnProperty2 = objectProto2.hasOwnProperty;
        var maskSrcKey2 = function() {
          var uid = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString2 = objectProto2.toString;
        var reIsNative2 = RegExp(
          "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer3 = moduleExports2 ? root2.Buffer : void 0, Symbol2 = root2.Symbol, Uint8Array3 = root2.Uint8Array, propertyIsEnumerable2 = objectProto2.propertyIsEnumerable, splice2 = arrayProto2.splice, symToStringTag2 = Symbol2 ? Symbol2.toStringTag : void 0;
        var nativeGetSymbols2 = Object.getOwnPropertySymbols, nativeIsBuffer2 = Buffer3 ? Buffer3.isBuffer : void 0, nativeKeys2 = overArg2(Object.keys, Object);
        var DataView2 = getNative2(root2, "DataView"), Map2 = getNative2(root2, "Map"), Promise2 = getNative2(root2, "Promise"), Set2 = getNative2(root2, "Set"), WeakMap2 = getNative2(root2, "WeakMap"), nativeCreate2 = getNative2(Object, "create");
        var dataViewCtorString2 = toSource2(DataView2), mapCtorString2 = toSource2(Map2), promiseCtorString2 = toSource2(Promise2), setCtorString2 = toSource2(Set2), weakMapCtorString2 = toSource2(WeakMap2);
        var symbolProto2 = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf2 = symbolProto2 ? symbolProto2.valueOf : void 0;
        function Hash2(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear2() {
          this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
          this.size = 0;
        }
        function hashDelete2(key) {
          var result = this.has(key) && delete this.__data__[key];
          this.size -= result ? 1 : 0;
          return result;
        }
        function hashGet2(key) {
          var data = this.__data__;
          if (nativeCreate2) {
            var result = data[key];
            return result === HASH_UNDEFINED2 ? void 0 : result;
          }
          return hasOwnProperty2.call(data, key) ? data[key] : void 0;
        }
        function hashHas2(key) {
          var data = this.__data__;
          return nativeCreate2 ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
        }
        function hashSet2(key, value2) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate2 && value2 === void 0 ? HASH_UNDEFINED2 : value2;
          return this;
        }
        Hash2.prototype.clear = hashClear2;
        Hash2.prototype["delete"] = hashDelete2;
        Hash2.prototype.get = hashGet2;
        Hash2.prototype.has = hashHas2;
        Hash2.prototype.set = hashSet2;
        function ListCache2(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear2() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete2(key) {
          var data = this.__data__, index = assocIndexOf2(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice2.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet2(key) {
          var data = this.__data__, index = assocIndexOf2(data, key);
          return index < 0 ? void 0 : data[index][1];
        }
        function listCacheHas2(key) {
          return assocIndexOf2(this.__data__, key) > -1;
        }
        function listCacheSet2(key, value2) {
          var data = this.__data__, index = assocIndexOf2(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value2]);
          } else {
            data[index][1] = value2;
          }
          return this;
        }
        ListCache2.prototype.clear = listCacheClear2;
        ListCache2.prototype["delete"] = listCacheDelete2;
        ListCache2.prototype.get = listCacheGet2;
        ListCache2.prototype.has = listCacheHas2;
        ListCache2.prototype.set = listCacheSet2;
        function MapCache2(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear2() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash2(),
            "map": new (Map2 || ListCache2)(),
            "string": new Hash2()
          };
        }
        function mapCacheDelete2(key) {
          var result = getMapData2(this, key)["delete"](key);
          this.size -= result ? 1 : 0;
          return result;
        }
        function mapCacheGet2(key) {
          return getMapData2(this, key).get(key);
        }
        function mapCacheHas2(key) {
          return getMapData2(this, key).has(key);
        }
        function mapCacheSet2(key, value2) {
          var data = getMapData2(this, key), size = data.size;
          data.set(key, value2);
          this.size += data.size == size ? 0 : 1;
          return this;
        }
        MapCache2.prototype.clear = mapCacheClear2;
        MapCache2.prototype["delete"] = mapCacheDelete2;
        MapCache2.prototype.get = mapCacheGet2;
        MapCache2.prototype.has = mapCacheHas2;
        MapCache2.prototype.set = mapCacheSet2;
        function SetCache2(values) {
          var index = -1, length = values == null ? 0 : values.length;
          this.__data__ = new MapCache2();
          while (++index < length) {
            this.add(values[index]);
          }
        }
        function setCacheAdd2(value2) {
          this.__data__.set(value2, HASH_UNDEFINED2);
          return this;
        }
        function setCacheHas2(value2) {
          return this.__data__.has(value2);
        }
        SetCache2.prototype.add = SetCache2.prototype.push = setCacheAdd2;
        SetCache2.prototype.has = setCacheHas2;
        function Stack2(entries) {
          var data = this.__data__ = new ListCache2(entries);
          this.size = data.size;
        }
        function stackClear2() {
          this.__data__ = new ListCache2();
          this.size = 0;
        }
        function stackDelete2(key) {
          var data = this.__data__, result = data["delete"](key);
          this.size = data.size;
          return result;
        }
        function stackGet2(key) {
          return this.__data__.get(key);
        }
        function stackHas2(key) {
          return this.__data__.has(key);
        }
        function stackSet2(key, value2) {
          var data = this.__data__;
          if (data instanceof ListCache2) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE2 - 1) {
              pairs.push([key, value2]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache2(pairs);
          }
          data.set(key, value2);
          this.size = data.size;
          return this;
        }
        Stack2.prototype.clear = stackClear2;
        Stack2.prototype["delete"] = stackDelete2;
        Stack2.prototype.get = stackGet2;
        Stack2.prototype.has = stackHas2;
        Stack2.prototype.set = stackSet2;
        function arrayLikeKeys2(value2, inherited) {
          var isArr = isArray2(value2), isArg = !isArr && isArguments2(value2), isBuff = !isArr && !isArg && isBuffer2(value2), isType = !isArr && !isArg && !isBuff && isTypedArray2(value2), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes2(value2.length, String) : [], length = result.length;
          for (var key in value2) {
            if (hasOwnProperty2.call(value2, key) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex2(key, length)))) {
              result.push(key);
            }
          }
          return result;
        }
        function assocIndexOf2(array, key) {
          var length = array.length;
          while (length--) {
            if (eq2(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseGetAllKeys2(object, keysFunc, symbolsFunc) {
          var result = keysFunc(object);
          return isArray2(object) ? result : arrayPush2(result, symbolsFunc(object));
        }
        function baseGetTag2(value2) {
          if (value2 == null) {
            return value2 === void 0 ? undefinedTag2 : nullTag2;
          }
          return symToStringTag2 && symToStringTag2 in Object(value2) ? getRawTag2(value2) : objectToString2(value2);
        }
        function baseIsArguments2(value2) {
          return isObjectLike2(value2) && baseGetTag2(value2) == argsTag2;
        }
        function baseIsEqual2(value2, other, bitmask, customizer, stack) {
          if (value2 === other) {
            return true;
          }
          if (value2 == null || other == null || !isObjectLike2(value2) && !isObjectLike2(other)) {
            return value2 !== value2 && other !== other;
          }
          return baseIsEqualDeep2(value2, other, bitmask, customizer, baseIsEqual2, stack);
        }
        function baseIsEqualDeep2(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag2 : getTag2(object), othTag = othIsArr ? arrayTag2 : getTag2(other);
          objTag = objTag == argsTag2 ? objectTag2 : objTag;
          othTag = othTag == argsTag2 ? objectTag2 : othTag;
          var objIsObj = objTag == objectTag2, othIsObj = othTag == objectTag2, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer2(object)) {
            if (!isBuffer2(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack2());
            return objIsArr || isTypedArray2(object) ? equalArrays2(object, other, bitmask, customizer, equalFunc, stack) : equalByTag2(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG2)) {
            var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack2());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack2());
          return equalObjects2(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsNative2(value2) {
          if (!isObject2(value2) || isMasked2(value2)) {
            return false;
          }
          var pattern2 = isFunction2(value2) ? reIsNative2 : reIsHostCtor2;
          return pattern2.test(toSource2(value2));
        }
        function baseIsTypedArray2(value2) {
          return isObjectLike2(value2) && isLength2(value2.length) && !!typedArrayTags2[baseGetTag2(value2)];
        }
        function baseKeys2(object) {
          if (!isPrototype2(object)) {
            return nativeKeys2(object);
          }
          var result = [];
          for (var key in Object(object)) {
            if (hasOwnProperty2.call(object, key) && key != "constructor") {
              result.push(key);
            }
          }
          return result;
        }
        function equalArrays2(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG2, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var stacked = stack.get(array);
          if (stacked && stack.get(other)) {
            return stacked == other;
          }
          var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG2 ? new SetCache2() : void 0;
          stack.set(array, other);
          stack.set(other, array);
          while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== void 0) {
              if (compared) {
                continue;
              }
              result = false;
              break;
            }
            if (seen) {
              if (!arraySome2(other, function(othValue2, othIndex) {
                if (!cacheHas2(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result;
        }
        function equalByTag2(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag2:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag2:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array3(object), new Uint8Array3(other))) {
                return false;
              }
              return true;
            case boolTag2:
            case dateTag2:
            case numberTag2:
              return eq2(+object, +other);
            case errorTag2:
              return object.name == other.name && object.message == other.message;
            case regexpTag2:
            case stringTag2:
              return object == other + "";
            case mapTag2:
              var convert = mapToArray2;
            case setTag2:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG2;
              convert || (convert = setToArray2);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG2;
              stack.set(object, other);
              var result = equalArrays2(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result;
            case symbolTag2:
              if (symbolValueOf2) {
                return symbolValueOf2.call(object) == symbolValueOf2.call(other);
              }
          }
          return false;
        }
        function equalObjects2(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG2, objProps = getAllKeys2(object), objLength = objProps.length, othProps = getAllKeys2(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
              return false;
            }
          }
          var stacked = stack.get(object);
          if (stacked && stack.get(other)) {
            return stacked == other;
          }
          var result = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result;
        }
        function getAllKeys2(object) {
          return baseGetAllKeys2(object, keys2, getSymbols2);
        }
        function getMapData2(map2, key) {
          var data = map2.__data__;
          return isKeyable2(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getNative2(object, key) {
          var value2 = getValue2(object, key);
          return baseIsNative2(value2) ? value2 : void 0;
        }
        function getRawTag2(value2) {
          var isOwn = hasOwnProperty2.call(value2, symToStringTag2), tag = value2[symToStringTag2];
          try {
            value2[symToStringTag2] = void 0;
            var unmasked = true;
          } catch (e) {
          }
          var result = nativeObjectToString2.call(value2);
          if (unmasked) {
            if (isOwn) {
              value2[symToStringTag2] = tag;
            } else {
              delete value2[symToStringTag2];
            }
          }
          return result;
        }
        var getSymbols2 = !nativeGetSymbols2 ? stubArray2 : function(object) {
          if (object == null) {
            return [];
          }
          object = Object(object);
          return arrayFilter2(nativeGetSymbols2(object), function(symbol) {
            return propertyIsEnumerable2.call(object, symbol);
          });
        };
        var getTag2 = baseGetTag2;
        if (DataView2 && getTag2(new DataView2(new ArrayBuffer(1))) != dataViewTag2 || Map2 && getTag2(new Map2()) != mapTag2 || Promise2 && getTag2(Promise2.resolve()) != promiseTag2 || Set2 && getTag2(new Set2()) != setTag2 || WeakMap2 && getTag2(new WeakMap2()) != weakMapTag2) {
          getTag2 = function(value2) {
            var result = baseGetTag2(value2), Ctor = result == objectTag2 ? value2.constructor : void 0, ctorString = Ctor ? toSource2(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString2:
                  return dataViewTag2;
                case mapCtorString2:
                  return mapTag2;
                case promiseCtorString2:
                  return promiseTag2;
                case setCtorString2:
                  return setTag2;
                case weakMapCtorString2:
                  return weakMapTag2;
              }
            }
            return result;
          };
        }
        function isIndex2(value2, length) {
          length = length == null ? MAX_SAFE_INTEGER2 : length;
          return !!length && (typeof value2 == "number" || reIsUint2.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length);
        }
        function isKeyable2(value2) {
          var type = typeof value2;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value2 !== "__proto__" : value2 === null;
        }
        function isMasked2(func) {
          return !!maskSrcKey2 && maskSrcKey2 in func;
        }
        function isPrototype2(value2) {
          var Ctor = value2 && value2.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
          return value2 === proto;
        }
        function objectToString2(value2) {
          return nativeObjectToString2.call(value2);
        }
        function toSource2(func) {
          if (func != null) {
            try {
              return funcToString2.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function eq2(value2, other) {
          return value2 === other || value2 !== value2 && other !== other;
        }
        var isArguments2 = baseIsArguments2(/* @__PURE__ */ function() {
          return arguments;
        }()) ? baseIsArguments2 : function(value2) {
          return isObjectLike2(value2) && hasOwnProperty2.call(value2, "callee") && !propertyIsEnumerable2.call(value2, "callee");
        };
        var isArray2 = Array.isArray;
        function isArrayLike2(value2) {
          return value2 != null && isLength2(value2.length) && !isFunction2(value2);
        }
        var isBuffer2 = nativeIsBuffer2 || stubFalse2;
        function isEqual2(value2, other) {
          return baseIsEqual2(value2, other);
        }
        function isFunction2(value2) {
          if (!isObject2(value2)) {
            return false;
          }
          var tag = baseGetTag2(value2);
          return tag == funcTag2 || tag == genTag2 || tag == asyncTag2 || tag == proxyTag2;
        }
        function isLength2(value2) {
          return typeof value2 == "number" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER2;
        }
        function isObject2(value2) {
          var type = typeof value2;
          return value2 != null && (type == "object" || type == "function");
        }
        function isObjectLike2(value2) {
          return value2 != null && typeof value2 == "object";
        }
        var isTypedArray2 = nodeIsTypedArray2 ? baseUnary2(nodeIsTypedArray2) : baseIsTypedArray2;
        function keys2(object) {
          return isArrayLike2(object) ? arrayLikeKeys2(object) : baseKeys2(object);
        }
        function stubArray2() {
          return [];
        }
        function stubFalse2() {
          return false;
        }
        module2.exports = isEqual2;
      })(lodash_isequal, lodash_isequal.exports);
      return lodash_isequal.exports;
    }
    var AttributeMap = {};
    var hasRequiredAttributeMap;
    function requireAttributeMap() {
      if (hasRequiredAttributeMap) return AttributeMap;
      hasRequiredAttributeMap = 1;
      Object.defineProperty(AttributeMap, "__esModule", { value: true });
      const cloneDeep2 = requireLodash_clonedeep();
      const isEqual2 = requireLodash_isequal();
      var AttributeMap$1;
      (function(AttributeMap2) {
        function compose(a = {}, b = {}, keepNull = false) {
          if (typeof a !== "object") {
            a = {};
          }
          if (typeof b !== "object") {
            b = {};
          }
          let attributes = cloneDeep2(b);
          if (!keepNull) {
            attributes = Object.keys(attributes).reduce((copy, key) => {
              if (attributes[key] != null) {
                copy[key] = attributes[key];
              }
              return copy;
            }, {});
          }
          for (const key in a) {
            if (a[key] !== void 0 && b[key] === void 0) {
              attributes[key] = a[key];
            }
          }
          return Object.keys(attributes).length > 0 ? attributes : void 0;
        }
        AttributeMap2.compose = compose;
        function diff(a = {}, b = {}) {
          if (typeof a !== "object") {
            a = {};
          }
          if (typeof b !== "object") {
            b = {};
          }
          const attributes = Object.keys(a).concat(Object.keys(b)).reduce((attrs, key) => {
            if (!isEqual2(a[key], b[key])) {
              attrs[key] = b[key] === void 0 ? null : b[key];
            }
            return attrs;
          }, {});
          return Object.keys(attributes).length > 0 ? attributes : void 0;
        }
        AttributeMap2.diff = diff;
        function invert(attr = {}, base = {}) {
          attr = attr || {};
          const baseInverted = Object.keys(base).reduce((memo, key) => {
            if (base[key] !== attr[key] && attr[key] !== void 0) {
              memo[key] = base[key];
            }
            return memo;
          }, {});
          return Object.keys(attr).reduce((memo, key) => {
            if (attr[key] !== base[key] && base[key] === void 0) {
              memo[key] = null;
            }
            return memo;
          }, baseInverted);
        }
        AttributeMap2.invert = invert;
        function transform(a, b, priority = false) {
          if (typeof a !== "object") {
            return b;
          }
          if (typeof b !== "object") {
            return void 0;
          }
          if (!priority) {
            return b;
          }
          const attributes = Object.keys(b).reduce((attrs, key) => {
            if (a[key] === void 0) {
              attrs[key] = b[key];
            }
            return attrs;
          }, {});
          return Object.keys(attributes).length > 0 ? attributes : void 0;
        }
        AttributeMap2.transform = transform;
      })(AttributeMap$1 || (AttributeMap$1 = {}));
      AttributeMap.default = AttributeMap$1;
      return AttributeMap;
    }
    var Op = {};
    var hasRequiredOp;
    function requireOp() {
      if (hasRequiredOp) return Op;
      hasRequiredOp = 1;
      Object.defineProperty(Op, "__esModule", { value: true });
      var Op$1;
      (function(Op2) {
        function length(op) {
          if (typeof op.delete === "number") {
            return op.delete;
          } else if (typeof op.retain === "number") {
            return op.retain;
          } else if (typeof op.retain === "object" && op.retain !== null) {
            return 1;
          } else {
            return typeof op.insert === "string" ? op.insert.length : 1;
          }
        }
        Op2.length = length;
      })(Op$1 || (Op$1 = {}));
      Op.default = Op$1;
      return Op;
    }
    var OpIterator = {};
    var hasRequiredOpIterator;
    function requireOpIterator() {
      if (hasRequiredOpIterator) return OpIterator;
      hasRequiredOpIterator = 1;
      Object.defineProperty(OpIterator, "__esModule", { value: true });
      const Op_1 = requireOp();
      class Iterator {
        constructor(ops) {
          this.ops = ops;
          this.index = 0;
          this.offset = 0;
        }
        hasNext() {
          return this.peekLength() < Infinity;
        }
        next(length) {
          if (!length) {
            length = Infinity;
          }
          const nextOp = this.ops[this.index];
          if (nextOp) {
            const offset = this.offset;
            const opLength = Op_1.default.length(nextOp);
            if (length >= opLength - offset) {
              length = opLength - offset;
              this.index += 1;
              this.offset = 0;
            } else {
              this.offset += length;
            }
            if (typeof nextOp.delete === "number") {
              return { delete: length };
            } else {
              const retOp = {};
              if (nextOp.attributes) {
                retOp.attributes = nextOp.attributes;
              }
              if (typeof nextOp.retain === "number") {
                retOp.retain = length;
              } else if (typeof nextOp.retain === "object" && nextOp.retain !== null) {
                retOp.retain = nextOp.retain;
              } else if (typeof nextOp.insert === "string") {
                retOp.insert = nextOp.insert.substr(offset, length);
              } else {
                retOp.insert = nextOp.insert;
              }
              return retOp;
            }
          } else {
            return { retain: Infinity };
          }
        }
        peek() {
          return this.ops[this.index];
        }
        peekLength() {
          if (this.ops[this.index]) {
            return Op_1.default.length(this.ops[this.index]) - this.offset;
          } else {
            return Infinity;
          }
        }
        peekType() {
          const op = this.ops[this.index];
          if (op) {
            if (typeof op.delete === "number") {
              return "delete";
            } else if (typeof op.retain === "number" || typeof op.retain === "object" && op.retain !== null) {
              return "retain";
            } else {
              return "insert";
            }
          }
          return "retain";
        }
        rest() {
          if (!this.hasNext()) {
            return [];
          } else if (this.offset === 0) {
            return this.ops.slice(this.index);
          } else {
            const offset = this.offset;
            const index = this.index;
            const next = this.next();
            const rest = this.ops.slice(this.index);
            this.offset = offset;
            this.index = index;
            return [next].concat(rest);
          }
        }
      }
      OpIterator.default = Iterator;
      return OpIterator;
    }
    var hasRequiredDelta;
    function requireDelta() {
      if (hasRequiredDelta) return Delta$1.exports;
      hasRequiredDelta = 1;
      (function(module2, exports2) {
        Object.defineProperty(exports2, "__esModule", { value: true });
        exports2.AttributeMap = exports2.OpIterator = exports2.Op = void 0;
        const diff = requireDiff();
        const cloneDeep2 = requireLodash_clonedeep();
        const isEqual2 = requireLodash_isequal();
        const AttributeMap_1 = requireAttributeMap();
        exports2.AttributeMap = AttributeMap_1.default;
        const Op_1 = requireOp();
        exports2.Op = Op_1.default;
        const OpIterator_1 = requireOpIterator();
        exports2.OpIterator = OpIterator_1.default;
        const NULL_CHARACTER = String.fromCharCode(0);
        const getEmbedTypeAndData = (a, b) => {
          if (typeof a !== "object" || a === null) {
            throw new Error(`cannot retain a ${typeof a}`);
          }
          if (typeof b !== "object" || b === null) {
            throw new Error(`cannot retain a ${typeof b}`);
          }
          const embedType = Object.keys(a)[0];
          if (!embedType || embedType !== Object.keys(b)[0]) {
            throw new Error(`embed types not matched: ${embedType} != ${Object.keys(b)[0]}`);
          }
          return [embedType, a[embedType], b[embedType]];
        };
        class Delta2 {
          constructor(ops) {
            if (Array.isArray(ops)) {
              this.ops = ops;
            } else if (ops != null && Array.isArray(ops.ops)) {
              this.ops = ops.ops;
            } else {
              this.ops = [];
            }
          }
          static registerEmbed(embedType, handler) {
            this.handlers[embedType] = handler;
          }
          static unregisterEmbed(embedType) {
            delete this.handlers[embedType];
          }
          static getHandler(embedType) {
            const handler = this.handlers[embedType];
            if (!handler) {
              throw new Error(`no handlers for embed type "${embedType}"`);
            }
            return handler;
          }
          insert(arg, attributes) {
            const newOp = {};
            if (typeof arg === "string" && arg.length === 0) {
              return this;
            }
            newOp.insert = arg;
            if (attributes != null && typeof attributes === "object" && Object.keys(attributes).length > 0) {
              newOp.attributes = attributes;
            }
            return this.push(newOp);
          }
          delete(length) {
            if (length <= 0) {
              return this;
            }
            return this.push({ delete: length });
          }
          retain(length, attributes) {
            if (typeof length === "number" && length <= 0) {
              return this;
            }
            const newOp = { retain: length };
            if (attributes != null && typeof attributes === "object" && Object.keys(attributes).length > 0) {
              newOp.attributes = attributes;
            }
            return this.push(newOp);
          }
          push(newOp) {
            let index = this.ops.length;
            let lastOp = this.ops[index - 1];
            newOp = cloneDeep2(newOp);
            if (typeof lastOp === "object") {
              if (typeof newOp.delete === "number" && typeof lastOp.delete === "number") {
                this.ops[index - 1] = { delete: lastOp.delete + newOp.delete };
                return this;
              }
              if (typeof lastOp.delete === "number" && newOp.insert != null) {
                index -= 1;
                lastOp = this.ops[index - 1];
                if (typeof lastOp !== "object") {
                  this.ops.unshift(newOp);
                  return this;
                }
              }
              if (isEqual2(newOp.attributes, lastOp.attributes)) {
                if (typeof newOp.insert === "string" && typeof lastOp.insert === "string") {
                  this.ops[index - 1] = { insert: lastOp.insert + newOp.insert };
                  if (typeof newOp.attributes === "object") {
                    this.ops[index - 1].attributes = newOp.attributes;
                  }
                  return this;
                } else if (typeof newOp.retain === "number" && typeof lastOp.retain === "number") {
                  this.ops[index - 1] = { retain: lastOp.retain + newOp.retain };
                  if (typeof newOp.attributes === "object") {
                    this.ops[index - 1].attributes = newOp.attributes;
                  }
                  return this;
                }
              }
            }
            if (index === this.ops.length) {
              this.ops.push(newOp);
            } else {
              this.ops.splice(index, 0, newOp);
            }
            return this;
          }
          chop() {
            const lastOp = this.ops[this.ops.length - 1];
            if (lastOp && typeof lastOp.retain === "number" && !lastOp.attributes) {
              this.ops.pop();
            }
            return this;
          }
          filter(predicate) {
            return this.ops.filter(predicate);
          }
          forEach(predicate) {
            this.ops.forEach(predicate);
          }
          map(predicate) {
            return this.ops.map(predicate);
          }
          partition(predicate) {
            const passed = [];
            const failed = [];
            this.forEach((op) => {
              const target = predicate(op) ? passed : failed;
              target.push(op);
            });
            return [passed, failed];
          }
          reduce(predicate, initialValue) {
            return this.ops.reduce(predicate, initialValue);
          }
          changeLength() {
            return this.reduce((length, elem) => {
              if (elem.insert) {
                return length + Op_1.default.length(elem);
              } else if (elem.delete) {
                return length - elem.delete;
              }
              return length;
            }, 0);
          }
          length() {
            return this.reduce((length, elem) => {
              return length + Op_1.default.length(elem);
            }, 0);
          }
          slice(start = 0, end = Infinity) {
            const ops = [];
            const iter = new OpIterator_1.default(this.ops);
            let index = 0;
            while (index < end && iter.hasNext()) {
              let nextOp;
              if (index < start) {
                nextOp = iter.next(start - index);
              } else {
                nextOp = iter.next(end - index);
                ops.push(nextOp);
              }
              index += Op_1.default.length(nextOp);
            }
            return new Delta2(ops);
          }
          compose(other) {
            const thisIter = new OpIterator_1.default(this.ops);
            const otherIter = new OpIterator_1.default(other.ops);
            const ops = [];
            const firstOther = otherIter.peek();
            if (firstOther != null && typeof firstOther.retain === "number" && firstOther.attributes == null) {
              let firstLeft = firstOther.retain;
              while (thisIter.peekType() === "insert" && thisIter.peekLength() <= firstLeft) {
                firstLeft -= thisIter.peekLength();
                ops.push(thisIter.next());
              }
              if (firstOther.retain - firstLeft > 0) {
                otherIter.next(firstOther.retain - firstLeft);
              }
            }
            const delta = new Delta2(ops);
            while (thisIter.hasNext() || otherIter.hasNext()) {
              if (otherIter.peekType() === "insert") {
                delta.push(otherIter.next());
              } else if (thisIter.peekType() === "delete") {
                delta.push(thisIter.next());
              } else {
                const length = Math.min(thisIter.peekLength(), otherIter.peekLength());
                const thisOp = thisIter.next(length);
                const otherOp = otherIter.next(length);
                if (otherOp.retain) {
                  const newOp = {};
                  if (typeof thisOp.retain === "number") {
                    newOp.retain = typeof otherOp.retain === "number" ? length : otherOp.retain;
                  } else {
                    if (typeof otherOp.retain === "number") {
                      if (thisOp.retain == null) {
                        newOp.insert = thisOp.insert;
                      } else {
                        newOp.retain = thisOp.retain;
                      }
                    } else {
                      const action = thisOp.retain == null ? "insert" : "retain";
                      const [embedType, thisData, otherData] = getEmbedTypeAndData(thisOp[action], otherOp.retain);
                      const handler = Delta2.getHandler(embedType);
                      newOp[action] = {
                        [embedType]: handler.compose(thisData, otherData, action === "retain")
                      };
                    }
                  }
                  const attributes = AttributeMap_1.default.compose(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === "number");
                  if (attributes) {
                    newOp.attributes = attributes;
                  }
                  delta.push(newOp);
                  if (!otherIter.hasNext() && isEqual2(delta.ops[delta.ops.length - 1], newOp)) {
                    const rest = new Delta2(thisIter.rest());
                    return delta.concat(rest).chop();
                  }
                } else if (typeof otherOp.delete === "number" && (typeof thisOp.retain === "number" || typeof thisOp.retain === "object" && thisOp.retain !== null)) {
                  delta.push(otherOp);
                }
              }
            }
            return delta.chop();
          }
          concat(other) {
            const delta = new Delta2(this.ops.slice());
            if (other.ops.length > 0) {
              delta.push(other.ops[0]);
              delta.ops = delta.ops.concat(other.ops.slice(1));
            }
            return delta;
          }
          diff(other, cursor) {
            if (this.ops === other.ops) {
              return new Delta2();
            }
            const strings = [this, other].map((delta) => {
              return delta.map((op) => {
                if (op.insert != null) {
                  return typeof op.insert === "string" ? op.insert : NULL_CHARACTER;
                }
                const prep = delta === other ? "on" : "with";
                throw new Error("diff() called " + prep + " non-document");
              }).join("");
            });
            const retDelta = new Delta2();
            const diffResult = diff(strings[0], strings[1], cursor, true);
            const thisIter = new OpIterator_1.default(this.ops);
            const otherIter = new OpIterator_1.default(other.ops);
            diffResult.forEach((component) => {
              let length = component[1].length;
              while (length > 0) {
                let opLength = 0;
                switch (component[0]) {
                  case diff.INSERT:
                    opLength = Math.min(otherIter.peekLength(), length);
                    retDelta.push(otherIter.next(opLength));
                    break;
                  case diff.DELETE:
                    opLength = Math.min(length, thisIter.peekLength());
                    thisIter.next(opLength);
                    retDelta.delete(opLength);
                    break;
                  case diff.EQUAL:
                    opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);
                    const thisOp = thisIter.next(opLength);
                    const otherOp = otherIter.next(opLength);
                    if (isEqual2(thisOp.insert, otherOp.insert)) {
                      retDelta.retain(opLength, AttributeMap_1.default.diff(thisOp.attributes, otherOp.attributes));
                    } else {
                      retDelta.push(otherOp).delete(opLength);
                    }
                    break;
                }
                length -= opLength;
              }
            });
            return retDelta.chop();
          }
          eachLine(predicate, newline = "\n") {
            const iter = new OpIterator_1.default(this.ops);
            let line = new Delta2();
            let i = 0;
            while (iter.hasNext()) {
              if (iter.peekType() !== "insert") {
                return;
              }
              const thisOp = iter.peek();
              const start = Op_1.default.length(thisOp) - iter.peekLength();
              const index = typeof thisOp.insert === "string" ? thisOp.insert.indexOf(newline, start) - start : -1;
              if (index < 0) {
                line.push(iter.next());
              } else if (index > 0) {
                line.push(iter.next(index));
              } else {
                if (predicate(line, iter.next(1).attributes || {}, i) === false) {
                  return;
                }
                i += 1;
                line = new Delta2();
              }
            }
            if (line.length() > 0) {
              predicate(line, {}, i);
            }
          }
          invert(base) {
            const inverted = new Delta2();
            this.reduce((baseIndex, op) => {
              if (op.insert) {
                inverted.delete(Op_1.default.length(op));
              } else if (typeof op.retain === "number" && op.attributes == null) {
                inverted.retain(op.retain);
                return baseIndex + op.retain;
              } else if (op.delete || typeof op.retain === "number") {
                const length = op.delete || op.retain;
                const slice = base.slice(baseIndex, baseIndex + length);
                slice.forEach((baseOp) => {
                  if (op.delete) {
                    inverted.push(baseOp);
                  } else if (op.retain && op.attributes) {
                    inverted.retain(Op_1.default.length(baseOp), AttributeMap_1.default.invert(op.attributes, baseOp.attributes));
                  }
                });
                return baseIndex + length;
              } else if (typeof op.retain === "object" && op.retain !== null) {
                const slice = base.slice(baseIndex, baseIndex + 1);
                const baseOp = new OpIterator_1.default(slice.ops).next();
                const [embedType, opData, baseOpData] = getEmbedTypeAndData(op.retain, baseOp.insert);
                const handler = Delta2.getHandler(embedType);
                inverted.retain({ [embedType]: handler.invert(opData, baseOpData) }, AttributeMap_1.default.invert(op.attributes, baseOp.attributes));
                return baseIndex + 1;
              }
              return baseIndex;
            }, 0);
            return inverted.chop();
          }
          transform(arg, priority = false) {
            priority = !!priority;
            if (typeof arg === "number") {
              return this.transformPosition(arg, priority);
            }
            const other = arg;
            const thisIter = new OpIterator_1.default(this.ops);
            const otherIter = new OpIterator_1.default(other.ops);
            const delta = new Delta2();
            while (thisIter.hasNext() || otherIter.hasNext()) {
              if (thisIter.peekType() === "insert" && (priority || otherIter.peekType() !== "insert")) {
                delta.retain(Op_1.default.length(thisIter.next()));
              } else if (otherIter.peekType() === "insert") {
                delta.push(otherIter.next());
              } else {
                const length = Math.min(thisIter.peekLength(), otherIter.peekLength());
                const thisOp = thisIter.next(length);
                const otherOp = otherIter.next(length);
                if (thisOp.delete) {
                  continue;
                } else if (otherOp.delete) {
                  delta.push(otherOp);
                } else {
                  const thisData = thisOp.retain;
                  const otherData = otherOp.retain;
                  let transformedData = typeof otherData === "object" && otherData !== null ? otherData : length;
                  if (typeof thisData === "object" && thisData !== null && typeof otherData === "object" && otherData !== null) {
                    const embedType = Object.keys(thisData)[0];
                    if (embedType === Object.keys(otherData)[0]) {
                      const handler = Delta2.getHandler(embedType);
                      if (handler) {
                        transformedData = {
                          [embedType]: handler.transform(thisData[embedType], otherData[embedType], priority)
                        };
                      }
                    }
                  }
                  delta.retain(transformedData, AttributeMap_1.default.transform(thisOp.attributes, otherOp.attributes, priority));
                }
              }
            }
            return delta.chop();
          }
          transformPosition(index, priority = false) {
            priority = !!priority;
            const thisIter = new OpIterator_1.default(this.ops);
            let offset = 0;
            while (thisIter.hasNext() && offset <= index) {
              const length = thisIter.peekLength();
              const nextType = thisIter.peekType();
              thisIter.next();
              if (nextType === "delete") {
                index -= Math.min(length, index - offset);
                continue;
              } else if (nextType === "insert" && (offset < index || !priority)) {
                index += length;
              }
              offset += length;
            }
            return index;
          }
        }
        Delta2.Op = Op_1.default;
        Delta2.OpIterator = OpIterator_1.default;
        Delta2.AttributeMap = AttributeMap_1.default;
        Delta2.handlers = {};
        exports2.default = Delta2;
        {
          module2.exports = Delta2;
          module2.exports.default = Delta2;
        }
      })(Delta$1, Delta$1.exports);
      return Delta$1.exports;
    }
    var DeltaExports = requireDelta();
    const Delta = /* @__PURE__ */ getDefaultExportFromCjs(DeltaExports);
    class Break extends EmbedBlot$1 {
      static value() {
        return void 0;
      }
      optimize() {
        if (this.prev || this.next) {
          this.remove();
        }
      }
      length() {
        return 0;
      }
      value() {
        return "";
      }
    }
    Break.blotName = "break";
    Break.tagName = "BR";
    let Text$1 = class Text extends TextBlot$1 {
    };
    const entityMap = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    function escapeText(text) {
      return text.replace(/[&<>"']/g, (s) => entityMap[s]);
    }
    let Inline$1 = (_a = class extends InlineBlot$1 {
      static compare(self2, other) {
        const selfIndex = _a.order.indexOf(self2);
        const otherIndex = _a.order.indexOf(other);
        if (selfIndex >= 0 || otherIndex >= 0) {
          return selfIndex - otherIndex;
        }
        if (self2 === other) {
          return 0;
        }
        if (self2 < other) {
          return -1;
        }
        return 1;
      }
      formatAt(index, length, name2, value2) {
        if (_a.compare(this.statics.blotName, name2) < 0 && this.scroll.query(name2, Scope.BLOT)) {
          const blot = this.isolate(index, length);
          if (value2) {
            blot.wrap(name2, value2);
          }
        } else {
          super.formatAt(index, length, name2, value2);
        }
      }
      optimize(context) {
        super.optimize(context);
        if (this.parent instanceof _a && _a.compare(this.statics.blotName, this.parent.statics.blotName) > 0) {
          const parent = this.parent.isolate(this.offset(), this.length());
          this.moveChildren(parent);
          parent.wrap(this);
        }
      }
    }, __publicField(_a, "allowedChildren", [_a, Break, EmbedBlot$1, Text$1]), // Lower index means deeper in the DOM tree, since not found (-1) is for embeds
    __publicField(_a, "order", [
      "cursor",
      "inline",
      // Must be lower
      "link",
      // Chrome wants <a> to be lower
      "underline",
      "strike",
      "italic",
      "bold",
      "script",
      "code"
      // Must be higher
    ]), _a);
    const NEWLINE_LENGTH = 1;
    class Block extends BlockBlot$1 {
      constructor() {
        super(...arguments);
        __publicField(this, "cache", {});
      }
      delta() {
        if (this.cache.delta == null) {
          this.cache.delta = blockDelta(this);
        }
        return this.cache.delta;
      }
      deleteAt(index, length) {
        super.deleteAt(index, length);
        this.cache = {};
      }
      formatAt(index, length, name2, value2) {
        if (length <= 0) return;
        if (this.scroll.query(name2, Scope.BLOCK)) {
          if (index + length === this.length()) {
            this.format(name2, value2);
          }
        } else {
          super.formatAt(index, Math.min(length, this.length() - index - 1), name2, value2);
        }
        this.cache = {};
      }
      insertAt(index, value2, def) {
        if (def != null) {
          super.insertAt(index, value2, def);
          this.cache = {};
          return;
        }
        if (value2.length === 0) return;
        const lines = value2.split("\n");
        const text = lines.shift();
        if (text.length > 0) {
          if (index < this.length() - 1 || this.children.tail == null) {
            super.insertAt(Math.min(index, this.length() - 1), text);
          } else {
            this.children.tail.insertAt(this.children.tail.length(), text);
          }
          this.cache = {};
        }
        let block = this;
        lines.reduce((lineIndex, line) => {
          block = block.split(lineIndex, true);
          block.insertAt(0, line);
          return line.length;
        }, index + text.length);
      }
      insertBefore(blot, ref) {
        const {
          head: head2
        } = this.children;
        super.insertBefore(blot, ref);
        if (head2 instanceof Break) {
          head2.remove();
        }
        this.cache = {};
      }
      length() {
        if (this.cache.length == null) {
          this.cache.length = super.length() + NEWLINE_LENGTH;
        }
        return this.cache.length;
      }
      moveChildren(target, ref) {
        super.moveChildren(target, ref);
        this.cache = {};
      }
      optimize(context) {
        super.optimize(context);
        this.cache = {};
      }
      path(index) {
        return super.path(index, true);
      }
      removeChild(child) {
        super.removeChild(child);
        this.cache = {};
      }
      split(index) {
        let force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        if (force && (index === 0 || index >= this.length() - NEWLINE_LENGTH)) {
          const clone = this.clone();
          if (index === 0) {
            this.parent.insertBefore(clone, this);
            return this;
          }
          this.parent.insertBefore(clone, this.next);
          return clone;
        }
        const next = super.split(index, force);
        this.cache = {};
        return next;
      }
    }
    Block.blotName = "block";
    Block.tagName = "P";
    Block.defaultChild = Break;
    Block.allowedChildren = [Break, Inline$1, EmbedBlot$1, Text$1];
    class BlockEmbed extends EmbedBlot$1 {
      attach() {
        super.attach();
        this.attributes = new AttributorStore$1(this.domNode);
      }
      delta() {
        return new Delta().insert(this.value(), {
          ...this.formats(),
          ...this.attributes.values()
        });
      }
      format(name2, value2) {
        const attribute = this.scroll.query(name2, Scope.BLOCK_ATTRIBUTE);
        if (attribute != null) {
          this.attributes.attribute(attribute, value2);
        }
      }
      formatAt(index, length, name2, value2) {
        this.format(name2, value2);
      }
      insertAt(index, value2, def) {
        if (def != null) {
          super.insertAt(index, value2, def);
          return;
        }
        const lines = value2.split("\n");
        const text = lines.pop();
        const blocks = lines.map((line) => {
          const block = this.scroll.create(Block.blotName);
          block.insertAt(0, line);
          return block;
        });
        const ref = this.split(index);
        blocks.forEach((block) => {
          this.parent.insertBefore(block, ref);
        });
        if (text) {
          this.parent.insertBefore(this.scroll.create("text", text), ref);
        }
      }
    }
    BlockEmbed.scope = Scope.BLOCK_BLOT;
    function blockDelta(blot) {
      let filter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      return blot.descendants(LeafBlot$1).reduce((delta, leaf) => {
        if (leaf.length() === 0) {
          return delta;
        }
        return delta.insert(leaf.value(), bubbleFormats(leaf, {}, filter));
      }, new Delta()).insert("\n", bubbleFormats(blot));
    }
    function bubbleFormats(blot) {
      let formats = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      let filter = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
      if (blot == null) return formats;
      if ("formats" in blot && typeof blot.formats === "function") {
        formats = {
          ...formats,
          ...blot.formats()
        };
        if (filter) {
          delete formats["code-token"];
        }
      }
      if (blot.parent == null || blot.parent.statics.blotName === "scroll" || blot.parent.statics.scope !== blot.statics.scope) {
        return formats;
      }
      return bubbleFormats(blot.parent, formats, filter);
    }
    const _Cursor = class _Cursor extends EmbedBlot$1 {
      // Zero width no break space
      static value() {
        return void 0;
      }
      constructor(scroll, domNode, selection) {
        super(scroll, domNode);
        this.selection = selection;
        this.textNode = document.createTextNode(_Cursor.CONTENTS);
        this.domNode.appendChild(this.textNode);
        this.savedLength = 0;
      }
      detach() {
        if (this.parent != null) this.parent.removeChild(this);
      }
      format(name2, value2) {
        if (this.savedLength !== 0) {
          super.format(name2, value2);
          return;
        }
        let target = this;
        let index = 0;
        while (target != null && target.statics.scope !== Scope.BLOCK_BLOT) {
          index += target.offset(target.parent);
          target = target.parent;
        }
        if (target != null) {
          this.savedLength = _Cursor.CONTENTS.length;
          target.optimize();
          target.formatAt(index, _Cursor.CONTENTS.length, name2, value2);
          this.savedLength = 0;
        }
      }
      index(node, offset) {
        if (node === this.textNode) return 0;
        return super.index(node, offset);
      }
      length() {
        return this.savedLength;
      }
      position() {
        return [this.textNode, this.textNode.data.length];
      }
      remove() {
        super.remove();
        this.parent = null;
      }
      restore() {
        if (this.selection.composing || this.parent == null) return null;
        const range = this.selection.getNativeRange();
        while (this.domNode.lastChild != null && this.domNode.lastChild !== this.textNode) {
          this.domNode.parentNode.insertBefore(this.domNode.lastChild, this.domNode);
        }
        const prevTextBlot = this.prev instanceof Text$1 ? this.prev : null;
        const prevTextLength = prevTextBlot ? prevTextBlot.length() : 0;
        const nextTextBlot = this.next instanceof Text$1 ? this.next : null;
        const nextText = nextTextBlot ? nextTextBlot.text : "";
        const {
          textNode
        } = this;
        const newText = textNode.data.split(_Cursor.CONTENTS).join("");
        textNode.data = _Cursor.CONTENTS;
        let mergedTextBlot;
        if (prevTextBlot) {
          mergedTextBlot = prevTextBlot;
          if (newText || nextTextBlot) {
            prevTextBlot.insertAt(prevTextBlot.length(), newText + nextText);
            if (nextTextBlot) {
              nextTextBlot.remove();
            }
          }
        } else if (nextTextBlot) {
          mergedTextBlot = nextTextBlot;
          nextTextBlot.insertAt(0, newText);
        } else {
          const newTextNode = document.createTextNode(newText);
          mergedTextBlot = this.scroll.create(newTextNode);
          this.parent.insertBefore(mergedTextBlot, this);
        }
        this.remove();
        if (range) {
          const remapOffset = (node, offset) => {
            if (prevTextBlot && node === prevTextBlot.domNode) {
              return offset;
            }
            if (node === textNode) {
              return prevTextLength + offset - 1;
            }
            if (nextTextBlot && node === nextTextBlot.domNode) {
              return prevTextLength + newText.length + offset;
            }
            return null;
          };
          const start = remapOffset(range.start.node, range.start.offset);
          const end = remapOffset(range.end.node, range.end.offset);
          if (start !== null && end !== null) {
            return {
              startNode: mergedTextBlot.domNode,
              startOffset: start,
              endNode: mergedTextBlot.domNode,
              endOffset: end
            };
          }
        }
        return null;
      }
      update(mutations, context) {
        if (mutations.some((mutation) => {
          return mutation.type === "characterData" && mutation.target === this.textNode;
        })) {
          const range = this.restore();
          if (range) context.range = range;
        }
      }
      // Avoid .ql-cursor being a descendant of `<a/>`.
      // The reason is Safari pushes down `<a/>` on text insertion.
      // That will cause DOM nodes not sync with the model.
      //
      // For example ({I} is the caret), given the markup:
      //    <a><span class="ql-cursor">\uFEFF{I}</span></a>
      // When typing a char "x", `<a/>` will be pushed down inside the `<span>` first:
      //    <span class="ql-cursor"><a>\uFEFF{I}</a></span>
      // And then "x" will be inserted after `<a/>`:
      //    <span class="ql-cursor"><a>\uFEFF</a>d{I}</span>
      optimize(context) {
        super.optimize(context);
        let {
          parent
        } = this;
        while (parent) {
          if (parent.domNode.tagName === "A") {
            this.savedLength = _Cursor.CONTENTS.length;
            parent.isolate(this.offset(parent), this.length()).unwrap();
            this.savedLength = 0;
            break;
          }
          parent = parent.parent;
        }
      }
      value() {
        return "";
      }
    };
    __publicField(_Cursor, "blotName", "cursor");
    __publicField(_Cursor, "className", "ql-cursor");
    __publicField(_Cursor, "tagName", "span");
    __publicField(_Cursor, "CONTENTS", "\uFEFF");
    let Cursor = _Cursor;
    var eventemitter3 = { exports: {} };
    var hasRequiredEventemitter3;
    function requireEventemitter3() {
      if (hasRequiredEventemitter3) return eventemitter3.exports;
      hasRequiredEventemitter3 = 1;
      (function(module2) {
        var has = Object.prototype.hasOwnProperty, prefix = "~";
        function Events() {
        }
        if (Object.create) {
          Events.prototype = /* @__PURE__ */ Object.create(null);
          if (!new Events().__proto__) prefix = false;
        }
        function EE(fn, context, once) {
          this.fn = fn;
          this.context = context;
          this.once = once || false;
        }
        function addListener(emitter, event, fn, context, once) {
          if (typeof fn !== "function") {
            throw new TypeError("The listener must be a function");
          }
          var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
          if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
          else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
          else emitter._events[evt] = [emitter._events[evt], listener];
          return emitter;
        }
        function clearEvent(emitter, evt) {
          if (--emitter._eventsCount === 0) emitter._events = new Events();
          else delete emitter._events[evt];
        }
        function EventEmitter2() {
          this._events = new Events();
          this._eventsCount = 0;
        }
        EventEmitter2.prototype.eventNames = function eventNames() {
          var names2 = [], events, name2;
          if (this._eventsCount === 0) return names2;
          for (name2 in events = this._events) {
            if (has.call(events, name2)) names2.push(prefix ? name2.slice(1) : name2);
          }
          if (Object.getOwnPropertySymbols) {
            return names2.concat(Object.getOwnPropertySymbols(events));
          }
          return names2;
        };
        EventEmitter2.prototype.listeners = function listeners(event) {
          var evt = prefix ? prefix + event : event, handlers = this._events[evt];
          if (!handlers) return [];
          if (handlers.fn) return [handlers.fn];
          for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
            ee[i] = handlers[i].fn;
          }
          return ee;
        };
        EventEmitter2.prototype.listenerCount = function listenerCount(event) {
          var evt = prefix ? prefix + event : event, listeners = this._events[evt];
          if (!listeners) return 0;
          if (listeners.fn) return 1;
          return listeners.length;
        };
        EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
          var evt = prefix ? prefix + event : event;
          if (!this._events[evt]) return false;
          var listeners = this._events[evt], len = arguments.length, args, i;
          if (listeners.fn) {
            if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
            switch (len) {
              case 1:
                return listeners.fn.call(listeners.context), true;
              case 2:
                return listeners.fn.call(listeners.context, a1), true;
              case 3:
                return listeners.fn.call(listeners.context, a1, a2), true;
              case 4:
                return listeners.fn.call(listeners.context, a1, a2, a3), true;
              case 5:
                return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
              case 6:
                return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
            }
            for (i = 1, args = new Array(len - 1); i < len; i++) {
              args[i - 1] = arguments[i];
            }
            listeners.fn.apply(listeners.context, args);
          } else {
            var length = listeners.length, j;
            for (i = 0; i < length; i++) {
              if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
              switch (len) {
                case 1:
                  listeners[i].fn.call(listeners[i].context);
                  break;
                case 2:
                  listeners[i].fn.call(listeners[i].context, a1);
                  break;
                case 3:
                  listeners[i].fn.call(listeners[i].context, a1, a2);
                  break;
                case 4:
                  listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                  break;
                default:
                  if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                    args[j - 1] = arguments[j];
                  }
                  listeners[i].fn.apply(listeners[i].context, args);
              }
            }
          }
          return true;
        };
        EventEmitter2.prototype.on = function on(event, fn, context) {
          return addListener(this, event, fn, context, false);
        };
        EventEmitter2.prototype.once = function once(event, fn, context) {
          return addListener(this, event, fn, context, true);
        };
        EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
          var evt = prefix ? prefix + event : event;
          if (!this._events[evt]) return this;
          if (!fn) {
            clearEvent(this, evt);
            return this;
          }
          var listeners = this._events[evt];
          if (listeners.fn) {
            if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
              clearEvent(this, evt);
            }
          } else {
            for (var i = 0, events = [], length = listeners.length; i < length; i++) {
              if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
                events.push(listeners[i]);
              }
            }
            if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
            else clearEvent(this, evt);
          }
          return this;
        };
        EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
          var evt;
          if (event) {
            evt = prefix ? prefix + event : event;
            if (this._events[evt]) clearEvent(this, evt);
          } else {
            this._events = new Events();
            this._eventsCount = 0;
          }
          return this;
        };
        EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
        EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
        EventEmitter2.prefixed = prefix;
        EventEmitter2.EventEmitter = EventEmitter2;
        {
          module2.exports = EventEmitter2;
        }
      })(eventemitter3);
      return eventemitter3.exports;
    }
    var eventemitter3Exports = requireEventemitter3();
    const EventEmitter = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
    const instances = /* @__PURE__ */ new WeakMap();
    const levels = ["error", "warn", "log", "info"];
    let level = "warn";
    function debug$6(method) {
      if (level) {
        if (levels.indexOf(method) <= levels.indexOf(level)) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          console[method](...args);
        }
      }
    }
    function namespace(ns) {
      return levels.reduce((logger, method) => {
        logger[method] = debug$6.bind(console, method, ns);
        return logger;
      }, {});
    }
    namespace.level = (newLevel) => {
      level = newLevel;
    };
    debug$6.level = namespace.level;
    const debug$5 = namespace("quill:events");
    const EVENTS = ["selectionchange", "mousedown", "mouseup", "click"];
    EVENTS.forEach((eventName) => {
      document.addEventListener(eventName, function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        Array.from(document.querySelectorAll(".ql-container")).forEach((node) => {
          const quill = instances.get(node);
          if (quill && quill.emitter) {
            quill.emitter.handleDOM(...args);
          }
        });
      });
    });
    class Emitter extends EventEmitter {
      constructor() {
        super();
        this.domListeners = {};
        this.on("error", debug$5.error);
      }
      emit() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        debug$5.log.call(debug$5, ...args);
        return super.emit(...args);
      }
      handleDOM(event) {
        for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          args[_key3 - 1] = arguments[_key3];
        }
        (this.domListeners[event.type] || []).forEach((_ref) => {
          let {
            node,
            handler
          } = _ref;
          if (event.target === node || node.contains(event.target)) {
            handler(event, ...args);
          }
        });
      }
      listenDOM(eventName, node, handler) {
        if (!this.domListeners[eventName]) {
          this.domListeners[eventName] = [];
        }
        this.domListeners[eventName].push({
          node,
          handler
        });
      }
    }
    __publicField(Emitter, "events", {
      EDITOR_CHANGE: "editor-change",
      SCROLL_BEFORE_UPDATE: "scroll-before-update",
      SCROLL_BLOT_MOUNT: "scroll-blot-mount",
      SCROLL_BLOT_UNMOUNT: "scroll-blot-unmount",
      SCROLL_OPTIMIZE: "scroll-optimize",
      SCROLL_UPDATE: "scroll-update",
      SCROLL_EMBED_UPDATE: "scroll-embed-update",
      SELECTION_CHANGE: "selection-change",
      TEXT_CHANGE: "text-change",
      COMPOSITION_BEFORE_START: "composition-before-start",
      COMPOSITION_START: "composition-start",
      COMPOSITION_BEFORE_END: "composition-before-end",
      COMPOSITION_END: "composition-end"
    });
    __publicField(Emitter, "sources", {
      API: "api",
      SILENT: "silent",
      USER: "user"
    });
    const debug$4 = namespace("quill:selection");
    class Range {
      constructor(index) {
        let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        this.index = index;
        this.length = length;
      }
    }
    class Selection {
      constructor(scroll, emitter) {
        this.emitter = emitter;
        this.scroll = scroll;
        this.composing = false;
        this.mouseDown = false;
        this.root = this.scroll.domNode;
        this.cursor = this.scroll.create("cursor", this);
        this.savedRange = new Range(0, 0);
        this.lastRange = this.savedRange;
        this.lastNative = null;
        this.handleComposition();
        this.handleDragging();
        this.emitter.listenDOM("selectionchange", document, () => {
          if (!this.mouseDown && !this.composing) {
            setTimeout(this.update.bind(this, Emitter.sources.USER), 1);
          }
        });
        this.emitter.on(Emitter.events.SCROLL_BEFORE_UPDATE, () => {
          if (!this.hasFocus()) return;
          const native = this.getNativeRange();
          if (native == null) return;
          if (native.start.node === this.cursor.textNode) return;
          this.emitter.once(Emitter.events.SCROLL_UPDATE, (source, mutations) => {
            try {
              if (this.root.contains(native.start.node) && this.root.contains(native.end.node)) {
                this.setNativeRange(native.start.node, native.start.offset, native.end.node, native.end.offset);
              }
              const triggeredByTyping = mutations.some((mutation) => mutation.type === "characterData" || mutation.type === "childList" || mutation.type === "attributes" && mutation.target === this.root);
              this.update(triggeredByTyping ? Emitter.sources.SILENT : source);
            } catch (ignored) {
            }
          });
        });
        this.emitter.on(Emitter.events.SCROLL_OPTIMIZE, (mutations, context) => {
          if (context.range) {
            const {
              startNode,
              startOffset,
              endNode,
              endOffset
            } = context.range;
            this.setNativeRange(startNode, startOffset, endNode, endOffset);
            this.update(Emitter.sources.SILENT);
          }
        });
        this.update(Emitter.sources.SILENT);
      }
      handleComposition() {
        this.emitter.on(Emitter.events.COMPOSITION_BEFORE_START, () => {
          this.composing = true;
        });
        this.emitter.on(Emitter.events.COMPOSITION_END, () => {
          this.composing = false;
          if (this.cursor.parent) {
            const range = this.cursor.restore();
            if (!range) return;
            setTimeout(() => {
              this.setNativeRange(range.startNode, range.startOffset, range.endNode, range.endOffset);
            }, 1);
          }
        });
      }
      handleDragging() {
        this.emitter.listenDOM("mousedown", document.body, () => {
          this.mouseDown = true;
        });
        this.emitter.listenDOM("mouseup", document.body, () => {
          this.mouseDown = false;
          this.update(Emitter.sources.USER);
        });
      }
      focus() {
        if (this.hasFocus()) return;
        this.root.focus({
          preventScroll: true
        });
        this.setRange(this.savedRange);
      }
      format(format, value2) {
        this.scroll.update();
        const nativeRange = this.getNativeRange();
        if (nativeRange == null || !nativeRange.native.collapsed || this.scroll.query(format, Scope.BLOCK)) return;
        if (nativeRange.start.node !== this.cursor.textNode) {
          const blot = this.scroll.find(nativeRange.start.node, false);
          if (blot == null) return;
          if (blot instanceof LeafBlot$1) {
            const after = blot.split(nativeRange.start.offset);
            blot.parent.insertBefore(this.cursor, after);
          } else {
            blot.insertBefore(this.cursor, nativeRange.start.node);
          }
          this.cursor.attach();
        }
        this.cursor.format(format, value2);
        this.scroll.optimize();
        this.setNativeRange(this.cursor.textNode, this.cursor.textNode.data.length);
        this.update();
      }
      getBounds(index) {
        let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        const scrollLength = this.scroll.length();
        index = Math.min(index, scrollLength - 1);
        length = Math.min(index + length, scrollLength - 1) - index;
        let node;
        let [leaf, offset] = this.scroll.leaf(index);
        if (leaf == null) return null;
        if (length > 0 && offset === leaf.length()) {
          const [next] = this.scroll.leaf(index + 1);
          if (next) {
            const [line] = this.scroll.line(index);
            const [nextLine] = this.scroll.line(index + 1);
            if (line === nextLine) {
              leaf = next;
              offset = 0;
            }
          }
        }
        [node, offset] = leaf.position(offset, true);
        const range = document.createRange();
        if (length > 0) {
          range.setStart(node, offset);
          [leaf, offset] = this.scroll.leaf(index + length);
          if (leaf == null) return null;
          [node, offset] = leaf.position(offset, true);
          range.setEnd(node, offset);
          return range.getBoundingClientRect();
        }
        let side = "left";
        let rect;
        if (node instanceof Text) {
          if (!node.data.length) {
            return null;
          }
          if (offset < node.data.length) {
            range.setStart(node, offset);
            range.setEnd(node, offset + 1);
          } else {
            range.setStart(node, offset - 1);
            range.setEnd(node, offset);
            side = "right";
          }
          rect = range.getBoundingClientRect();
        } else {
          if (!(leaf.domNode instanceof Element)) return null;
          rect = leaf.domNode.getBoundingClientRect();
          if (offset > 0) side = "right";
        }
        return {
          bottom: rect.top + rect.height,
          height: rect.height,
          left: rect[side],
          right: rect[side],
          top: rect.top,
          width: 0
        };
      }
      getNativeRange() {
        const selection = document.getSelection();
        if (selection == null || selection.rangeCount <= 0) return null;
        const nativeRange = selection.getRangeAt(0);
        if (nativeRange == null) return null;
        const range = this.normalizeNative(nativeRange);
        debug$4.info("getNativeRange", range);
        return range;
      }
      getRange() {
        const root2 = this.scroll.domNode;
        if ("isConnected" in root2 && !root2.isConnected) {
          return [null, null];
        }
        const normalized = this.getNativeRange();
        if (normalized == null) return [null, null];
        const range = this.normalizedToRange(normalized);
        return [range, normalized];
      }
      hasFocus() {
        return document.activeElement === this.root || document.activeElement != null && contains(this.root, document.activeElement);
      }
      normalizedToRange(range) {
        const positions = [[range.start.node, range.start.offset]];
        if (!range.native.collapsed) {
          positions.push([range.end.node, range.end.offset]);
        }
        const indexes = positions.map((position) => {
          const [node, offset] = position;
          const blot = this.scroll.find(node, true);
          const index = blot.offset(this.scroll);
          if (offset === 0) {
            return index;
          }
          if (blot instanceof LeafBlot$1) {
            return index + blot.index(node, offset);
          }
          return index + blot.length();
        });
        const end = Math.min(Math.max(...indexes), this.scroll.length() - 1);
        const start = Math.min(end, ...indexes);
        return new Range(start, end - start);
      }
      normalizeNative(nativeRange) {
        if (!contains(this.root, nativeRange.startContainer) || !nativeRange.collapsed && !contains(this.root, nativeRange.endContainer)) {
          return null;
        }
        const range = {
          start: {
            node: nativeRange.startContainer,
            offset: nativeRange.startOffset
          },
          end: {
            node: nativeRange.endContainer,
            offset: nativeRange.endOffset
          },
          native: nativeRange
        };
        [range.start, range.end].forEach((position) => {
          let {
            node,
            offset
          } = position;
          while (!(node instanceof Text) && node.childNodes.length > 0) {
            if (node.childNodes.length > offset) {
              node = node.childNodes[offset];
              offset = 0;
            } else if (node.childNodes.length === offset) {
              node = node.lastChild;
              if (node instanceof Text) {
                offset = node.data.length;
              } else if (node.childNodes.length > 0) {
                offset = node.childNodes.length;
              } else {
                offset = node.childNodes.length + 1;
              }
            } else {
              break;
            }
          }
          position.node = node;
          position.offset = offset;
        });
        return range;
      }
      rangeToNative(range) {
        const scrollLength = this.scroll.length();
        const getPosition = (index, inclusive) => {
          index = Math.min(scrollLength - 1, index);
          const [leaf, leafOffset] = this.scroll.leaf(index);
          return leaf ? leaf.position(leafOffset, inclusive) : [null, -1];
        };
        return [...getPosition(range.index, false), ...getPosition(range.index + range.length, true)];
      }
      setNativeRange(startNode, startOffset) {
        let endNode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : startNode;
        let endOffset = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : startOffset;
        let force = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
        debug$4.info("setNativeRange", startNode, startOffset, endNode, endOffset);
        if (startNode != null && (this.root.parentNode == null || startNode.parentNode == null || // @ts-expect-error Fix me later
        endNode.parentNode == null)) {
          return;
        }
        const selection = document.getSelection();
        if (selection == null) return;
        if (startNode != null) {
          if (!this.hasFocus()) this.root.focus({
            preventScroll: true
          });
          const {
            native
          } = this.getNativeRange() || {};
          if (native == null || force || startNode !== native.startContainer || startOffset !== native.startOffset || endNode !== native.endContainer || endOffset !== native.endOffset) {
            if (startNode instanceof Element && startNode.tagName === "BR") {
              startOffset = Array.from(startNode.parentNode.childNodes).indexOf(startNode);
              startNode = startNode.parentNode;
            }
            if (endNode instanceof Element && endNode.tagName === "BR") {
              endOffset = Array.from(endNode.parentNode.childNodes).indexOf(endNode);
              endNode = endNode.parentNode;
            }
            const range = document.createRange();
            range.setStart(startNode, startOffset);
            range.setEnd(endNode, endOffset);
            selection.removeAllRanges();
            selection.addRange(range);
          }
        } else {
          selection.removeAllRanges();
          this.root.blur();
        }
      }
      setRange(range) {
        let force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        let source = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Emitter.sources.API;
        if (typeof force === "string") {
          source = force;
          force = false;
        }
        debug$4.info("setRange", range);
        if (range != null) {
          const args = this.rangeToNative(range);
          this.setNativeRange(...args, force);
        } else {
          this.setNativeRange(null);
        }
        this.update(source);
      }
      update() {
        let source = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Emitter.sources.USER;
        const oldRange = this.lastRange;
        const [lastRange, nativeRange] = this.getRange();
        this.lastRange = lastRange;
        this.lastNative = nativeRange;
        if (this.lastRange != null) {
          this.savedRange = this.lastRange;
        }
        if (!isEqual$1(oldRange, this.lastRange)) {
          if (!this.composing && nativeRange != null && nativeRange.native.collapsed && nativeRange.start.node !== this.cursor.textNode) {
            const range = this.cursor.restore();
            if (range) {
              this.setNativeRange(range.startNode, range.startOffset, range.endNode, range.endOffset);
            }
          }
          const args = [Emitter.events.SELECTION_CHANGE, cloneDeep(this.lastRange), cloneDeep(oldRange), source];
          this.emitter.emit(Emitter.events.EDITOR_CHANGE, ...args);
          if (source !== Emitter.sources.SILENT) {
            this.emitter.emit(...args);
          }
        }
      }
    }
    function contains(parent, descendant) {
      try {
        descendant.parentNode;
      } catch (e) {
        return false;
      }
      return parent.contains(descendant);
    }
    const ASCII = /^[ -~]*$/;
    class Editor {
      constructor(scroll) {
        this.scroll = scroll;
        this.delta = this.getDelta();
      }
      applyDelta(delta) {
        this.scroll.update();
        let scrollLength = this.scroll.length();
        this.scroll.batchStart();
        const normalizedDelta = normalizeDelta(delta);
        const deleteDelta = new Delta();
        const normalizedOps = splitOpLines(normalizedDelta.ops.slice());
        normalizedOps.reduce((index, op) => {
          const length = DeltaExports.Op.length(op);
          let attributes = op.attributes || {};
          let isImplicitNewlinePrepended = false;
          let isImplicitNewlineAppended = false;
          if (op.insert != null) {
            deleteDelta.retain(length);
            if (typeof op.insert === "string") {
              const text = op.insert;
              isImplicitNewlineAppended = !text.endsWith("\n") && (scrollLength <= index || !!this.scroll.descendant(BlockEmbed, index)[0]);
              this.scroll.insertAt(index, text);
              const [line, offset] = this.scroll.line(index);
              let formats = merge({}, bubbleFormats(line));
              if (line instanceof Block) {
                const [leaf] = line.descendant(LeafBlot$1, offset);
                if (leaf) {
                  formats = merge(formats, bubbleFormats(leaf));
                }
              }
              attributes = DeltaExports.AttributeMap.diff(formats, attributes) || {};
            } else if (typeof op.insert === "object") {
              const key = Object.keys(op.insert)[0];
              if (key == null) return index;
              const isInlineEmbed = this.scroll.query(key, Scope.INLINE) != null;
              if (isInlineEmbed) {
                if (scrollLength <= index || !!this.scroll.descendant(BlockEmbed, index)[0]) {
                  isImplicitNewlineAppended = true;
                }
              } else if (index > 0) {
                const [leaf, offset] = this.scroll.descendant(LeafBlot$1, index - 1);
                if (leaf instanceof Text$1) {
                  const text = leaf.value();
                  if (text[offset] !== "\n") {
                    isImplicitNewlinePrepended = true;
                  }
                } else if (leaf instanceof EmbedBlot$1 && leaf.statics.scope === Scope.INLINE_BLOT) {
                  isImplicitNewlinePrepended = true;
                }
              }
              this.scroll.insertAt(index, key, op.insert[key]);
              if (isInlineEmbed) {
                const [leaf] = this.scroll.descendant(LeafBlot$1, index);
                if (leaf) {
                  const formats = merge({}, bubbleFormats(leaf));
                  attributes = DeltaExports.AttributeMap.diff(formats, attributes) || {};
                }
              }
            }
            scrollLength += length;
          } else {
            deleteDelta.push(op);
            if (op.retain !== null && typeof op.retain === "object") {
              const key = Object.keys(op.retain)[0];
              if (key == null) return index;
              this.scroll.updateEmbedAt(index, key, op.retain[key]);
            }
          }
          Object.keys(attributes).forEach((name2) => {
            this.scroll.formatAt(index, length, name2, attributes[name2]);
          });
          const prependedLength = isImplicitNewlinePrepended ? 1 : 0;
          const addedLength = isImplicitNewlineAppended ? 1 : 0;
          scrollLength += prependedLength + addedLength;
          deleteDelta.retain(prependedLength);
          deleteDelta.delete(addedLength);
          return index + length + prependedLength + addedLength;
        }, 0);
        deleteDelta.reduce((index, op) => {
          if (typeof op.delete === "number") {
            this.scroll.deleteAt(index, op.delete);
            return index;
          }
          return index + DeltaExports.Op.length(op);
        }, 0);
        this.scroll.batchEnd();
        this.scroll.optimize();
        return this.update(normalizedDelta);
      }
      deleteText(index, length) {
        this.scroll.deleteAt(index, length);
        return this.update(new Delta().retain(index).delete(length));
      }
      formatLine(index, length) {
        let formats = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        this.scroll.update();
        Object.keys(formats).forEach((format) => {
          this.scroll.lines(index, Math.max(length, 1)).forEach((line) => {
            line.format(format, formats[format]);
          });
        });
        this.scroll.optimize();
        const delta = new Delta().retain(index).retain(length, cloneDeep(formats));
        return this.update(delta);
      }
      formatText(index, length) {
        let formats = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Object.keys(formats).forEach((format) => {
          this.scroll.formatAt(index, length, format, formats[format]);
        });
        const delta = new Delta().retain(index).retain(length, cloneDeep(formats));
        return this.update(delta);
      }
      getContents(index, length) {
        return this.delta.slice(index, index + length);
      }
      getDelta() {
        return this.scroll.lines().reduce((delta, line) => {
          return delta.concat(line.delta());
        }, new Delta());
      }
      getFormat(index) {
        let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        let lines = [];
        let leaves = [];
        if (length === 0) {
          this.scroll.path(index).forEach((path) => {
            const [blot] = path;
            if (blot instanceof Block) {
              lines.push(blot);
            } else if (blot instanceof LeafBlot$1) {
              leaves.push(blot);
            }
          });
        } else {
          lines = this.scroll.lines(index, length);
          leaves = this.scroll.descendants(LeafBlot$1, index, length);
        }
        const [lineFormats, leafFormats] = [lines, leaves].map((blots) => {
          const blot = blots.shift();
          if (blot == null) return {};
          let formats = bubbleFormats(blot);
          while (Object.keys(formats).length > 0) {
            const blot2 = blots.shift();
            if (blot2 == null) return formats;
            formats = combineFormats(bubbleFormats(blot2), formats);
          }
          return formats;
        });
        return {
          ...lineFormats,
          ...leafFormats
        };
      }
      getHTML(index, length) {
        const [line, lineOffset] = this.scroll.line(index);
        if (line) {
          const lineLength = line.length();
          const isWithinLine = line.length() >= lineOffset + length;
          if (isWithinLine && !(lineOffset === 0 && length === lineLength)) {
            return convertHTML(line, lineOffset, length, true);
          }
          return convertHTML(this.scroll, index, length, true);
        }
        return "";
      }
      getText(index, length) {
        return this.getContents(index, length).filter((op) => typeof op.insert === "string").map((op) => op.insert).join("");
      }
      insertContents(index, contents) {
        const normalizedDelta = normalizeDelta(contents);
        const change = new Delta().retain(index).concat(normalizedDelta);
        this.scroll.insertContents(index, normalizedDelta);
        return this.update(change);
      }
      insertEmbed(index, embed, value2) {
        this.scroll.insertAt(index, embed, value2);
        return this.update(new Delta().retain(index).insert({
          [embed]: value2
        }));
      }
      insertText(index, text) {
        let formats = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        text = text.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
        this.scroll.insertAt(index, text);
        Object.keys(formats).forEach((format) => {
          this.scroll.formatAt(index, text.length, format, formats[format]);
        });
        return this.update(new Delta().retain(index).insert(text, cloneDeep(formats)));
      }
      isBlank() {
        if (this.scroll.children.length === 0) return true;
        if (this.scroll.children.length > 1) return false;
        const blot = this.scroll.children.head;
        if ((blot == null ? void 0 : blot.statics.blotName) !== Block.blotName) return false;
        const block = blot;
        if (block.children.length > 1) return false;
        return block.children.head instanceof Break;
      }
      removeFormat(index, length) {
        const text = this.getText(index, length);
        const [line, offset] = this.scroll.line(index + length);
        let suffixLength = 0;
        let suffix = new Delta();
        if (line != null) {
          suffixLength = line.length() - offset;
          suffix = line.delta().slice(offset, offset + suffixLength - 1).insert("\n");
        }
        const contents = this.getContents(index, length + suffixLength);
        const diff = contents.diff(new Delta().insert(text).concat(suffix));
        const delta = new Delta().retain(index).concat(diff);
        return this.applyDelta(delta);
      }
      update(change) {
        let mutations = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
        let selectionInfo = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
        const oldDelta = this.delta;
        if (mutations.length === 1 && mutations[0].type === "characterData" && // @ts-expect-error Fix me later
        mutations[0].target.data.match(ASCII) && this.scroll.find(mutations[0].target)) {
          const textBlot = this.scroll.find(mutations[0].target);
          const formats = bubbleFormats(textBlot);
          const index = textBlot.offset(this.scroll);
          const oldValue = mutations[0].oldValue.replace(Cursor.CONTENTS, "");
          const oldText = new Delta().insert(oldValue);
          const newText = new Delta().insert(textBlot.value());
          const relativeSelectionInfo = selectionInfo && {
            oldRange: shiftRange$1(selectionInfo.oldRange, -index),
            newRange: shiftRange$1(selectionInfo.newRange, -index)
          };
          const diffDelta = new Delta().retain(index).concat(oldText.diff(newText, relativeSelectionInfo));
          change = diffDelta.reduce((delta, op) => {
            if (op.insert) {
              return delta.insert(op.insert, formats);
            }
            return delta.push(op);
          }, new Delta());
          this.delta = oldDelta.compose(change);
        } else {
          this.delta = this.getDelta();
          if (!change || !isEqual$1(oldDelta.compose(change), this.delta)) {
            change = oldDelta.diff(this.delta, selectionInfo);
          }
        }
        return change;
      }
    }
    function convertListHTML(items, lastIndent, types) {
      if (items.length === 0) {
        const [endTag2] = getListType(types.pop());
        if (lastIndent <= 0) {
          return `</li></${endTag2}>`;
        }
        return `</li></${endTag2}>${convertListHTML([], lastIndent - 1, types)}`;
      }
      const [{
        child,
        offset,
        length,
        indent,
        type
      }, ...rest] = items;
      const [tag, attribute] = getListType(type);
      if (indent > lastIndent) {
        types.push(type);
        if (indent === lastIndent + 1) {
          return `<${tag}><li${attribute}>${convertHTML(child, offset, length)}${convertListHTML(rest, indent, types)}`;
        }
        return `<${tag}><li>${convertListHTML(items, lastIndent + 1, types)}`;
      }
      const previousType = types[types.length - 1];
      if (indent === lastIndent && type === previousType) {
        return `</li><li${attribute}>${convertHTML(child, offset, length)}${convertListHTML(rest, indent, types)}`;
      }
      const [endTag] = getListType(types.pop());
      return `</li></${endTag}>${convertListHTML(items, lastIndent - 1, types)}`;
    }
    function convertHTML(blot, index, length) {
      let isRoot = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      if ("html" in blot && typeof blot.html === "function") {
        return blot.html(index, length);
      }
      if (blot instanceof Text$1) {
        const escapedText = escapeText(blot.value().slice(index, index + length));
        return escapedText.replaceAll(" ", "&nbsp;");
      }
      if (blot instanceof ParentBlot$1) {
        if (blot.statics.blotName === "list-container") {
          const items = [];
          blot.children.forEachAt(index, length, (child, offset, childLength) => {
            const formats = "formats" in child && typeof child.formats === "function" ? child.formats() : {};
            items.push({
              child,
              offset,
              length: childLength,
              indent: formats.indent || 0,
              type: formats.list
            });
          });
          return convertListHTML(items, -1, []);
        }
        const parts = [];
        blot.children.forEachAt(index, length, (child, offset, childLength) => {
          parts.push(convertHTML(child, offset, childLength));
        });
        if (isRoot || blot.statics.blotName === "list") {
          return parts.join("");
        }
        const {
          outerHTML,
          innerHTML
        } = blot.domNode;
        const [start, end] = outerHTML.split(`>${innerHTML}<`);
        if (start === "<table") {
          return `<table style="border: 1px solid #000;">${parts.join("")}<${end}`;
        }
        return `${start}>${parts.join("")}<${end}`;
      }
      return blot.domNode instanceof Element ? blot.domNode.outerHTML : "";
    }
    function combineFormats(formats, combined) {
      return Object.keys(combined).reduce((merged, name2) => {
        if (formats[name2] == null) return merged;
        const combinedValue = combined[name2];
        if (combinedValue === formats[name2]) {
          merged[name2] = combinedValue;
        } else if (Array.isArray(combinedValue)) {
          if (combinedValue.indexOf(formats[name2]) < 0) {
            merged[name2] = combinedValue.concat([formats[name2]]);
          } else {
            merged[name2] = combinedValue;
          }
        } else {
          merged[name2] = [combinedValue, formats[name2]];
        }
        return merged;
      }, {});
    }
    function getListType(type) {
      const tag = type === "ordered" ? "ol" : "ul";
      switch (type) {
        case "checked":
          return [tag, ' data-list="checked"'];
        case "unchecked":
          return [tag, ' data-list="unchecked"'];
        default:
          return [tag, ""];
      }
    }
    function normalizeDelta(delta) {
      return delta.reduce((normalizedDelta, op) => {
        if (typeof op.insert === "string") {
          const text = op.insert.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
          return normalizedDelta.insert(text, op.attributes);
        }
        return normalizedDelta.push(op);
      }, new Delta());
    }
    function shiftRange$1(_ref, amount) {
      let {
        index,
        length
      } = _ref;
      return new Range(index + amount, length);
    }
    function splitOpLines(ops) {
      const split = [];
      ops.forEach((op) => {
        if (typeof op.insert === "string") {
          const lines = op.insert.split("\n");
          lines.forEach((line, index) => {
            if (index) split.push({
              insert: "\n",
              attributes: op.attributes
            });
            if (line) split.push({
              insert: line,
              attributes: op.attributes
            });
          });
        } else {
          split.push(op);
        }
      });
      return split;
    }
    class Module {
      constructor(quill) {
        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        this.quill = quill;
        this.options = options;
      }
    }
    __publicField(Module, "DEFAULTS", {});
    const GUARD_TEXT = "\uFEFF";
    class Embed extends EmbedBlot$1 {
      constructor(scroll, node) {
        super(scroll, node);
        this.contentNode = document.createElement("span");
        this.contentNode.setAttribute("contenteditable", "false");
        Array.from(this.domNode.childNodes).forEach((childNode) => {
          this.contentNode.appendChild(childNode);
        });
        this.leftGuard = document.createTextNode(GUARD_TEXT);
        this.rightGuard = document.createTextNode(GUARD_TEXT);
        this.domNode.appendChild(this.leftGuard);
        this.domNode.appendChild(this.contentNode);
        this.domNode.appendChild(this.rightGuard);
      }
      index(node, offset) {
        if (node === this.leftGuard) return 0;
        if (node === this.rightGuard) return 1;
        return super.index(node, offset);
      }
      restore(node) {
        let range = null;
        let textNode;
        const text = node.data.split(GUARD_TEXT).join("");
        if (node === this.leftGuard) {
          if (this.prev instanceof Text$1) {
            const prevLength = this.prev.length();
            this.prev.insertAt(prevLength, text);
            range = {
              startNode: this.prev.domNode,
              startOffset: prevLength + text.length
            };
          } else {
            textNode = document.createTextNode(text);
            this.parent.insertBefore(this.scroll.create(textNode), this);
            range = {
              startNode: textNode,
              startOffset: text.length
            };
          }
        } else if (node === this.rightGuard) {
          if (this.next instanceof Text$1) {
            this.next.insertAt(0, text);
            range = {
              startNode: this.next.domNode,
              startOffset: text.length
            };
          } else {
            textNode = document.createTextNode(text);
            this.parent.insertBefore(this.scroll.create(textNode), this.next);
            range = {
              startNode: textNode,
              startOffset: text.length
            };
          }
        }
        node.data = GUARD_TEXT;
        return range;
      }
      update(mutations, context) {
        mutations.forEach((mutation) => {
          if (mutation.type === "characterData" && (mutation.target === this.leftGuard || mutation.target === this.rightGuard)) {
            const range = this.restore(mutation.target);
            if (range) context.range = range;
          }
        });
      }
    }
    class Composition {
      constructor(scroll, emitter) {
        __publicField(this, "isComposing", false);
        this.scroll = scroll;
        this.emitter = emitter;
        this.setupListeners();
      }
      setupListeners() {
        this.scroll.domNode.addEventListener("compositionstart", (event) => {
          if (!this.isComposing) {
            this.handleCompositionStart(event);
          }
        });
        this.scroll.domNode.addEventListener("compositionend", (event) => {
          if (this.isComposing) {
            queueMicrotask(() => {
              this.handleCompositionEnd(event);
            });
          }
        });
      }
      handleCompositionStart(event) {
        const blot = event.target instanceof Node ? this.scroll.find(event.target, true) : null;
        if (blot && !(blot instanceof Embed)) {
          this.emitter.emit(Emitter.events.COMPOSITION_BEFORE_START, event);
          this.scroll.batchStart();
          this.emitter.emit(Emitter.events.COMPOSITION_START, event);
          this.isComposing = true;
        }
      }
      handleCompositionEnd(event) {
        this.emitter.emit(Emitter.events.COMPOSITION_BEFORE_END, event);
        this.scroll.batchEnd();
        this.emitter.emit(Emitter.events.COMPOSITION_END, event);
        this.isComposing = false;
      }
    }
    const _Theme = class _Theme {
      constructor(quill, options) {
        __publicField(this, "modules", {});
        this.quill = quill;
        this.options = options;
      }
      init() {
        Object.keys(this.options.modules).forEach((name2) => {
          if (this.modules[name2] == null) {
            this.addModule(name2);
          }
        });
      }
      addModule(name2) {
        const ModuleClass = this.quill.constructor.import(`modules/${name2}`);
        this.modules[name2] = new ModuleClass(this.quill, this.options.modules[name2] || {});
        return this.modules[name2];
      }
    };
    __publicField(_Theme, "DEFAULTS", {
      modules: {}
    });
    __publicField(_Theme, "themes", {
      default: _Theme
    });
    let Theme = _Theme;
    const getParentElement = (element) => element.parentElement || element.getRootNode().host || null;
    const getElementRect = (element) => {
      const rect = element.getBoundingClientRect();
      const scaleX = "offsetWidth" in element && Math.abs(rect.width) / element.offsetWidth || 1;
      const scaleY = "offsetHeight" in element && Math.abs(rect.height) / element.offsetHeight || 1;
      return {
        top: rect.top,
        right: rect.left + element.clientWidth * scaleX,
        bottom: rect.top + element.clientHeight * scaleY,
        left: rect.left
      };
    };
    const paddingValueToInt = (value2) => {
      const number = parseInt(value2, 10);
      return Number.isNaN(number) ? 0 : number;
    };
    const getScrollDistance = (targetStart, targetEnd, scrollStart, scrollEnd, scrollPaddingStart, scrollPaddingEnd) => {
      if (targetStart < scrollStart && targetEnd > scrollEnd) {
        return 0;
      }
      if (targetStart < scrollStart) {
        return -(scrollStart - targetStart + scrollPaddingStart);
      }
      if (targetEnd > scrollEnd) {
        return targetEnd - targetStart > scrollEnd - scrollStart ? targetStart + scrollPaddingStart - scrollStart : targetEnd - scrollEnd + scrollPaddingEnd;
      }
      return 0;
    };
    const scrollRectIntoView = (root2, targetRect) => {
      var _a2, _b, _c;
      const document2 = root2.ownerDocument;
      let rect = targetRect;
      let current = root2;
      while (current) {
        const isDocumentBody = current === document2.body;
        const bounding = isDocumentBody ? {
          top: 0,
          right: ((_a2 = window.visualViewport) == null ? void 0 : _a2.width) ?? document2.documentElement.clientWidth,
          bottom: ((_b = window.visualViewport) == null ? void 0 : _b.height) ?? document2.documentElement.clientHeight,
          left: 0
        } : getElementRect(current);
        const style = getComputedStyle(current);
        const scrollDistanceX = getScrollDistance(rect.left, rect.right, bounding.left, bounding.right, paddingValueToInt(style.scrollPaddingLeft), paddingValueToInt(style.scrollPaddingRight));
        const scrollDistanceY = getScrollDistance(rect.top, rect.bottom, bounding.top, bounding.bottom, paddingValueToInt(style.scrollPaddingTop), paddingValueToInt(style.scrollPaddingBottom));
        if (scrollDistanceX || scrollDistanceY) {
          if (isDocumentBody) {
            (_c = document2.defaultView) == null ? void 0 : _c.scrollBy(scrollDistanceX, scrollDistanceY);
          } else {
            const {
              scrollLeft,
              scrollTop
            } = current;
            if (scrollDistanceY) {
              current.scrollTop += scrollDistanceY;
            }
            if (scrollDistanceX) {
              current.scrollLeft += scrollDistanceX;
            }
            const scrolledLeft = current.scrollLeft - scrollLeft;
            const scrolledTop = current.scrollTop - scrollTop;
            rect = {
              left: rect.left - scrolledLeft,
              top: rect.top - scrolledTop,
              right: rect.right - scrolledLeft,
              bottom: rect.bottom - scrolledTop
            };
          }
        }
        current = isDocumentBody || style.position === "fixed" ? null : getParentElement(current);
      }
    };
    const MAX_REGISTER_ITERATIONS = 100;
    const CORE_FORMATS = ["block", "break", "cursor", "inline", "scroll", "text"];
    const createRegistryWithFormats = (formats, sourceRegistry, debug2) => {
      const registry = new Registry();
      CORE_FORMATS.forEach((name2) => {
        const coreBlot = sourceRegistry.query(name2);
        if (coreBlot) registry.register(coreBlot);
      });
      formats.forEach((name2) => {
        let format = sourceRegistry.query(name2);
        if (!format) {
          debug2.error(`Cannot register "${name2}" specified in "formats" config. Are you sure it was registered?`);
        }
        let iterations = 0;
        while (format) {
          registry.register(format);
          format = "blotName" in format ? format.requiredContainer ?? null : null;
          iterations += 1;
          if (iterations > MAX_REGISTER_ITERATIONS) {
            debug2.error(`Cycle detected in registering blot requiredContainer: "${name2}"`);
            break;
          }
        }
      });
      return registry;
    };
    const debug$3 = namespace("quill");
    const globalRegistry = new Registry();
    ParentBlot$1.uiClass = "ql-ui";
    const _Quill = class _Quill {
      static debug(limit) {
        if (limit === true) {
          limit = "log";
        }
        namespace.level(limit);
      }
      static find(node) {
        let bubble2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        return instances.get(node) || globalRegistry.find(node, bubble2);
      }
      static import(name2) {
        if (this.imports[name2] == null) {
          debug$3.error(`Cannot import ${name2}. Are you sure it was registered?`);
        }
        return this.imports[name2];
      }
      static register() {
        if (typeof (arguments.length <= 0 ? void 0 : arguments[0]) !== "string") {
          const target = arguments.length <= 0 ? void 0 : arguments[0];
          const overwrite = !!(arguments.length <= 1 ? void 0 : arguments[1]);
          const name2 = "attrName" in target ? target.attrName : target.blotName;
          if (typeof name2 === "string") {
            this.register(`formats/${name2}`, target, overwrite);
          } else {
            Object.keys(target).forEach((key) => {
              this.register(key, target[key], overwrite);
            });
          }
        } else {
          const path = arguments.length <= 0 ? void 0 : arguments[0];
          const target = arguments.length <= 1 ? void 0 : arguments[1];
          const overwrite = !!(arguments.length <= 2 ? void 0 : arguments[2]);
          if (this.imports[path] != null && !overwrite) {
            debug$3.warn(`Overwriting ${path} with`, target);
          }
          this.imports[path] = target;
          if ((path.startsWith("blots/") || path.startsWith("formats/")) && target && typeof target !== "boolean" && target.blotName !== "abstract") {
            globalRegistry.register(target);
          }
          if (typeof target.register === "function") {
            target.register(globalRegistry);
          }
        }
      }
      constructor(container) {
        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        this.options = expandConfig(container, options);
        this.container = this.options.container;
        if (this.container == null) {
          debug$3.error("Invalid Quill container", container);
          return;
        }
        if (this.options.debug) {
          _Quill.debug(this.options.debug);
        }
        const html = this.container.innerHTML.trim();
        this.container.classList.add("ql-container");
        this.container.innerHTML = "";
        instances.set(this.container, this);
        this.root = this.addContainer("ql-editor");
        this.root.classList.add("ql-blank");
        this.emitter = new Emitter();
        const scrollBlotName = ScrollBlot$1.blotName;
        const ScrollBlot2 = this.options.registry.query(scrollBlotName);
        if (!ScrollBlot2 || !("blotName" in ScrollBlot2)) {
          throw new Error(`Cannot initialize Quill without "${scrollBlotName}" blot`);
        }
        this.scroll = new ScrollBlot2(this.options.registry, this.root, {
          emitter: this.emitter
        });
        this.editor = new Editor(this.scroll);
        this.selection = new Selection(this.scroll, this.emitter);
        this.composition = new Composition(this.scroll, this.emitter);
        this.theme = new this.options.theme(this, this.options);
        this.keyboard = this.theme.addModule("keyboard");
        this.clipboard = this.theme.addModule("clipboard");
        this.history = this.theme.addModule("history");
        this.uploader = this.theme.addModule("uploader");
        this.theme.addModule("input");
        this.theme.addModule("uiNode");
        this.theme.init();
        this.emitter.on(Emitter.events.EDITOR_CHANGE, (type) => {
          if (type === Emitter.events.TEXT_CHANGE) {
            this.root.classList.toggle("ql-blank", this.editor.isBlank());
          }
        });
        this.emitter.on(Emitter.events.SCROLL_UPDATE, (source, mutations) => {
          const oldRange = this.selection.lastRange;
          const [newRange] = this.selection.getRange();
          const selectionInfo = oldRange && newRange ? {
            oldRange,
            newRange
          } : void 0;
          modify.call(this, () => this.editor.update(null, mutations, selectionInfo), source);
        });
        this.emitter.on(Emitter.events.SCROLL_EMBED_UPDATE, (blot, delta) => {
          const oldRange = this.selection.lastRange;
          const [newRange] = this.selection.getRange();
          const selectionInfo = oldRange && newRange ? {
            oldRange,
            newRange
          } : void 0;
          modify.call(this, () => {
            const change = new Delta().retain(blot.offset(this)).retain({
              [blot.statics.blotName]: delta
            });
            return this.editor.update(change, [], selectionInfo);
          }, _Quill.sources.USER);
        });
        if (html) {
          const contents = this.clipboard.convert({
            html: `${html}<p><br></p>`,
            text: "\n"
          });
          this.setContents(contents);
        }
        this.history.clear();
        if (this.options.placeholder) {
          this.root.setAttribute("data-placeholder", this.options.placeholder);
        }
        if (this.options.readOnly) {
          this.disable();
        }
        this.allowReadOnlyEdits = false;
      }
      addContainer(container) {
        let refNode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        if (typeof container === "string") {
          const className = container;
          container = document.createElement("div");
          container.classList.add(className);
        }
        this.container.insertBefore(container, refNode);
        return container;
      }
      blur() {
        this.selection.setRange(null);
      }
      deleteText(index, length, source) {
        [index, length, , source] = overload(index, length, source);
        return modify.call(this, () => {
          return this.editor.deleteText(index, length);
        }, source, index, -1 * length);
      }
      disable() {
        this.enable(false);
      }
      editReadOnly(modifier) {
        this.allowReadOnlyEdits = true;
        const value2 = modifier();
        this.allowReadOnlyEdits = false;
        return value2;
      }
      enable() {
        let enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        this.scroll.enable(enabled);
        this.container.classList.toggle("ql-disabled", !enabled);
      }
      focus() {
        let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        this.selection.focus();
        if (!options.preventScroll) {
          this.scrollSelectionIntoView();
        }
      }
      format(name2, value2) {
        let source = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Emitter.sources.API;
        return modify.call(this, () => {
          const range = this.getSelection(true);
          let change = new Delta();
          if (range == null) return change;
          if (this.scroll.query(name2, Scope.BLOCK)) {
            change = this.editor.formatLine(range.index, range.length, {
              [name2]: value2
            });
          } else if (range.length === 0) {
            this.selection.format(name2, value2);
            return change;
          } else {
            change = this.editor.formatText(range.index, range.length, {
              [name2]: value2
            });
          }
          this.setSelection(range, Emitter.sources.SILENT);
          return change;
        }, source);
      }
      formatLine(index, length, name2, value2, source) {
        let formats;
        [index, length, formats, source] = overload(
          index,
          length,
          // @ts-expect-error
          name2,
          value2,
          source
        );
        return modify.call(this, () => {
          return this.editor.formatLine(index, length, formats);
        }, source, index, 0);
      }
      formatText(index, length, name2, value2, source) {
        let formats;
        [index, length, formats, source] = overload(
          // @ts-expect-error
          index,
          length,
          name2,
          value2,
          source
        );
        return modify.call(this, () => {
          return this.editor.formatText(index, length, formats);
        }, source, index, 0);
      }
      getBounds(index) {
        let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        let bounds2 = null;
        if (typeof index === "number") {
          bounds2 = this.selection.getBounds(index, length);
        } else {
          bounds2 = this.selection.getBounds(index.index, index.length);
        }
        if (!bounds2) return null;
        const containerBounds = this.container.getBoundingClientRect();
        return {
          bottom: bounds2.bottom - containerBounds.top,
          height: bounds2.height,
          left: bounds2.left - containerBounds.left,
          right: bounds2.right - containerBounds.left,
          top: bounds2.top - containerBounds.top,
          width: bounds2.width
        };
      }
      getContents() {
        let index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.getLength() - index;
        [index, length] = overload(index, length);
        return this.editor.getContents(index, length);
      }
      getFormat() {
        let index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.getSelection(true);
        let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        if (typeof index === "number") {
          return this.editor.getFormat(index, length);
        }
        return this.editor.getFormat(index.index, index.length);
      }
      getIndex(blot) {
        return blot.offset(this.scroll);
      }
      getLength() {
        return this.scroll.length();
      }
      getLeaf(index) {
        return this.scroll.leaf(index);
      }
      getLine(index) {
        return this.scroll.line(index);
      }
      getLines() {
        let index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.MAX_VALUE;
        if (typeof index !== "number") {
          return this.scroll.lines(index.index, index.length);
        }
        return this.scroll.lines(index, length);
      }
      getModule(name2) {
        return this.theme.modules[name2];
      }
      getSelection() {
        let focus = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        if (focus) this.focus();
        this.update();
        return this.selection.getRange()[0];
      }
      getSemanticHTML() {
        let index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        let length = arguments.length > 1 ? arguments[1] : void 0;
        if (typeof index === "number") {
          length = length ?? this.getLength() - index;
        }
        [index, length] = overload(index, length);
        return this.editor.getHTML(index, length);
      }
      getText() {
        let index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        let length = arguments.length > 1 ? arguments[1] : void 0;
        if (typeof index === "number") {
          length = length ?? this.getLength() - index;
        }
        [index, length] = overload(index, length);
        return this.editor.getText(index, length);
      }
      hasFocus() {
        return this.selection.hasFocus();
      }
      insertEmbed(index, embed, value2) {
        let source = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : _Quill.sources.API;
        return modify.call(this, () => {
          return this.editor.insertEmbed(index, embed, value2);
        }, source, index);
      }
      insertText(index, text, name2, value2, source) {
        let formats;
        [index, , formats, source] = overload(index, 0, name2, value2, source);
        return modify.call(this, () => {
          return this.editor.insertText(index, text, formats);
        }, source, index, text.length);
      }
      isEnabled() {
        return this.scroll.isEnabled();
      }
      off() {
        return this.emitter.off(...arguments);
      }
      on() {
        return this.emitter.on(...arguments);
      }
      once() {
        return this.emitter.once(...arguments);
      }
      removeFormat(index, length, source) {
        [index, length, , source] = overload(index, length, source);
        return modify.call(this, () => {
          return this.editor.removeFormat(index, length);
        }, source, index);
      }
      scrollRectIntoView(rect) {
        scrollRectIntoView(this.root, rect);
      }
      /**
       * @deprecated Use Quill#scrollSelectionIntoView() instead.
       */
      scrollIntoView() {
        console.warn("Quill#scrollIntoView() has been deprecated and will be removed in the near future. Please use Quill#scrollSelectionIntoView() instead.");
        this.scrollSelectionIntoView();
      }
      /**
       * Scroll the current selection into the visible area.
       * If the selection is already visible, no scrolling will occur.
       */
      scrollSelectionIntoView() {
        const range = this.selection.lastRange;
        const bounds2 = range && this.selection.getBounds(range.index, range.length);
        if (bounds2) {
          this.scrollRectIntoView(bounds2);
        }
      }
      setContents(delta) {
        let source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Emitter.sources.API;
        return modify.call(this, () => {
          delta = new Delta(delta);
          const length = this.getLength();
          const delete1 = this.editor.deleteText(0, length);
          const applied = this.editor.insertContents(0, delta);
          const delete2 = this.editor.deleteText(this.getLength() - 1, 1);
          return delete1.compose(applied).compose(delete2);
        }, source);
      }
      setSelection(index, length, source) {
        if (index == null) {
          this.selection.setRange(null, length || _Quill.sources.API);
        } else {
          [index, length, , source] = overload(index, length, source);
          this.selection.setRange(new Range(Math.max(0, index), length), source);
          if (source !== Emitter.sources.SILENT) {
            this.scrollSelectionIntoView();
          }
        }
      }
      setText(text) {
        let source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Emitter.sources.API;
        const delta = new Delta().insert(text);
        return this.setContents(delta, source);
      }
      update() {
        let source = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Emitter.sources.USER;
        const change = this.scroll.update(source);
        this.selection.update(source);
        return change;
      }
      updateContents(delta) {
        let source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Emitter.sources.API;
        return modify.call(this, () => {
          delta = new Delta(delta);
          return this.editor.applyDelta(delta);
        }, source, true);
      }
    };
    __publicField(_Quill, "DEFAULTS", {
      bounds: null,
      modules: {
        clipboard: true,
        keyboard: true,
        history: true,
        uploader: true
      },
      placeholder: "",
      readOnly: false,
      registry: globalRegistry,
      theme: "default"
    });
    __publicField(_Quill, "events", Emitter.events);
    __publicField(_Quill, "sources", Emitter.sources);
    __publicField(_Quill, "version", "2.0.3");
    __publicField(_Quill, "imports", {
      delta: Delta,
      parchment: Parchment,
      "core/module": Module,
      "core/theme": Theme
    });
    let Quill = _Quill;
    function resolveSelector(selector) {
      return typeof selector === "string" ? document.querySelector(selector) : selector;
    }
    function expandModuleConfig(config2) {
      return Object.entries(config2 ?? {}).reduce((expanded, _ref) => {
        let [key, value2] = _ref;
        return {
          ...expanded,
          [key]: value2 === true ? {} : value2
        };
      }, {});
    }
    function omitUndefinedValuesFromOptions(obj) {
      return Object.fromEntries(Object.entries(obj).filter((entry) => entry[1] !== void 0));
    }
    function expandConfig(containerOrSelector, options) {
      const container = resolveSelector(containerOrSelector);
      if (!container) {
        throw new Error("Invalid Quill container");
      }
      const shouldUseDefaultTheme = !options.theme || options.theme === Quill.DEFAULTS.theme;
      const theme = shouldUseDefaultTheme ? Theme : Quill.import(`themes/${options.theme}`);
      if (!theme) {
        throw new Error(`Invalid theme ${options.theme}. Did you register it?`);
      }
      const {
        modules: quillModuleDefaults,
        ...quillDefaults
      } = Quill.DEFAULTS;
      const {
        modules: themeModuleDefaults,
        ...themeDefaults
      } = theme.DEFAULTS;
      let userModuleOptions = expandModuleConfig(options.modules);
      if (userModuleOptions != null && userModuleOptions.toolbar && userModuleOptions.toolbar.constructor !== Object) {
        userModuleOptions = {
          ...userModuleOptions,
          toolbar: {
            container: userModuleOptions.toolbar
          }
        };
      }
      const modules = merge({}, expandModuleConfig(quillModuleDefaults), expandModuleConfig(themeModuleDefaults), userModuleOptions);
      const config2 = {
        ...quillDefaults,
        ...omitUndefinedValuesFromOptions(themeDefaults),
        ...omitUndefinedValuesFromOptions(options)
      };
      let registry = options.registry;
      if (registry) {
        if (options.formats) {
          debug$3.warn('Ignoring "formats" option because "registry" is specified');
        }
      } else {
        registry = options.formats ? createRegistryWithFormats(options.formats, config2.registry, debug$3) : config2.registry;
      }
      return {
        ...config2,
        registry,
        container,
        theme,
        modules: Object.entries(modules).reduce((modulesWithDefaults, _ref2) => {
          let [name2, value2] = _ref2;
          if (!value2) return modulesWithDefaults;
          const moduleClass = Quill.import(`modules/${name2}`);
          if (moduleClass == null) {
            debug$3.error(`Cannot load ${name2} module. Are you sure you registered it?`);
            return modulesWithDefaults;
          }
          return {
            ...modulesWithDefaults,
            // @ts-expect-error
            [name2]: merge({}, moduleClass.DEFAULTS || {}, value2)
          };
        }, {}),
        bounds: resolveSelector(config2.bounds)
      };
    }
    function modify(modifier, source, index, shift) {
      if (!this.isEnabled() && source === Emitter.sources.USER && !this.allowReadOnlyEdits) {
        return new Delta();
      }
      let range = index == null ? null : this.getSelection();
      const oldDelta = this.editor.delta;
      const change = modifier();
      if (range != null) {
        if (index === true) {
          index = range.index;
        }
        if (shift == null) {
          range = shiftRange(range, change, source);
        } else if (shift !== 0) {
          range = shiftRange(range, index, shift, source);
        }
        this.setSelection(range, Emitter.sources.SILENT);
      }
      if (change.length() > 0) {
        const args = [Emitter.events.TEXT_CHANGE, change, oldDelta, source];
        this.emitter.emit(Emitter.events.EDITOR_CHANGE, ...args);
        if (source !== Emitter.sources.SILENT) {
          this.emitter.emit(...args);
        }
      }
      return change;
    }
    function overload(index, length, name2, value2, source) {
      let formats = {};
      if (typeof index.index === "number" && typeof index.length === "number") {
        if (typeof length !== "number") {
          source = value2;
          value2 = name2;
          name2 = length;
          length = index.length;
          index = index.index;
        } else {
          length = index.length;
          index = index.index;
        }
      } else if (typeof length !== "number") {
        source = value2;
        value2 = name2;
        name2 = length;
        length = 0;
      }
      if (typeof name2 === "object") {
        formats = name2;
        source = value2;
      } else if (typeof name2 === "string") {
        if (value2 != null) {
          formats[name2] = value2;
        } else {
          source = name2;
        }
      }
      source = source || Emitter.sources.API;
      return [index, length, formats, source];
    }
    function shiftRange(range, index, lengthOrSource, source) {
      const length = typeof lengthOrSource === "number" ? lengthOrSource : 0;
      if (range == null) return null;
      let start;
      let end;
      if (index && typeof index.transformPosition === "function") {
        [start, end] = [range.index, range.index + range.length].map((pos) => (
          // @ts-expect-error -- TODO: add a better type guard around `index`
          index.transformPosition(pos, source !== Emitter.sources.USER)
        ));
      } else {
        [start, end] = [range.index, range.index + range.length].map((pos) => {
          if (pos < index || pos === index && source === Emitter.sources.USER) return pos;
          if (length >= 0) {
            return pos + length;
          }
          return Math.max(index, pos + length);
        });
      }
      return new Range(start, end - start);
    }
    class Container extends ContainerBlot$1 {
    }
    function isLine$1(blot) {
      return blot instanceof Block || blot instanceof BlockEmbed;
    }
    function isUpdatable(blot) {
      return typeof blot.updateContent === "function";
    }
    class Scroll extends ScrollBlot$1 {
      constructor(registry, domNode, _ref) {
        let {
          emitter
        } = _ref;
        super(registry, domNode);
        this.emitter = emitter;
        this.batch = false;
        this.optimize();
        this.enable();
        this.domNode.addEventListener("dragstart", (e) => this.handleDragStart(e));
      }
      batchStart() {
        if (!Array.isArray(this.batch)) {
          this.batch = [];
        }
      }
      batchEnd() {
        if (!this.batch) return;
        const mutations = this.batch;
        this.batch = false;
        this.update(mutations);
      }
      emitMount(blot) {
        this.emitter.emit(Emitter.events.SCROLL_BLOT_MOUNT, blot);
      }
      emitUnmount(blot) {
        this.emitter.emit(Emitter.events.SCROLL_BLOT_UNMOUNT, blot);
      }
      emitEmbedUpdate(blot, change) {
        this.emitter.emit(Emitter.events.SCROLL_EMBED_UPDATE, blot, change);
      }
      deleteAt(index, length) {
        const [first, offset] = this.line(index);
        const [last] = this.line(index + length);
        super.deleteAt(index, length);
        if (last != null && first !== last && offset > 0) {
          if (first instanceof BlockEmbed || last instanceof BlockEmbed) {
            this.optimize();
            return;
          }
          const ref = last.children.head instanceof Break ? null : last.children.head;
          first.moveChildren(last, ref);
          first.remove();
        }
        this.optimize();
      }
      enable() {
        let enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        this.domNode.setAttribute("contenteditable", enabled ? "true" : "false");
      }
      formatAt(index, length, format, value2) {
        super.formatAt(index, length, format, value2);
        this.optimize();
      }
      insertAt(index, value2, def) {
        if (index >= this.length()) {
          if (def == null || this.scroll.query(value2, Scope.BLOCK) == null) {
            const blot = this.scroll.create(this.statics.defaultChild.blotName);
            this.appendChild(blot);
            if (def == null && value2.endsWith("\n")) {
              blot.insertAt(0, value2.slice(0, -1), def);
            } else {
              blot.insertAt(0, value2, def);
            }
          } else {
            const embed = this.scroll.create(value2, def);
            this.appendChild(embed);
          }
        } else {
          super.insertAt(index, value2, def);
        }
        this.optimize();
      }
      insertBefore(blot, ref) {
        if (blot.statics.scope === Scope.INLINE_BLOT) {
          const wrapper = this.scroll.create(this.statics.defaultChild.blotName);
          wrapper.appendChild(blot);
          super.insertBefore(wrapper, ref);
        } else {
          super.insertBefore(blot, ref);
        }
      }
      insertContents(index, delta) {
        const renderBlocks = this.deltaToRenderBlocks(delta.concat(new Delta().insert("\n")));
        const last = renderBlocks.pop();
        if (last == null) return;
        this.batchStart();
        const first = renderBlocks.shift();
        if (first) {
          const shouldInsertNewlineChar = first.type === "block" && (first.delta.length() === 0 || !this.descendant(BlockEmbed, index)[0] && index < this.length());
          const delta2 = first.type === "block" ? first.delta : new Delta().insert({
            [first.key]: first.value
          });
          insertInlineContents(this, index, delta2);
          const newlineCharLength = first.type === "block" ? 1 : 0;
          const lineEndIndex = index + delta2.length() + newlineCharLength;
          if (shouldInsertNewlineChar) {
            this.insertAt(lineEndIndex - 1, "\n");
          }
          const formats = bubbleFormats(this.line(index)[0]);
          const attributes = DeltaExports.AttributeMap.diff(formats, first.attributes) || {};
          Object.keys(attributes).forEach((name2) => {
            this.formatAt(lineEndIndex - 1, 1, name2, attributes[name2]);
          });
          index = lineEndIndex;
        }
        let [refBlot, refBlotOffset] = this.children.find(index);
        if (renderBlocks.length) {
          if (refBlot) {
            refBlot = refBlot.split(refBlotOffset);
            refBlotOffset = 0;
          }
          renderBlocks.forEach((renderBlock) => {
            if (renderBlock.type === "block") {
              const block = this.createBlock(renderBlock.attributes, refBlot || void 0);
              insertInlineContents(block, 0, renderBlock.delta);
            } else {
              const blockEmbed = this.create(renderBlock.key, renderBlock.value);
              this.insertBefore(blockEmbed, refBlot || void 0);
              Object.keys(renderBlock.attributes).forEach((name2) => {
                blockEmbed.format(name2, renderBlock.attributes[name2]);
              });
            }
          });
        }
        if (last.type === "block" && last.delta.length()) {
          const offset = refBlot ? refBlot.offset(refBlot.scroll) + refBlotOffset : this.length();
          insertInlineContents(this, offset, last.delta);
        }
        this.batchEnd();
        this.optimize();
      }
      isEnabled() {
        return this.domNode.getAttribute("contenteditable") === "true";
      }
      leaf(index) {
        const last = this.path(index).pop();
        if (!last) {
          return [null, -1];
        }
        const [blot, offset] = last;
        return blot instanceof LeafBlot$1 ? [blot, offset] : [null, -1];
      }
      line(index) {
        if (index === this.length()) {
          return this.line(index - 1);
        }
        return this.descendant(isLine$1, index);
      }
      lines() {
        let index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
        let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.MAX_VALUE;
        const getLines = (blot, blotIndex, blotLength) => {
          let lines = [];
          let lengthLeft = blotLength;
          blot.children.forEachAt(blotIndex, blotLength, (child, childIndex, childLength) => {
            if (isLine$1(child)) {
              lines.push(child);
            } else if (child instanceof ContainerBlot$1) {
              lines = lines.concat(getLines(child, childIndex, lengthLeft));
            }
            lengthLeft -= childLength;
          });
          return lines;
        };
        return getLines(this, index, length);
      }
      optimize() {
        let mutations = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        let context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (this.batch) return;
        super.optimize(mutations, context);
        if (mutations.length > 0) {
          this.emitter.emit(Emitter.events.SCROLL_OPTIMIZE, mutations, context);
        }
      }
      path(index) {
        return super.path(index).slice(1);
      }
      remove() {
      }
      update(mutations) {
        if (this.batch) {
          if (Array.isArray(mutations)) {
            this.batch = this.batch.concat(mutations);
          }
          return;
        }
        let source = Emitter.sources.USER;
        if (typeof mutations === "string") {
          source = mutations;
        }
        if (!Array.isArray(mutations)) {
          mutations = this.observer.takeRecords();
        }
        mutations = mutations.filter((_ref2) => {
          let {
            target
          } = _ref2;
          const blot = this.find(target, true);
          return blot && !isUpdatable(blot);
        });
        if (mutations.length > 0) {
          this.emitter.emit(Emitter.events.SCROLL_BEFORE_UPDATE, source, mutations);
        }
        super.update(mutations.concat([]));
        if (mutations.length > 0) {
          this.emitter.emit(Emitter.events.SCROLL_UPDATE, source, mutations);
        }
      }
      updateEmbedAt(index, key, change) {
        const [blot] = this.descendant((b) => b instanceof BlockEmbed, index);
        if (blot && blot.statics.blotName === key && isUpdatable(blot)) {
          blot.updateContent(change);
        }
      }
      handleDragStart(event) {
        event.preventDefault();
      }
      deltaToRenderBlocks(delta) {
        const renderBlocks = [];
        let currentBlockDelta = new Delta();
        delta.forEach((op) => {
          const insert = op == null ? void 0 : op.insert;
          if (!insert) return;
          if (typeof insert === "string") {
            const splitted = insert.split("\n");
            splitted.slice(0, -1).forEach((text) => {
              currentBlockDelta.insert(text, op.attributes);
              renderBlocks.push({
                type: "block",
                delta: currentBlockDelta,
                attributes: op.attributes ?? {}
              });
              currentBlockDelta = new Delta();
            });
            const last = splitted[splitted.length - 1];
            if (last) {
              currentBlockDelta.insert(last, op.attributes);
            }
          } else {
            const key = Object.keys(insert)[0];
            if (!key) return;
            if (this.query(key, Scope.INLINE)) {
              currentBlockDelta.push(op);
            } else {
              if (currentBlockDelta.length()) {
                renderBlocks.push({
                  type: "block",
                  delta: currentBlockDelta,
                  attributes: {}
                });
              }
              currentBlockDelta = new Delta();
              renderBlocks.push({
                type: "blockEmbed",
                key,
                value: insert[key],
                attributes: op.attributes ?? {}
              });
            }
          }
        });
        if (currentBlockDelta.length()) {
          renderBlocks.push({
            type: "block",
            delta: currentBlockDelta,
            attributes: {}
          });
        }
        return renderBlocks;
      }
      createBlock(attributes, refBlot) {
        let blotName;
        const formats = {};
        Object.entries(attributes).forEach((_ref3) => {
          let [key, value2] = _ref3;
          const isBlockBlot = this.query(key, Scope.BLOCK & Scope.BLOT) != null;
          if (isBlockBlot) {
            blotName = key;
          } else {
            formats[key] = value2;
          }
        });
        const block = this.create(blotName || this.statics.defaultChild.blotName, blotName ? attributes[blotName] : void 0);
        this.insertBefore(block, refBlot || void 0);
        const length = block.length();
        Object.entries(formats).forEach((_ref4) => {
          let [key, value2] = _ref4;
          block.formatAt(0, length, key, value2);
        });
        return block;
      }
    }
    __publicField(Scroll, "blotName", "scroll");
    __publicField(Scroll, "className", "ql-editor");
    __publicField(Scroll, "tagName", "DIV");
    __publicField(Scroll, "defaultChild", Block);
    __publicField(Scroll, "allowedChildren", [Block, BlockEmbed, Container]);
    function insertInlineContents(parent, index, inlineContents) {
      inlineContents.reduce((index2, op) => {
        const length = DeltaExports.Op.length(op);
        let attributes = op.attributes || {};
        if (op.insert != null) {
          if (typeof op.insert === "string") {
            const text = op.insert;
            parent.insertAt(index2, text);
            const [leaf] = parent.descendant(LeafBlot$1, index2);
            const formats = bubbleFormats(leaf);
            attributes = DeltaExports.AttributeMap.diff(formats, attributes) || {};
          } else if (typeof op.insert === "object") {
            const key = Object.keys(op.insert)[0];
            if (key == null) return index2;
            parent.insertAt(index2, key, op.insert[key]);
            const isInlineEmbed = parent.scroll.query(key, Scope.INLINE) != null;
            if (isInlineEmbed) {
              const [leaf] = parent.descendant(LeafBlot$1, index2);
              const formats = bubbleFormats(leaf);
              attributes = DeltaExports.AttributeMap.diff(formats, attributes) || {};
            }
          }
        }
        Object.keys(attributes).forEach((key) => {
          parent.formatAt(index2, length, key, attributes[key]);
        });
        return index2 + length;
      }, index);
    }
    const config$2 = {
      scope: Scope.BLOCK,
      whitelist: ["right", "center", "justify"]
    };
    const AlignAttribute = new Attributor("align", "align", config$2);
    const AlignClass = new ClassAttributor$1("align", "ql-align", config$2);
    const AlignStyle = new StyleAttributor$1("align", "text-align", config$2);
    class ColorAttributor extends StyleAttributor$1 {
      value(domNode) {
        let value2 = super.value(domNode);
        if (!value2.startsWith("rgb(")) return value2;
        value2 = value2.replace(/^[^\d]+/, "").replace(/[^\d]+$/, "");
        const hex = value2.split(",").map((component) => `00${parseInt(component, 10).toString(16)}`.slice(-2)).join("");
        return `#${hex}`;
      }
    }
    const ColorClass = new ClassAttributor$1("color", "ql-color", {
      scope: Scope.INLINE
    });
    const ColorStyle = new ColorAttributor("color", "color", {
      scope: Scope.INLINE
    });
    const BackgroundClass = new ClassAttributor$1("background", "ql-bg", {
      scope: Scope.INLINE
    });
    const BackgroundStyle = new ColorAttributor("background", "background-color", {
      scope: Scope.INLINE
    });
    class CodeBlockContainer extends Container {
      static create(value2) {
        const domNode = super.create(value2);
        domNode.setAttribute("spellcheck", "false");
        return domNode;
      }
      code(index, length) {
        return this.children.map((child) => child.length() <= 1 ? "" : child.domNode.innerText).join("\n").slice(index, index + length);
      }
      html(index, length) {
        return `<pre>
${escapeText(this.code(index, length))}
</pre>`;
      }
    }
    class CodeBlock extends Block {
      static register() {
        Quill.register(CodeBlockContainer);
      }
    }
    __publicField(CodeBlock, "TAB", "  ");
    class Code extends Inline$1 {
    }
    Code.blotName = "code";
    Code.tagName = "CODE";
    CodeBlock.blotName = "code-block";
    CodeBlock.className = "ql-code-block";
    CodeBlock.tagName = "DIV";
    CodeBlockContainer.blotName = "code-block-container";
    CodeBlockContainer.className = "ql-code-block-container";
    CodeBlockContainer.tagName = "DIV";
    CodeBlockContainer.allowedChildren = [CodeBlock];
    CodeBlock.allowedChildren = [Text$1, Break, Cursor];
    CodeBlock.requiredContainer = CodeBlockContainer;
    const config$1 = {
      scope: Scope.BLOCK,
      whitelist: ["rtl"]
    };
    const DirectionAttribute = new Attributor("direction", "dir", config$1);
    const DirectionClass = new ClassAttributor$1("direction", "ql-direction", config$1);
    const DirectionStyle = new StyleAttributor$1("direction", "direction", config$1);
    const config = {
      scope: Scope.INLINE,
      whitelist: ["serif", "monospace"]
    };
    const FontClass = new ClassAttributor$1("font", "ql-font", config);
    class FontStyleAttributor extends StyleAttributor$1 {
      value(node) {
        return super.value(node).replace(/["']/g, "");
      }
    }
    const FontStyle = new FontStyleAttributor("font", "font-family", config);
    const SizeClass = new ClassAttributor$1("size", "ql-size", {
      scope: Scope.INLINE,
      whitelist: ["small", "large", "huge"]
    });
    const SizeStyle = new StyleAttributor$1("size", "font-size", {
      scope: Scope.INLINE,
      whitelist: ["10px", "18px", "32px"]
    });
    const debug$2 = namespace("quill:keyboard");
    const SHORTKEY = /Mac/i.test(navigator.platform) ? "metaKey" : "ctrlKey";
    class Keyboard extends Module {
      static match(evt, binding) {
        if (["altKey", "ctrlKey", "metaKey", "shiftKey"].some((key) => {
          return !!binding[key] !== evt[key] && binding[key] !== null;
        })) {
          return false;
        }
        return binding.key === evt.key || binding.key === evt.which;
      }
      constructor(quill, options) {
        super(quill, options);
        this.bindings = {};
        Object.keys(this.options.bindings).forEach((name2) => {
          if (this.options.bindings[name2]) {
            this.addBinding(this.options.bindings[name2]);
          }
        });
        this.addBinding({
          key: "Enter",
          shiftKey: null
        }, this.handleEnter);
        this.addBinding({
          key: "Enter",
          metaKey: null,
          ctrlKey: null,
          altKey: null
        }, () => {
        });
        if (/Firefox/i.test(navigator.userAgent)) {
          this.addBinding({
            key: "Backspace"
          }, {
            collapsed: true
          }, this.handleBackspace);
          this.addBinding({
            key: "Delete"
          }, {
            collapsed: true
          }, this.handleDelete);
        } else {
          this.addBinding({
            key: "Backspace"
          }, {
            collapsed: true,
            prefix: /^.?$/
          }, this.handleBackspace);
          this.addBinding({
            key: "Delete"
          }, {
            collapsed: true,
            suffix: /^.?$/
          }, this.handleDelete);
        }
        this.addBinding({
          key: "Backspace"
        }, {
          collapsed: false
        }, this.handleDeleteRange);
        this.addBinding({
          key: "Delete"
        }, {
          collapsed: false
        }, this.handleDeleteRange);
        this.addBinding({
          key: "Backspace",
          altKey: null,
          ctrlKey: null,
          metaKey: null,
          shiftKey: null
        }, {
          collapsed: true,
          offset: 0
        }, this.handleBackspace);
        this.listen();
      }
      addBinding(keyBinding) {
        let context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        let handler = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        const binding = normalize$2(keyBinding);
        if (binding == null) {
          debug$2.warn("Attempted to add invalid keyboard binding", binding);
          return;
        }
        if (typeof context === "function") {
          context = {
            handler: context
          };
        }
        if (typeof handler === "function") {
          handler = {
            handler
          };
        }
        const keys2 = Array.isArray(binding.key) ? binding.key : [binding.key];
        keys2.forEach((key) => {
          const singleBinding = {
            ...binding,
            key,
            ...context,
            ...handler
          };
          this.bindings[singleBinding.key] = this.bindings[singleBinding.key] || [];
          this.bindings[singleBinding.key].push(singleBinding);
        });
      }
      listen() {
        this.quill.root.addEventListener("keydown", (evt) => {
          if (evt.defaultPrevented || evt.isComposing) return;
          const isComposing = evt.keyCode === 229 && (evt.key === "Enter" || evt.key === "Backspace");
          if (isComposing) return;
          const bindings = (this.bindings[evt.key] || []).concat(this.bindings[evt.which] || []);
          const matches = bindings.filter((binding) => Keyboard.match(evt, binding));
          if (matches.length === 0) return;
          const blot = Quill.find(evt.target, true);
          if (blot && blot.scroll !== this.quill.scroll) return;
          const range = this.quill.getSelection();
          if (range == null || !this.quill.hasFocus()) return;
          const [line, offset] = this.quill.getLine(range.index);
          const [leafStart, offsetStart] = this.quill.getLeaf(range.index);
          const [leafEnd, offsetEnd] = range.length === 0 ? [leafStart, offsetStart] : this.quill.getLeaf(range.index + range.length);
          const prefixText = leafStart instanceof TextBlot$1 ? leafStart.value().slice(0, offsetStart) : "";
          const suffixText = leafEnd instanceof TextBlot$1 ? leafEnd.value().slice(offsetEnd) : "";
          const curContext = {
            collapsed: range.length === 0,
            // @ts-expect-error Fix me later
            empty: range.length === 0 && line.length() <= 1,
            format: this.quill.getFormat(range),
            line,
            offset,
            prefix: prefixText,
            suffix: suffixText,
            event: evt
          };
          const prevented = matches.some((binding) => {
            if (binding.collapsed != null && binding.collapsed !== curContext.collapsed) {
              return false;
            }
            if (binding.empty != null && binding.empty !== curContext.empty) {
              return false;
            }
            if (binding.offset != null && binding.offset !== curContext.offset) {
              return false;
            }
            if (Array.isArray(binding.format)) {
              if (binding.format.every((name2) => curContext.format[name2] == null)) {
                return false;
              }
            } else if (typeof binding.format === "object") {
              if (!Object.keys(binding.format).every((name2) => {
                if (binding.format[name2] === true) return curContext.format[name2] != null;
                if (binding.format[name2] === false) return curContext.format[name2] == null;
                return isEqual$1(binding.format[name2], curContext.format[name2]);
              })) {
                return false;
              }
            }
            if (binding.prefix != null && !binding.prefix.test(curContext.prefix)) {
              return false;
            }
            if (binding.suffix != null && !binding.suffix.test(curContext.suffix)) {
              return false;
            }
            return binding.handler.call(this, range, curContext, binding) !== true;
          });
          if (prevented) {
            evt.preventDefault();
          }
        });
      }
      handleBackspace(range, context) {
        const length = /[\uD800-\uDBFF][\uDC00-\uDFFF]$/.test(context.prefix) ? 2 : 1;
        if (range.index === 0 || this.quill.getLength() <= 1) return;
        let formats = {};
        const [line] = this.quill.getLine(range.index);
        let delta = new Delta().retain(range.index - length).delete(length);
        if (context.offset === 0) {
          const [prev] = this.quill.getLine(range.index - 1);
          if (prev) {
            const isPrevLineEmpty = prev.statics.blotName === "block" && prev.length() <= 1;
            if (!isPrevLineEmpty) {
              const curFormats = line.formats();
              const prevFormats = this.quill.getFormat(range.index - 1, 1);
              formats = DeltaExports.AttributeMap.diff(curFormats, prevFormats) || {};
              if (Object.keys(formats).length > 0) {
                const formatDelta = new Delta().retain(range.index + line.length() - 2).retain(1, formats);
                delta = delta.compose(formatDelta);
              }
            }
          }
        }
        this.quill.updateContents(delta, Quill.sources.USER);
        this.quill.focus();
      }
      handleDelete(range, context) {
        const length = /^[\uD800-\uDBFF][\uDC00-\uDFFF]/.test(context.suffix) ? 2 : 1;
        if (range.index >= this.quill.getLength() - length) return;
        let formats = {};
        const [line] = this.quill.getLine(range.index);
        let delta = new Delta().retain(range.index).delete(length);
        if (context.offset >= line.length() - 1) {
          const [next] = this.quill.getLine(range.index + 1);
          if (next) {
            const curFormats = line.formats();
            const nextFormats = this.quill.getFormat(range.index, 1);
            formats = DeltaExports.AttributeMap.diff(curFormats, nextFormats) || {};
            if (Object.keys(formats).length > 0) {
              delta = delta.retain(next.length() - 1).retain(1, formats);
            }
          }
        }
        this.quill.updateContents(delta, Quill.sources.USER);
        this.quill.focus();
      }
      handleDeleteRange(range) {
        deleteRange({
          range,
          quill: this.quill
        });
        this.quill.focus();
      }
      handleEnter(range, context) {
        const lineFormats = Object.keys(context.format).reduce((formats, format) => {
          if (this.quill.scroll.query(format, Scope.BLOCK) && !Array.isArray(context.format[format])) {
            formats[format] = context.format[format];
          }
          return formats;
        }, {});
        const delta = new Delta().retain(range.index).delete(range.length).insert("\n", lineFormats);
        this.quill.updateContents(delta, Quill.sources.USER);
        this.quill.setSelection(range.index + 1, Quill.sources.SILENT);
        this.quill.focus();
      }
    }
    const defaultOptions = {
      bindings: {
        bold: makeFormatHandler("bold"),
        italic: makeFormatHandler("italic"),
        underline: makeFormatHandler("underline"),
        indent: {
          // highlight tab or tab at beginning of list, indent or blockquote
          key: "Tab",
          format: ["blockquote", "indent", "list"],
          handler(range, context) {
            if (context.collapsed && context.offset !== 0) return true;
            this.quill.format("indent", "+1", Quill.sources.USER);
            return false;
          }
        },
        outdent: {
          key: "Tab",
          shiftKey: true,
          format: ["blockquote", "indent", "list"],
          // highlight tab or tab at beginning of list, indent or blockquote
          handler(range, context) {
            if (context.collapsed && context.offset !== 0) return true;
            this.quill.format("indent", "-1", Quill.sources.USER);
            return false;
          }
        },
        "outdent backspace": {
          key: "Backspace",
          collapsed: true,
          shiftKey: null,
          metaKey: null,
          ctrlKey: null,
          altKey: null,
          format: ["indent", "list"],
          offset: 0,
          handler(range, context) {
            if (context.format.indent != null) {
              this.quill.format("indent", "-1", Quill.sources.USER);
            } else if (context.format.list != null) {
              this.quill.format("list", false, Quill.sources.USER);
            }
          }
        },
        "indent code-block": makeCodeBlockHandler(true),
        "outdent code-block": makeCodeBlockHandler(false),
        "remove tab": {
          key: "Tab",
          shiftKey: true,
          collapsed: true,
          prefix: /\t$/,
          handler(range) {
            this.quill.deleteText(range.index - 1, 1, Quill.sources.USER);
          }
        },
        tab: {
          key: "Tab",
          handler(range, context) {
            if (context.format.table) return true;
            this.quill.history.cutoff();
            const delta = new Delta().retain(range.index).delete(range.length).insert("	");
            this.quill.updateContents(delta, Quill.sources.USER);
            this.quill.history.cutoff();
            this.quill.setSelection(range.index + 1, Quill.sources.SILENT);
            return false;
          }
        },
        "blockquote empty enter": {
          key: "Enter",
          collapsed: true,
          format: ["blockquote"],
          empty: true,
          handler() {
            this.quill.format("blockquote", false, Quill.sources.USER);
          }
        },
        "list empty enter": {
          key: "Enter",
          collapsed: true,
          format: ["list"],
          empty: true,
          handler(range, context) {
            const formats = {
              list: false
            };
            if (context.format.indent) {
              formats.indent = false;
            }
            this.quill.formatLine(range.index, range.length, formats, Quill.sources.USER);
          }
        },
        "checklist enter": {
          key: "Enter",
          collapsed: true,
          format: {
            list: "checked"
          },
          handler(range) {
            const [line, offset] = this.quill.getLine(range.index);
            const formats = {
              // @ts-expect-error Fix me later
              ...line.formats(),
              list: "checked"
            };
            const delta = new Delta().retain(range.index).insert("\n", formats).retain(line.length() - offset - 1).retain(1, {
              list: "unchecked"
            });
            this.quill.updateContents(delta, Quill.sources.USER);
            this.quill.setSelection(range.index + 1, Quill.sources.SILENT);
            this.quill.scrollSelectionIntoView();
          }
        },
        "header enter": {
          key: "Enter",
          collapsed: true,
          format: ["header"],
          suffix: /^$/,
          handler(range, context) {
            const [line, offset] = this.quill.getLine(range.index);
            const delta = new Delta().retain(range.index).insert("\n", context.format).retain(line.length() - offset - 1).retain(1, {
              header: null
            });
            this.quill.updateContents(delta, Quill.sources.USER);
            this.quill.setSelection(range.index + 1, Quill.sources.SILENT);
            this.quill.scrollSelectionIntoView();
          }
        },
        "table backspace": {
          key: "Backspace",
          format: ["table"],
          collapsed: true,
          offset: 0,
          handler() {
          }
        },
        "table delete": {
          key: "Delete",
          format: ["table"],
          collapsed: true,
          suffix: /^$/,
          handler() {
          }
        },
        "table enter": {
          key: "Enter",
          shiftKey: null,
          format: ["table"],
          handler(range) {
            const module2 = this.quill.getModule("table");
            if (module2) {
              const [table, row, cell, offset] = module2.getTable(range);
              const shift = tableSide(table, row, cell, offset);
              if (shift == null) return;
              let index = table.offset();
              if (shift < 0) {
                const delta = new Delta().retain(index).insert("\n");
                this.quill.updateContents(delta, Quill.sources.USER);
                this.quill.setSelection(range.index + 1, range.length, Quill.sources.SILENT);
              } else if (shift > 0) {
                index += table.length();
                const delta = new Delta().retain(index).insert("\n");
                this.quill.updateContents(delta, Quill.sources.USER);
                this.quill.setSelection(index, Quill.sources.USER);
              }
            }
          }
        },
        "table tab": {
          key: "Tab",
          shiftKey: null,
          format: ["table"],
          handler(range, context) {
            const {
              event,
              line: cell
            } = context;
            const offset = cell.offset(this.quill.scroll);
            if (event.shiftKey) {
              this.quill.setSelection(offset - 1, Quill.sources.USER);
            } else {
              this.quill.setSelection(offset + cell.length(), Quill.sources.USER);
            }
          }
        },
        "list autofill": {
          key: " ",
          shiftKey: null,
          collapsed: true,
          format: {
            "code-block": false,
            blockquote: false,
            table: false
          },
          prefix: /^\s*?(\d+\.|-|\*|\[ ?\]|\[x\])$/,
          handler(range, context) {
            if (this.quill.scroll.query("list") == null) return true;
            const {
              length
            } = context.prefix;
            const [line, offset] = this.quill.getLine(range.index);
            if (offset > length) return true;
            let value2;
            switch (context.prefix.trim()) {
              case "[]":
              case "[ ]":
                value2 = "unchecked";
                break;
              case "[x]":
                value2 = "checked";
                break;
              case "-":
              case "*":
                value2 = "bullet";
                break;
              default:
                value2 = "ordered";
            }
            this.quill.insertText(range.index, " ", Quill.sources.USER);
            this.quill.history.cutoff();
            const delta = new Delta().retain(range.index - offset).delete(length + 1).retain(line.length() - 2 - offset).retain(1, {
              list: value2
            });
            this.quill.updateContents(delta, Quill.sources.USER);
            this.quill.history.cutoff();
            this.quill.setSelection(range.index - length, Quill.sources.SILENT);
            return false;
          }
        },
        "code exit": {
          key: "Enter",
          collapsed: true,
          format: ["code-block"],
          prefix: /^$/,
          suffix: /^\s*$/,
          handler(range) {
            const [line, offset] = this.quill.getLine(range.index);
            let numLines = 2;
            let cur = line;
            while (cur != null && cur.length() <= 1 && cur.formats()["code-block"]) {
              cur = cur.prev;
              numLines -= 1;
              if (numLines <= 0) {
                const delta = new Delta().retain(range.index + line.length() - offset - 2).retain(1, {
                  "code-block": null
                }).delete(1);
                this.quill.updateContents(delta, Quill.sources.USER);
                this.quill.setSelection(range.index - 1, Quill.sources.SILENT);
                return false;
              }
            }
            return true;
          }
        },
        "embed left": makeEmbedArrowHandler("ArrowLeft", false),
        "embed left shift": makeEmbedArrowHandler("ArrowLeft", true),
        "embed right": makeEmbedArrowHandler("ArrowRight", false),
        "embed right shift": makeEmbedArrowHandler("ArrowRight", true),
        "table down": makeTableArrowHandler(false),
        "table up": makeTableArrowHandler(true)
      }
    };
    Keyboard.DEFAULTS = defaultOptions;
    function makeCodeBlockHandler(indent) {
      return {
        key: "Tab",
        shiftKey: !indent,
        format: {
          "code-block": true
        },
        handler(range, _ref) {
          let {
            event
          } = _ref;
          const CodeBlock2 = this.quill.scroll.query("code-block");
          const {
            TAB
          } = CodeBlock2;
          if (range.length === 0 && !event.shiftKey) {
            this.quill.insertText(range.index, TAB, Quill.sources.USER);
            this.quill.setSelection(range.index + TAB.length, Quill.sources.SILENT);
            return;
          }
          const lines = range.length === 0 ? this.quill.getLines(range.index, 1) : this.quill.getLines(range);
          let {
            index,
            length
          } = range;
          lines.forEach((line, i) => {
            if (indent) {
              line.insertAt(0, TAB);
              if (i === 0) {
                index += TAB.length;
              } else {
                length += TAB.length;
              }
            } else if (line.domNode.textContent.startsWith(TAB)) {
              line.deleteAt(0, TAB.length);
              if (i === 0) {
                index -= TAB.length;
              } else {
                length -= TAB.length;
              }
            }
          });
          this.quill.update(Quill.sources.USER);
          this.quill.setSelection(index, length, Quill.sources.SILENT);
        }
      };
    }
    function makeEmbedArrowHandler(key, shiftKey) {
      const where = key === "ArrowLeft" ? "prefix" : "suffix";
      return {
        key,
        shiftKey,
        altKey: null,
        [where]: /^$/,
        handler(range) {
          let {
            index
          } = range;
          if (key === "ArrowRight") {
            index += range.length + 1;
          }
          const [leaf] = this.quill.getLeaf(index);
          if (!(leaf instanceof EmbedBlot$1)) return true;
          if (key === "ArrowLeft") {
            if (shiftKey) {
              this.quill.setSelection(range.index - 1, range.length + 1, Quill.sources.USER);
            } else {
              this.quill.setSelection(range.index - 1, Quill.sources.USER);
            }
          } else if (shiftKey) {
            this.quill.setSelection(range.index, range.length + 1, Quill.sources.USER);
          } else {
            this.quill.setSelection(range.index + range.length + 1, Quill.sources.USER);
          }
          return false;
        }
      };
    }
    function makeFormatHandler(format) {
      return {
        key: format[0],
        shortKey: true,
        handler(range, context) {
          this.quill.format(format, !context.format[format], Quill.sources.USER);
        }
      };
    }
    function makeTableArrowHandler(up) {
      return {
        key: up ? "ArrowUp" : "ArrowDown",
        collapsed: true,
        format: ["table"],
        handler(range, context) {
          const key = up ? "prev" : "next";
          const cell = context.line;
          const targetRow = cell.parent[key];
          if (targetRow != null) {
            if (targetRow.statics.blotName === "table-row") {
              let targetCell = targetRow.children.head;
              let cur = cell;
              while (cur.prev != null) {
                cur = cur.prev;
                targetCell = targetCell.next;
              }
              const index = targetCell.offset(this.quill.scroll) + Math.min(context.offset, targetCell.length() - 1);
              this.quill.setSelection(index, 0, Quill.sources.USER);
            }
          } else {
            const targetLine = cell.table()[key];
            if (targetLine != null) {
              if (up) {
                this.quill.setSelection(targetLine.offset(this.quill.scroll) + targetLine.length() - 1, 0, Quill.sources.USER);
              } else {
                this.quill.setSelection(targetLine.offset(this.quill.scroll), 0, Quill.sources.USER);
              }
            }
          }
          return false;
        }
      };
    }
    function normalize$2(binding) {
      if (typeof binding === "string" || typeof binding === "number") {
        binding = {
          key: binding
        };
      } else if (typeof binding === "object") {
        binding = cloneDeep(binding);
      } else {
        return null;
      }
      if (binding.shortKey) {
        binding[SHORTKEY] = binding.shortKey;
        delete binding.shortKey;
      }
      return binding;
    }
    function deleteRange(_ref2) {
      let {
        quill,
        range
      } = _ref2;
      const lines = quill.getLines(range);
      let formats = {};
      if (lines.length > 1) {
        const firstFormats = lines[0].formats();
        const lastFormats = lines[lines.length - 1].formats();
        formats = DeltaExports.AttributeMap.diff(lastFormats, firstFormats) || {};
      }
      quill.deleteText(range, Quill.sources.USER);
      if (Object.keys(formats).length > 0) {
        quill.formatLine(range.index, 1, formats, Quill.sources.USER);
      }
      quill.setSelection(range.index, Quill.sources.SILENT);
    }
    function tableSide(_table, row, cell, offset) {
      if (row.prev == null && row.next == null) {
        if (cell.prev == null && cell.next == null) {
          return offset === 0 ? -1 : 1;
        }
        return cell.prev == null ? -1 : 1;
      }
      if (row.prev == null) {
        return -1;
      }
      if (row.next == null) {
        return 1;
      }
      return null;
    }
    const normalWeightRegexp = /font-weight:\s*normal/;
    const blockTagNames = ["P", "OL", "UL"];
    const isBlockElement = (element) => {
      return element && blockTagNames.includes(element.tagName);
    };
    const normalizeEmptyLines = (doc) => {
      Array.from(doc.querySelectorAll("br")).filter((br) => isBlockElement(br.previousElementSibling) && isBlockElement(br.nextElementSibling)).forEach((br) => {
        var _a2;
        (_a2 = br.parentNode) == null ? void 0 : _a2.removeChild(br);
      });
    };
    const normalizeFontWeight = (doc) => {
      Array.from(doc.querySelectorAll('b[style*="font-weight"]')).filter((node) => {
        var _a2;
        return (_a2 = node.getAttribute("style")) == null ? void 0 : _a2.match(normalWeightRegexp);
      }).forEach((node) => {
        var _a2;
        const fragment = doc.createDocumentFragment();
        fragment.append(...node.childNodes);
        (_a2 = node.parentNode) == null ? void 0 : _a2.replaceChild(fragment, node);
      });
    };
    function normalize$1(doc) {
      if (doc.querySelector('[id^="docs-internal-guid-"]')) {
        normalizeFontWeight(doc);
        normalizeEmptyLines(doc);
      }
    }
    const ignoreRegexp = /\bmso-list:[^;]*ignore/i;
    const idRegexp = /\bmso-list:[^;]*\bl(\d+)/i;
    const indentRegexp = /\bmso-list:[^;]*\blevel(\d+)/i;
    const parseListItem = (element, html) => {
      const style = element.getAttribute("style");
      const idMatch = style == null ? void 0 : style.match(idRegexp);
      if (!idMatch) {
        return null;
      }
      const id = Number(idMatch[1]);
      const indentMatch = style == null ? void 0 : style.match(indentRegexp);
      const indent = indentMatch ? Number(indentMatch[1]) : 1;
      const typeRegexp = new RegExp(`@list l${id}:level${indent}\\s*\\{[^\\}]*mso-level-number-format:\\s*([\\w-]+)`, "i");
      const typeMatch = html.match(typeRegexp);
      const type = typeMatch && typeMatch[1] === "bullet" ? "bullet" : "ordered";
      return {
        id,
        indent,
        type,
        element
      };
    };
    const normalizeListItem = (doc) => {
      var _a2, _b;
      const msoList = Array.from(doc.querySelectorAll("[style*=mso-list]"));
      const ignored = [];
      const others = [];
      msoList.forEach((node) => {
        const shouldIgnore = (node.getAttribute("style") || "").match(ignoreRegexp);
        if (shouldIgnore) {
          ignored.push(node);
        } else {
          others.push(node);
        }
      });
      ignored.forEach((node) => {
        var _a3;
        return (_a3 = node.parentNode) == null ? void 0 : _a3.removeChild(node);
      });
      const html = doc.documentElement.innerHTML;
      const listItems = others.map((element) => parseListItem(element, html)).filter((parsed) => parsed);
      while (listItems.length) {
        const childListItems = [];
        let current = listItems.shift();
        while (current) {
          childListItems.push(current);
          current = listItems.length && ((_a2 = listItems[0]) == null ? void 0 : _a2.element) === current.element.nextElementSibling && // Different id means the next item doesn't belong to this group.
          listItems[0].id === current.id ? listItems.shift() : null;
        }
        const ul = document.createElement("ul");
        childListItems.forEach((listItem) => {
          const li = document.createElement("li");
          li.setAttribute("data-list", listItem.type);
          if (listItem.indent > 1) {
            li.setAttribute("class", `ql-indent-${listItem.indent - 1}`);
          }
          li.innerHTML = listItem.element.innerHTML;
          ul.appendChild(li);
        });
        const element = (_b = childListItems[0]) == null ? void 0 : _b.element;
        const {
          parentNode
        } = element ?? {};
        if (element) {
          parentNode == null ? void 0 : parentNode.replaceChild(ul, element);
        }
        childListItems.slice(1).forEach((_ref) => {
          let {
            element: e
          } = _ref;
          parentNode == null ? void 0 : parentNode.removeChild(e);
        });
      }
    };
    function normalize(doc) {
      if (doc.documentElement.getAttribute("xmlns:w") === "urn:schemas-microsoft-com:office:word") {
        normalizeListItem(doc);
      }
    }
    const NORMALIZERS = [normalize, normalize$1];
    const normalizeExternalHTML = (doc) => {
      if (doc.documentElement) {
        NORMALIZERS.forEach((normalize2) => {
          normalize2(doc);
        });
      }
    };
    const debug$1 = namespace("quill:clipboard");
    const CLIPBOARD_CONFIG = [[Node.TEXT_NODE, matchText], [Node.TEXT_NODE, matchNewline], ["br", matchBreak], [Node.ELEMENT_NODE, matchNewline], [Node.ELEMENT_NODE, matchBlot], [Node.ELEMENT_NODE, matchAttributor], [Node.ELEMENT_NODE, matchStyles], ["li", matchIndent], ["ol, ul", matchList], ["pre", matchCodeBlock], ["tr", matchTable], ["b", createMatchAlias("bold")], ["i", createMatchAlias("italic")], ["strike", createMatchAlias("strike")], ["style", matchIgnore]];
    const ATTRIBUTE_ATTRIBUTORS = [AlignAttribute, DirectionAttribute].reduce((memo, attr) => {
      memo[attr.keyName] = attr;
      return memo;
    }, {});
    const STYLE_ATTRIBUTORS = [AlignStyle, BackgroundStyle, ColorStyle, DirectionStyle, FontStyle, SizeStyle].reduce((memo, attr) => {
      memo[attr.keyName] = attr;
      return memo;
    }, {});
    class Clipboard extends Module {
      constructor(quill, options) {
        super(quill, options);
        this.quill.root.addEventListener("copy", (e) => this.onCaptureCopy(e, false));
        this.quill.root.addEventListener("cut", (e) => this.onCaptureCopy(e, true));
        this.quill.root.addEventListener("paste", this.onCapturePaste.bind(this));
        this.matchers = [];
        CLIPBOARD_CONFIG.concat(this.options.matchers ?? []).forEach((_ref) => {
          let [selector, matcher] = _ref;
          this.addMatcher(selector, matcher);
        });
      }
      addMatcher(selector, matcher) {
        this.matchers.push([selector, matcher]);
      }
      convert(_ref2) {
        let {
          html,
          text
        } = _ref2;
        let formats = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        if (formats[CodeBlock.blotName]) {
          return new Delta().insert(text || "", {
            [CodeBlock.blotName]: formats[CodeBlock.blotName]
          });
        }
        if (!html) {
          return new Delta().insert(text || "", formats);
        }
        const delta = this.convertHTML(html);
        if (deltaEndsWith(delta, "\n") && (delta.ops[delta.ops.length - 1].attributes == null || formats.table)) {
          return delta.compose(new Delta().retain(delta.length() - 1).delete(1));
        }
        return delta;
      }
      normalizeHTML(doc) {
        normalizeExternalHTML(doc);
      }
      convertHTML(html) {
        const doc = new DOMParser().parseFromString(html, "text/html");
        this.normalizeHTML(doc);
        const container = doc.body;
        const nodeMatches = /* @__PURE__ */ new WeakMap();
        const [elementMatchers, textMatchers] = this.prepareMatching(container, nodeMatches);
        return traverse(this.quill.scroll, container, elementMatchers, textMatchers, nodeMatches);
      }
      dangerouslyPasteHTML(index, html) {
        let source = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Quill.sources.API;
        if (typeof index === "string") {
          const delta = this.convert({
            html: index,
            text: ""
          });
          this.quill.setContents(delta, html);
          this.quill.setSelection(0, Quill.sources.SILENT);
        } else {
          const paste = this.convert({
            html,
            text: ""
          });
          this.quill.updateContents(new Delta().retain(index).concat(paste), source);
          this.quill.setSelection(index + paste.length(), Quill.sources.SILENT);
        }
      }
      onCaptureCopy(e) {
        var _a2, _b;
        let isCut = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        if (e.defaultPrevented) return;
        e.preventDefault();
        const [range] = this.quill.selection.getRange();
        if (range == null) return;
        const {
          html,
          text
        } = this.onCopy(range, isCut);
        (_a2 = e.clipboardData) == null ? void 0 : _a2.setData("text/plain", text);
        (_b = e.clipboardData) == null ? void 0 : _b.setData("text/html", html);
        if (isCut) {
          deleteRange({
            range,
            quill: this.quill
          });
        }
      }
      /*
       * https://www.iana.org/assignments/media-types/text/uri-list
       */
      normalizeURIList(urlList) {
        return urlList.split(/\r?\n/).filter((url) => url[0] !== "#").join("\n");
      }
      onCapturePaste(e) {
        var _a2, _b, _c, _d, _e;
        if (e.defaultPrevented || !this.quill.isEnabled()) return;
        e.preventDefault();
        const range = this.quill.getSelection(true);
        if (range == null) return;
        const html = (_a2 = e.clipboardData) == null ? void 0 : _a2.getData("text/html");
        let text = (_b = e.clipboardData) == null ? void 0 : _b.getData("text/plain");
        if (!html && !text) {
          const urlList = (_c = e.clipboardData) == null ? void 0 : _c.getData("text/uri-list");
          if (urlList) {
            text = this.normalizeURIList(urlList);
          }
        }
        const files = Array.from(((_d = e.clipboardData) == null ? void 0 : _d.files) || []);
        if (!html && files.length > 0) {
          this.quill.uploader.upload(range, files);
          return;
        }
        if (html && files.length > 0) {
          const doc = new DOMParser().parseFromString(html, "text/html");
          if (doc.body.childElementCount === 1 && ((_e = doc.body.firstElementChild) == null ? void 0 : _e.tagName) === "IMG") {
            this.quill.uploader.upload(range, files);
            return;
          }
        }
        this.onPaste(range, {
          html,
          text
        });
      }
      onCopy(range) {
        const text = this.quill.getText(range);
        const html = this.quill.getSemanticHTML(range);
        return {
          html,
          text
        };
      }
      onPaste(range, _ref3) {
        let {
          text,
          html
        } = _ref3;
        const formats = this.quill.getFormat(range.index);
        const pastedDelta = this.convert({
          text,
          html
        }, formats);
        debug$1.log("onPaste", pastedDelta, {
          text,
          html
        });
        const delta = new Delta().retain(range.index).delete(range.length).concat(pastedDelta);
        this.quill.updateContents(delta, Quill.sources.USER);
        this.quill.setSelection(delta.length() - range.length, Quill.sources.SILENT);
        this.quill.scrollSelectionIntoView();
      }
      prepareMatching(container, nodeMatches) {
        const elementMatchers = [];
        const textMatchers = [];
        this.matchers.forEach((pair) => {
          const [selector, matcher] = pair;
          switch (selector) {
            case Node.TEXT_NODE:
              textMatchers.push(matcher);
              break;
            case Node.ELEMENT_NODE:
              elementMatchers.push(matcher);
              break;
            default:
              Array.from(container.querySelectorAll(selector)).forEach((node) => {
                if (nodeMatches.has(node)) {
                  const matches = nodeMatches.get(node);
                  matches == null ? void 0 : matches.push(matcher);
                } else {
                  nodeMatches.set(node, [matcher]);
                }
              });
              break;
          }
        });
        return [elementMatchers, textMatchers];
      }
    }
    __publicField(Clipboard, "DEFAULTS", {
      matchers: []
    });
    function applyFormat(delta, format, value2, scroll) {
      if (!scroll.query(format)) {
        return delta;
      }
      return delta.reduce((newDelta, op) => {
        if (!op.insert) return newDelta;
        if (op.attributes && op.attributes[format]) {
          return newDelta.push(op);
        }
        const formats = value2 ? {
          [format]: value2
        } : {};
        return newDelta.insert(op.insert, {
          ...formats,
          ...op.attributes
        });
      }, new Delta());
    }
    function deltaEndsWith(delta, text) {
      let endText = "";
      for (let i = delta.ops.length - 1; i >= 0 && endText.length < text.length; --i) {
        const op = delta.ops[i];
        if (typeof op.insert !== "string") break;
        endText = op.insert + endText;
      }
      return endText.slice(-1 * text.length) === text;
    }
    function isLine(node, scroll) {
      if (!(node instanceof Element)) return false;
      const match2 = scroll.query(node);
      if (match2 && match2.prototype instanceof EmbedBlot$1) return false;
      return ["address", "article", "blockquote", "canvas", "dd", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "iframe", "li", "main", "nav", "ol", "output", "p", "pre", "section", "table", "td", "tr", "ul", "video"].includes(node.tagName.toLowerCase());
    }
    function isBetweenInlineElements(node, scroll) {
      return node.previousElementSibling && node.nextElementSibling && !isLine(node.previousElementSibling, scroll) && !isLine(node.nextElementSibling, scroll);
    }
    const preNodes = /* @__PURE__ */ new WeakMap();
    function isPre(node) {
      if (node == null) return false;
      if (!preNodes.has(node)) {
        if (node.tagName === "PRE") {
          preNodes.set(node, true);
        } else {
          preNodes.set(node, isPre(node.parentNode));
        }
      }
      return preNodes.get(node);
    }
    function traverse(scroll, node, elementMatchers, textMatchers, nodeMatches) {
      if (node.nodeType === node.TEXT_NODE) {
        return textMatchers.reduce((delta, matcher) => {
          return matcher(node, delta, scroll);
        }, new Delta());
      }
      if (node.nodeType === node.ELEMENT_NODE) {
        return Array.from(node.childNodes || []).reduce((delta, childNode) => {
          let childrenDelta = traverse(scroll, childNode, elementMatchers, textMatchers, nodeMatches);
          if (childNode.nodeType === node.ELEMENT_NODE) {
            childrenDelta = elementMatchers.reduce((reducedDelta, matcher) => {
              return matcher(childNode, reducedDelta, scroll);
            }, childrenDelta);
            childrenDelta = (nodeMatches.get(childNode) || []).reduce((reducedDelta, matcher) => {
              return matcher(childNode, reducedDelta, scroll);
            }, childrenDelta);
          }
          return delta.concat(childrenDelta);
        }, new Delta());
      }
      return new Delta();
    }
    function createMatchAlias(format) {
      return (_node, delta, scroll) => {
        return applyFormat(delta, format, true, scroll);
      };
    }
    function matchAttributor(node, delta, scroll) {
      const attributes = Attributor.keys(node);
      const classes = ClassAttributor$1.keys(node);
      const styles2 = StyleAttributor$1.keys(node);
      const formats = {};
      attributes.concat(classes).concat(styles2).forEach((name2) => {
        let attr = scroll.query(name2, Scope.ATTRIBUTE);
        if (attr != null) {
          formats[attr.attrName] = attr.value(node);
          if (formats[attr.attrName]) return;
        }
        attr = ATTRIBUTE_ATTRIBUTORS[name2];
        if (attr != null && (attr.attrName === name2 || attr.keyName === name2)) {
          formats[attr.attrName] = attr.value(node) || void 0;
        }
        attr = STYLE_ATTRIBUTORS[name2];
        if (attr != null && (attr.attrName === name2 || attr.keyName === name2)) {
          attr = STYLE_ATTRIBUTORS[name2];
          formats[attr.attrName] = attr.value(node) || void 0;
        }
      });
      return Object.entries(formats).reduce((newDelta, _ref4) => {
        let [name2, value2] = _ref4;
        return applyFormat(newDelta, name2, value2, scroll);
      }, delta);
    }
    function matchBlot(node, delta, scroll) {
      const match2 = scroll.query(node);
      if (match2 == null) return delta;
      if (match2.prototype instanceof EmbedBlot$1) {
        const embed = {};
        const value2 = match2.value(node);
        if (value2 != null) {
          embed[match2.blotName] = value2;
          return new Delta().insert(embed, match2.formats(node, scroll));
        }
      } else {
        if (match2.prototype instanceof BlockBlot$1 && !deltaEndsWith(delta, "\n")) {
          delta.insert("\n");
        }
        if ("blotName" in match2 && "formats" in match2 && typeof match2.formats === "function") {
          return applyFormat(delta, match2.blotName, match2.formats(node, scroll), scroll);
        }
      }
      return delta;
    }
    function matchBreak(node, delta) {
      if (!deltaEndsWith(delta, "\n")) {
        delta.insert("\n");
      }
      return delta;
    }
    function matchCodeBlock(node, delta, scroll) {
      const match2 = scroll.query("code-block");
      const language = match2 && "formats" in match2 && typeof match2.formats === "function" ? match2.formats(node, scroll) : true;
      return applyFormat(delta, "code-block", language, scroll);
    }
    function matchIgnore() {
      return new Delta();
    }
    function matchIndent(node, delta, scroll) {
      const match2 = scroll.query(node);
      if (match2 == null || // @ts-expect-error
      match2.blotName !== "list" || !deltaEndsWith(delta, "\n")) {
        return delta;
      }
      let indent = -1;
      let parent = node.parentNode;
      while (parent != null) {
        if (["OL", "UL"].includes(parent.tagName)) {
          indent += 1;
        }
        parent = parent.parentNode;
      }
      if (indent <= 0) return delta;
      return delta.reduce((composed, op) => {
        if (!op.insert) return composed;
        if (op.attributes && typeof op.attributes.indent === "number") {
          return composed.push(op);
        }
        return composed.insert(op.insert, {
          indent,
          ...op.attributes || {}
        });
      }, new Delta());
    }
    function matchList(node, delta, scroll) {
      const element = node;
      let list = element.tagName === "OL" ? "ordered" : "bullet";
      const checkedAttr = element.getAttribute("data-checked");
      if (checkedAttr) {
        list = checkedAttr === "true" ? "checked" : "unchecked";
      }
      return applyFormat(delta, "list", list, scroll);
    }
    function matchNewline(node, delta, scroll) {
      if (!deltaEndsWith(delta, "\n")) {
        if (isLine(node, scroll) && (node.childNodes.length > 0 || node instanceof HTMLParagraphElement)) {
          return delta.insert("\n");
        }
        if (delta.length() > 0 && node.nextSibling) {
          let nextSibling = node.nextSibling;
          while (nextSibling != null) {
            if (isLine(nextSibling, scroll)) {
              return delta.insert("\n");
            }
            const match2 = scroll.query(nextSibling);
            if (match2 && match2.prototype instanceof BlockEmbed) {
              return delta.insert("\n");
            }
            nextSibling = nextSibling.firstChild;
          }
        }
      }
      return delta;
    }
    function matchStyles(node, delta, scroll) {
      var _a2;
      const formats = {};
      const style = node.style || {};
      if (style.fontStyle === "italic") {
        formats.italic = true;
      }
      if (style.textDecoration === "underline") {
        formats.underline = true;
      }
      if (style.textDecoration === "line-through") {
        formats.strike = true;
      }
      if (((_a2 = style.fontWeight) == null ? void 0 : _a2.startsWith("bold")) || // @ts-expect-error Fix me later
      parseInt(style.fontWeight, 10) >= 700) {
        formats.bold = true;
      }
      delta = Object.entries(formats).reduce((newDelta, _ref5) => {
        let [name2, value2] = _ref5;
        return applyFormat(newDelta, name2, value2, scroll);
      }, delta);
      if (parseFloat(style.textIndent || 0) > 0) {
        return new Delta().insert("	").concat(delta);
      }
      return delta;
    }
    function matchTable(node, delta, scroll) {
      var _a2, _b;
      const table = ((_a2 = node.parentElement) == null ? void 0 : _a2.tagName) === "TABLE" ? node.parentElement : (_b = node.parentElement) == null ? void 0 : _b.parentElement;
      if (table != null) {
        const rows = Array.from(table.querySelectorAll("tr"));
        const row = rows.indexOf(node) + 1;
        return applyFormat(delta, "table", row, scroll);
      }
      return delta;
    }
    function matchText(node, delta, scroll) {
      var _a2;
      let text = node.data;
      if (((_a2 = node.parentElement) == null ? void 0 : _a2.tagName) === "O:P") {
        return delta.insert(text.trim());
      }
      if (!isPre(node)) {
        if (text.trim().length === 0 && text.includes("\n") && !isBetweenInlineElements(node, scroll)) {
          return delta;
        }
        text = text.replace(/[^\S\u00a0]/g, " ");
        text = text.replace(/ {2,}/g, " ");
        if (node.previousSibling == null && node.parentElement != null && isLine(node.parentElement, scroll) || node.previousSibling instanceof Element && isLine(node.previousSibling, scroll)) {
          text = text.replace(/^ /, "");
        }
        if (node.nextSibling == null && node.parentElement != null && isLine(node.parentElement, scroll) || node.nextSibling instanceof Element && isLine(node.nextSibling, scroll)) {
          text = text.replace(/ $/, "");
        }
        text = text.replaceAll(" ", " ");
      }
      return delta.insert(text);
    }
    class History extends Module {
      constructor(quill, options) {
        super(quill, options);
        __publicField(this, "lastRecorded", 0);
        __publicField(this, "ignoreChange", false);
        __publicField(this, "stack", {
          undo: [],
          redo: []
        });
        __publicField(this, "currentRange", null);
        this.quill.on(Quill.events.EDITOR_CHANGE, (eventName, value2, oldValue, source) => {
          if (eventName === Quill.events.SELECTION_CHANGE) {
            if (value2 && source !== Quill.sources.SILENT) {
              this.currentRange = value2;
            }
          } else if (eventName === Quill.events.TEXT_CHANGE) {
            if (!this.ignoreChange) {
              if (!this.options.userOnly || source === Quill.sources.USER) {
                this.record(value2, oldValue);
              } else {
                this.transform(value2);
              }
            }
            this.currentRange = transformRange(this.currentRange, value2);
          }
        });
        this.quill.keyboard.addBinding({
          key: "z",
          shortKey: true
        }, this.undo.bind(this));
        this.quill.keyboard.addBinding({
          key: ["z", "Z"],
          shortKey: true,
          shiftKey: true
        }, this.redo.bind(this));
        if (/Win/i.test(navigator.platform)) {
          this.quill.keyboard.addBinding({
            key: "y",
            shortKey: true
          }, this.redo.bind(this));
        }
        this.quill.root.addEventListener("beforeinput", (event) => {
          if (event.inputType === "historyUndo") {
            this.undo();
            event.preventDefault();
          } else if (event.inputType === "historyRedo") {
            this.redo();
            event.preventDefault();
          }
        });
      }
      change(source, dest) {
        if (this.stack[source].length === 0) return;
        const item = this.stack[source].pop();
        if (!item) return;
        const base = this.quill.getContents();
        const inverseDelta = item.delta.invert(base);
        this.stack[dest].push({
          delta: inverseDelta,
          range: transformRange(item.range, inverseDelta)
        });
        this.lastRecorded = 0;
        this.ignoreChange = true;
        this.quill.updateContents(item.delta, Quill.sources.USER);
        this.ignoreChange = false;
        this.restoreSelection(item);
      }
      clear() {
        this.stack = {
          undo: [],
          redo: []
        };
      }
      cutoff() {
        this.lastRecorded = 0;
      }
      record(changeDelta, oldDelta) {
        if (changeDelta.ops.length === 0) return;
        this.stack.redo = [];
        let undoDelta = changeDelta.invert(oldDelta);
        let undoRange = this.currentRange;
        const timestamp = Date.now();
        if (
          // @ts-expect-error Fix me later
          this.lastRecorded + this.options.delay > timestamp && this.stack.undo.length > 0
        ) {
          const item = this.stack.undo.pop();
          if (item) {
            undoDelta = undoDelta.compose(item.delta);
            undoRange = item.range;
          }
        } else {
          this.lastRecorded = timestamp;
        }
        if (undoDelta.length() === 0) return;
        this.stack.undo.push({
          delta: undoDelta,
          range: undoRange
        });
        if (this.stack.undo.length > this.options.maxStack) {
          this.stack.undo.shift();
        }
      }
      redo() {
        this.change("redo", "undo");
      }
      transform(delta) {
        transformStack(this.stack.undo, delta);
        transformStack(this.stack.redo, delta);
      }
      undo() {
        this.change("undo", "redo");
      }
      restoreSelection(stackItem) {
        if (stackItem.range) {
          this.quill.setSelection(stackItem.range, Quill.sources.USER);
        } else {
          const index = getLastChangeIndex(this.quill.scroll, stackItem.delta);
          this.quill.setSelection(index, Quill.sources.USER);
        }
      }
    }
    __publicField(History, "DEFAULTS", {
      delay: 1e3,
      maxStack: 100,
      userOnly: false
    });
    function transformStack(stack, delta) {
      let remoteDelta = delta;
      for (let i = stack.length - 1; i >= 0; i -= 1) {
        const oldItem = stack[i];
        stack[i] = {
          delta: remoteDelta.transform(oldItem.delta, true),
          range: oldItem.range && transformRange(oldItem.range, remoteDelta)
        };
        remoteDelta = oldItem.delta.transform(remoteDelta);
        if (stack[i].delta.length() === 0) {
          stack.splice(i, 1);
        }
      }
    }
    function endsWithNewlineChange(scroll, delta) {
      const lastOp = delta.ops[delta.ops.length - 1];
      if (lastOp == null) return false;
      if (lastOp.insert != null) {
        return typeof lastOp.insert === "string" && lastOp.insert.endsWith("\n");
      }
      if (lastOp.attributes != null) {
        return Object.keys(lastOp.attributes).some((attr) => {
          return scroll.query(attr, Scope.BLOCK) != null;
        });
      }
      return false;
    }
    function getLastChangeIndex(scroll, delta) {
      const deleteLength = delta.reduce((length, op) => {
        return length + (op.delete || 0);
      }, 0);
      let changeIndex = delta.length() - deleteLength;
      if (endsWithNewlineChange(scroll, delta)) {
        changeIndex -= 1;
      }
      return changeIndex;
    }
    function transformRange(range, delta) {
      if (!range) return range;
      const start = delta.transformPosition(range.index);
      const end = delta.transformPosition(range.index + range.length);
      return {
        index: start,
        length: end - start
      };
    }
    class Uploader extends Module {
      constructor(quill, options) {
        super(quill, options);
        quill.root.addEventListener("drop", (e) => {
          var _a2;
          e.preventDefault();
          let native = null;
          if (document.caretRangeFromPoint) {
            native = document.caretRangeFromPoint(e.clientX, e.clientY);
          } else if (document.caretPositionFromPoint) {
            const position = document.caretPositionFromPoint(e.clientX, e.clientY);
            native = document.createRange();
            native.setStart(position.offsetNode, position.offset);
            native.setEnd(position.offsetNode, position.offset);
          }
          const normalized = native && quill.selection.normalizeNative(native);
          if (normalized) {
            const range = quill.selection.normalizedToRange(normalized);
            if ((_a2 = e.dataTransfer) == null ? void 0 : _a2.files) {
              this.upload(range, e.dataTransfer.files);
            }
          }
        });
      }
      upload(range, files) {
        const uploads = [];
        Array.from(files).forEach((file) => {
          var _a2;
          if (file && ((_a2 = this.options.mimetypes) == null ? void 0 : _a2.includes(file.type))) {
            uploads.push(file);
          }
        });
        if (uploads.length > 0) {
          this.options.handler.call(this, range, uploads);
        }
      }
    }
    Uploader.DEFAULTS = {
      mimetypes: ["image/png", "image/jpeg"],
      handler(range, files) {
        if (!this.quill.scroll.query("image")) {
          return;
        }
        const promises = files.map((file) => {
          return new Promise((resolve) => {
            const reader = new FileReader();
            reader.onload = () => {
              resolve(reader.result);
            };
            reader.readAsDataURL(file);
          });
        });
        Promise.all(promises).then((images) => {
          const update = images.reduce((delta, image) => {
            return delta.insert({
              image
            });
          }, new Delta().retain(range.index).delete(range.length));
          this.quill.updateContents(update, Emitter.sources.USER);
          this.quill.setSelection(range.index + images.length, Emitter.sources.SILENT);
        });
      }
    };
    const INSERT_TYPES = ["insertText", "insertReplacementText"];
    class Input extends Module {
      constructor(quill, options) {
        super(quill, options);
        quill.root.addEventListener("beforeinput", (event) => {
          this.handleBeforeInput(event);
        });
        if (!/Android/i.test(navigator.userAgent)) {
          quill.on(Quill.events.COMPOSITION_BEFORE_START, () => {
            this.handleCompositionStart();
          });
        }
      }
      deleteRange(range) {
        deleteRange({
          range,
          quill: this.quill
        });
      }
      replaceText(range) {
        let text = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
        if (range.length === 0) return false;
        if (text) {
          const formats = this.quill.getFormat(range.index, 1);
          this.deleteRange(range);
          this.quill.updateContents(new Delta().retain(range.index).insert(text, formats), Quill.sources.USER);
        } else {
          this.deleteRange(range);
        }
        this.quill.setSelection(range.index + text.length, 0, Quill.sources.SILENT);
        return true;
      }
      handleBeforeInput(event) {
        if (this.quill.composition.isComposing || event.defaultPrevented || !INSERT_TYPES.includes(event.inputType)) {
          return;
        }
        const staticRange = event.getTargetRanges ? event.getTargetRanges()[0] : null;
        if (!staticRange || staticRange.collapsed === true) {
          return;
        }
        const text = getPlainTextFromInputEvent(event);
        if (text == null) {
          return;
        }
        const normalized = this.quill.selection.normalizeNative(staticRange);
        const range = normalized ? this.quill.selection.normalizedToRange(normalized) : null;
        if (range && this.replaceText(range, text)) {
          event.preventDefault();
        }
      }
      handleCompositionStart() {
        const range = this.quill.getSelection();
        if (range) {
          this.replaceText(range);
        }
      }
    }
    function getPlainTextFromInputEvent(event) {
      var _a2;
      if (typeof event.data === "string") {
        return event.data;
      }
      if ((_a2 = event.dataTransfer) == null ? void 0 : _a2.types.includes("text/plain")) {
        return event.dataTransfer.getData("text/plain");
      }
      return null;
    }
    const isMac = /Mac/i.test(navigator.platform);
    const TTL_FOR_VALID_SELECTION_CHANGE = 100;
    const canMoveCaretBeforeUINode = (event) => {
      if (event.key === "ArrowLeft" || event.key === "ArrowRight" || // RTL scripts or moving from the end of the previous line
      event.key === "ArrowUp" || event.key === "ArrowDown" || event.key === "Home") {
        return true;
      }
      if (isMac && event.key === "a" && event.ctrlKey === true) {
        return true;
      }
      return false;
    };
    class UINode extends Module {
      constructor(quill, options) {
        super(quill, options);
        __publicField(this, "isListening", false);
        __publicField(this, "selectionChangeDeadline", 0);
        this.handleArrowKeys();
        this.handleNavigationShortcuts();
      }
      handleArrowKeys() {
        this.quill.keyboard.addBinding({
          key: ["ArrowLeft", "ArrowRight"],
          offset: 0,
          shiftKey: null,
          handler(range, _ref) {
            let {
              line,
              event
            } = _ref;
            if (!(line instanceof ParentBlot$1) || !line.uiNode) {
              return true;
            }
            const isRTL = getComputedStyle(line.domNode)["direction"] === "rtl";
            if (isRTL && event.key !== "ArrowRight" || !isRTL && event.key !== "ArrowLeft") {
              return true;
            }
            this.quill.setSelection(range.index - 1, range.length + (event.shiftKey ? 1 : 0), Quill.sources.USER);
            return false;
          }
        });
      }
      handleNavigationShortcuts() {
        this.quill.root.addEventListener("keydown", (event) => {
          if (!event.defaultPrevented && canMoveCaretBeforeUINode(event)) {
            this.ensureListeningToSelectionChange();
          }
        });
      }
      /**
       * We only listen to the `selectionchange` event when
       * there is an intention of moving the caret to the beginning using shortcuts.
       * This is primarily implemented to prevent infinite loops, as we are changing
       * the selection within the handler of a `selectionchange` event.
       */
      ensureListeningToSelectionChange() {
        this.selectionChangeDeadline = Date.now() + TTL_FOR_VALID_SELECTION_CHANGE;
        if (this.isListening) return;
        this.isListening = true;
        const listener = () => {
          this.isListening = false;
          if (Date.now() <= this.selectionChangeDeadline) {
            this.handleSelectionChange();
          }
        };
        document.addEventListener("selectionchange", listener, {
          once: true
        });
      }
      handleSelectionChange() {
        const selection = document.getSelection();
        if (!selection) return;
        const range = selection.getRangeAt(0);
        if (range.collapsed !== true || range.startOffset !== 0) return;
        const line = this.quill.scroll.find(range.startContainer);
        if (!(line instanceof ParentBlot$1) || !line.uiNode) return;
        const newRange = document.createRange();
        newRange.setStartAfter(line.uiNode);
        newRange.setEndAfter(line.uiNode);
        selection.removeAllRanges();
        selection.addRange(newRange);
      }
    }
    Quill.register({
      "blots/block": Block,
      "blots/block/embed": BlockEmbed,
      "blots/break": Break,
      "blots/container": Container,
      "blots/cursor": Cursor,
      "blots/embed": Embed,
      "blots/inline": Inline$1,
      "blots/scroll": Scroll,
      "blots/text": Text$1,
      "modules/clipboard": Clipboard,
      "modules/history": History,
      "modules/keyboard": Keyboard,
      "modules/uploader": Uploader,
      "modules/input": Input,
      "modules/uiNode": UINode
    });
    class IndentAttributor extends ClassAttributor$1 {
      add(node, value2) {
        let normalizedValue = 0;
        if (value2 === "+1" || value2 === "-1") {
          const indent = this.value(node) || 0;
          normalizedValue = value2 === "+1" ? indent + 1 : indent - 1;
        } else if (typeof value2 === "number") {
          normalizedValue = value2;
        }
        if (normalizedValue === 0) {
          this.remove(node);
          return true;
        }
        return super.add(node, normalizedValue.toString());
      }
      canAdd(node, value2) {
        return super.canAdd(node, value2) || super.canAdd(node, parseInt(value2, 10));
      }
      value(node) {
        return parseInt(super.value(node), 10) || void 0;
      }
    }
    const IndentClass = new IndentAttributor("indent", "ql-indent", {
      scope: Scope.BLOCK,
      // @ts-expect-error
      whitelist: [1, 2, 3, 4, 5, 6, 7, 8]
    });
    class Blockquote extends Block {
    }
    __publicField(Blockquote, "blotName", "blockquote");
    __publicField(Blockquote, "tagName", "blockquote");
    class Header extends Block {
      static formats(domNode) {
        return this.tagName.indexOf(domNode.tagName) + 1;
      }
    }
    __publicField(Header, "blotName", "header");
    __publicField(Header, "tagName", ["H1", "H2", "H3", "H4", "H5", "H6"]);
    class ListContainer extends Container {
    }
    ListContainer.blotName = "list-container";
    ListContainer.tagName = "OL";
    class ListItem extends Block {
      static create(value2) {
        const node = super.create();
        node.setAttribute("data-list", value2);
        return node;
      }
      static formats(domNode) {
        return domNode.getAttribute("data-list") || void 0;
      }
      static register() {
        Quill.register(ListContainer);
      }
      constructor(scroll, domNode) {
        super(scroll, domNode);
        const ui = domNode.ownerDocument.createElement("span");
        const listEventHandler = (e) => {
          if (!scroll.isEnabled()) return;
          const format = this.statics.formats(domNode, scroll);
          if (format === "checked") {
            this.format("list", "unchecked");
            e.preventDefault();
          } else if (format === "unchecked") {
            this.format("list", "checked");
            e.preventDefault();
          }
        };
        ui.addEventListener("mousedown", listEventHandler);
        ui.addEventListener("touchstart", listEventHandler);
        this.attachUI(ui);
      }
      format(name2, value2) {
        if (name2 === this.statics.blotName && value2) {
          this.domNode.setAttribute("data-list", value2);
        } else {
          super.format(name2, value2);
        }
      }
    }
    ListItem.blotName = "list";
    ListItem.tagName = "LI";
    ListContainer.allowedChildren = [ListItem];
    ListItem.requiredContainer = ListContainer;
    class Bold extends Inline$1 {
      static create() {
        return super.create();
      }
      static formats() {
        return true;
      }
      optimize(context) {
        super.optimize(context);
        if (this.domNode.tagName !== this.statics.tagName[0]) {
          this.replaceWith(this.statics.blotName);
        }
      }
    }
    __publicField(Bold, "blotName", "bold");
    __publicField(Bold, "tagName", ["STRONG", "B"]);
    class Italic extends Bold {
    }
    __publicField(Italic, "blotName", "italic");
    __publicField(Italic, "tagName", ["EM", "I"]);
    class Link extends Inline$1 {
      static create(value2) {
        const node = super.create(value2);
        node.setAttribute("href", this.sanitize(value2));
        node.setAttribute("rel", "noopener noreferrer");
        node.setAttribute("target", "_blank");
        return node;
      }
      static formats(domNode) {
        return domNode.getAttribute("href");
      }
      static sanitize(url) {
        return sanitize(url, this.PROTOCOL_WHITELIST) ? url : this.SANITIZED_URL;
      }
      format(name2, value2) {
        if (name2 !== this.statics.blotName || !value2) {
          super.format(name2, value2);
        } else {
          this.domNode.setAttribute("href", this.constructor.sanitize(value2));
        }
      }
    }
    __publicField(Link, "blotName", "link");
    __publicField(Link, "tagName", "A");
    __publicField(Link, "SANITIZED_URL", "about:blank");
    __publicField(Link, "PROTOCOL_WHITELIST", ["http", "https", "mailto", "tel", "sms"]);
    function sanitize(url, protocols) {
      const anchor = document.createElement("a");
      anchor.href = url;
      const protocol = anchor.href.slice(0, anchor.href.indexOf(":"));
      return protocols.indexOf(protocol) > -1;
    }
    class Script extends Inline$1 {
      static create(value2) {
        if (value2 === "super") {
          return document.createElement("sup");
        }
        if (value2 === "sub") {
          return document.createElement("sub");
        }
        return super.create(value2);
      }
      static formats(domNode) {
        if (domNode.tagName === "SUB") return "sub";
        if (domNode.tagName === "SUP") return "super";
        return void 0;
      }
    }
    __publicField(Script, "blotName", "script");
    __publicField(Script, "tagName", ["SUB", "SUP"]);
    class Strike extends Bold {
    }
    __publicField(Strike, "blotName", "strike");
    __publicField(Strike, "tagName", ["S", "STRIKE"]);
    class Underline extends Inline$1 {
    }
    __publicField(Underline, "blotName", "underline");
    __publicField(Underline, "tagName", "U");
    class Formula extends Embed {
      static create(value2) {
        if (window.katex == null) {
          throw new Error("Formula module requires KaTeX.");
        }
        const node = super.create(value2);
        if (typeof value2 === "string") {
          window.katex.render(value2, node, {
            throwOnError: false,
            errorColor: "#f00"
          });
          node.setAttribute("data-value", value2);
        }
        return node;
      }
      static value(domNode) {
        return domNode.getAttribute("data-value");
      }
      html() {
        const {
          formula
        } = this.value();
        return `<span>${formula}</span>`;
      }
    }
    __publicField(Formula, "blotName", "formula");
    __publicField(Formula, "className", "ql-formula");
    __publicField(Formula, "tagName", "SPAN");
    const ATTRIBUTES$1 = ["alt", "height", "width"];
    class Image extends EmbedBlot$1 {
      static create(value2) {
        const node = super.create(value2);
        if (typeof value2 === "string") {
          node.setAttribute("src", this.sanitize(value2));
        }
        return node;
      }
      static formats(domNode) {
        return ATTRIBUTES$1.reduce((formats, attribute) => {
          if (domNode.hasAttribute(attribute)) {
            formats[attribute] = domNode.getAttribute(attribute);
          }
          return formats;
        }, {});
      }
      static match(url) {
        return /\.(jpe?g|gif|png)$/.test(url) || /^data:image\/.+;base64/.test(url);
      }
      static sanitize(url) {
        return sanitize(url, ["http", "https", "data"]) ? url : "//:0";
      }
      static value(domNode) {
        return domNode.getAttribute("src");
      }
      format(name2, value2) {
        if (ATTRIBUTES$1.indexOf(name2) > -1) {
          if (value2) {
            this.domNode.setAttribute(name2, value2);
          } else {
            this.domNode.removeAttribute(name2);
          }
        } else {
          super.format(name2, value2);
        }
      }
    }
    __publicField(Image, "blotName", "image");
    __publicField(Image, "tagName", "IMG");
    const ATTRIBUTES = ["height", "width"];
    class Video extends BlockEmbed {
      static create(value2) {
        const node = super.create(value2);
        node.setAttribute("frameborder", "0");
        node.setAttribute("allowfullscreen", "true");
        node.setAttribute("src", this.sanitize(value2));
        return node;
      }
      static formats(domNode) {
        return ATTRIBUTES.reduce((formats, attribute) => {
          if (domNode.hasAttribute(attribute)) {
            formats[attribute] = domNode.getAttribute(attribute);
          }
          return formats;
        }, {});
      }
      static sanitize(url) {
        return Link.sanitize(url);
      }
      static value(domNode) {
        return domNode.getAttribute("src");
      }
      format(name2, value2) {
        if (ATTRIBUTES.indexOf(name2) > -1) {
          if (value2) {
            this.domNode.setAttribute(name2, value2);
          } else {
            this.domNode.removeAttribute(name2);
          }
        } else {
          super.format(name2, value2);
        }
      }
      html() {
        const {
          video
        } = this.value();
        return `<a href="${video}">${video}</a>`;
      }
    }
    __publicField(Video, "blotName", "video");
    __publicField(Video, "className", "ql-video");
    __publicField(Video, "tagName", "IFRAME");
    const TokenAttributor = new ClassAttributor$1("code-token", "hljs", {
      scope: Scope.INLINE
    });
    class CodeToken extends Inline$1 {
      static formats(node, scroll) {
        while (node != null && node !== scroll.domNode) {
          if (node.classList && node.classList.contains(CodeBlock.className)) {
            return super.formats(node, scroll);
          }
          node = node.parentNode;
        }
        return void 0;
      }
      constructor(scroll, domNode, value2) {
        super(scroll, domNode, value2);
        TokenAttributor.add(this.domNode, value2);
      }
      format(format, value2) {
        if (format !== CodeToken.blotName) {
          super.format(format, value2);
        } else if (value2) {
          TokenAttributor.add(this.domNode, value2);
        } else {
          TokenAttributor.remove(this.domNode);
          this.domNode.classList.remove(this.statics.className);
        }
      }
      optimize() {
        super.optimize(...arguments);
        if (!TokenAttributor.value(this.domNode)) {
          this.unwrap();
        }
      }
    }
    CodeToken.blotName = "code-token";
    CodeToken.className = "ql-token";
    class SyntaxCodeBlock extends CodeBlock {
      static create(value2) {
        const domNode = super.create(value2);
        if (typeof value2 === "string") {
          domNode.setAttribute("data-language", value2);
        }
        return domNode;
      }
      static formats(domNode) {
        return domNode.getAttribute("data-language") || "plain";
      }
      static register() {
      }
      // Syntax module will register
      format(name2, value2) {
        if (name2 === this.statics.blotName && value2) {
          this.domNode.setAttribute("data-language", value2);
        } else {
          super.format(name2, value2);
        }
      }
      replaceWith(name2, value2) {
        this.formatAt(0, this.length(), CodeToken.blotName, false);
        return super.replaceWith(name2, value2);
      }
    }
    class SyntaxCodeBlockContainer extends CodeBlockContainer {
      attach() {
        super.attach();
        this.forceNext = false;
        this.scroll.emitMount(this);
      }
      format(name2, value2) {
        if (name2 === SyntaxCodeBlock.blotName) {
          this.forceNext = true;
          this.children.forEach((child) => {
            child.format(name2, value2);
          });
        }
      }
      formatAt(index, length, name2, value2) {
        if (name2 === SyntaxCodeBlock.blotName) {
          this.forceNext = true;
        }
        super.formatAt(index, length, name2, value2);
      }
      highlight(highlight2) {
        let forced = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        if (this.children.head == null) return;
        const nodes = Array.from(this.domNode.childNodes).filter((node) => node !== this.uiNode);
        const text = `${nodes.map((node) => node.textContent).join("\n")}
`;
        const language = SyntaxCodeBlock.formats(this.children.head.domNode);
        if (forced || this.forceNext || this.cachedText !== text) {
          if (text.trim().length > 0 || this.cachedText == null) {
            const oldDelta = this.children.reduce((delta2, child) => {
              return delta2.concat(blockDelta(child, false));
            }, new Delta());
            const delta = highlight2(text, language);
            oldDelta.diff(delta).reduce((index, _ref) => {
              let {
                retain,
                attributes
              } = _ref;
              if (!retain) return index;
              if (attributes) {
                Object.keys(attributes).forEach((format) => {
                  if ([SyntaxCodeBlock.blotName, CodeToken.blotName].includes(format)) {
                    this.formatAt(index, retain, format, attributes[format]);
                  }
                });
              }
              return index + retain;
            }, 0);
          }
          this.cachedText = text;
          this.forceNext = false;
        }
      }
      html(index, length) {
        const [codeBlock] = this.children.find(index);
        const language = codeBlock ? SyntaxCodeBlock.formats(codeBlock.domNode) : "plain";
        return `<pre data-language="${language}">
${escapeText(this.code(index, length))}
</pre>`;
      }
      optimize(context) {
        super.optimize(context);
        if (this.parent != null && this.children.head != null && this.uiNode != null) {
          const language = SyntaxCodeBlock.formats(this.children.head.domNode);
          if (language !== this.uiNode.value) {
            this.uiNode.value = language;
          }
        }
      }
    }
    SyntaxCodeBlockContainer.allowedChildren = [SyntaxCodeBlock];
    SyntaxCodeBlock.requiredContainer = SyntaxCodeBlockContainer;
    SyntaxCodeBlock.allowedChildren = [CodeToken, Cursor, Text$1, Break];
    const highlight = (lib2, language, text) => {
      if (typeof lib2.versionString === "string") {
        const majorVersion = lib2.versionString.split(".")[0];
        if (parseInt(majorVersion, 10) >= 11) {
          return lib2.highlight(text, {
            language
          }).value;
        }
      }
      return lib2.highlight(language, text).value;
    };
    class Syntax extends Module {
      static register() {
        Quill.register(CodeToken, true);
        Quill.register(SyntaxCodeBlock, true);
        Quill.register(SyntaxCodeBlockContainer, true);
      }
      constructor(quill, options) {
        super(quill, options);
        if (this.options.hljs == null) {
          throw new Error("Syntax module requires highlight.js. Please include the library on the page before Quill.");
        }
        this.languages = this.options.languages.reduce((memo, _ref2) => {
          let {
            key
          } = _ref2;
          memo[key] = true;
          return memo;
        }, {});
        this.highlightBlot = this.highlightBlot.bind(this);
        this.initListener();
        this.initTimer();
      }
      initListener() {
        this.quill.on(Quill.events.SCROLL_BLOT_MOUNT, (blot) => {
          if (!(blot instanceof SyntaxCodeBlockContainer)) return;
          const select2 = this.quill.root.ownerDocument.createElement("select");
          this.options.languages.forEach((_ref3) => {
            let {
              key,
              label
            } = _ref3;
            const option2 = select2.ownerDocument.createElement("option");
            option2.textContent = label;
            option2.setAttribute("value", key);
            select2.appendChild(option2);
          });
          select2.addEventListener("change", () => {
            blot.format(SyntaxCodeBlock.blotName, select2.value);
            this.quill.root.focus();
            this.highlight(blot, true);
          });
          if (blot.uiNode == null) {
            blot.attachUI(select2);
            if (blot.children.head) {
              select2.value = SyntaxCodeBlock.formats(blot.children.head.domNode);
            }
          }
        });
      }
      initTimer() {
        let timer = null;
        this.quill.on(Quill.events.SCROLL_OPTIMIZE, () => {
          if (timer) {
            clearTimeout(timer);
          }
          timer = setTimeout(() => {
            this.highlight();
            timer = null;
          }, this.options.interval);
        });
      }
      highlight() {
        let blot = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        let force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        if (this.quill.selection.composing) return;
        this.quill.update(Quill.sources.USER);
        const range = this.quill.getSelection();
        const blots = blot == null ? this.quill.scroll.descendants(SyntaxCodeBlockContainer) : [blot];
        blots.forEach((container) => {
          container.highlight(this.highlightBlot, force);
        });
        this.quill.update(Quill.sources.SILENT);
        if (range != null) {
          this.quill.setSelection(range, Quill.sources.SILENT);
        }
      }
      highlightBlot(text) {
        let language = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "plain";
        language = this.languages[language] ? language : "plain";
        if (language === "plain") {
          return escapeText(text).split("\n").reduce((delta, line, i) => {
            if (i !== 0) {
              delta.insert("\n", {
                [CodeBlock.blotName]: language
              });
            }
            return delta.insert(line);
          }, new Delta());
        }
        const container = this.quill.root.ownerDocument.createElement("div");
        container.classList.add(CodeBlock.className);
        container.innerHTML = highlight(this.options.hljs, language, text);
        return traverse(this.quill.scroll, container, [(node, delta) => {
          const value2 = TokenAttributor.value(node);
          if (value2) {
            return delta.compose(new Delta().retain(delta.length(), {
              [CodeToken.blotName]: value2
            }));
          }
          return delta;
        }], [(node, delta) => {
          return node.data.split("\n").reduce((memo, nodeText, i) => {
            if (i !== 0) memo.insert("\n", {
              [CodeBlock.blotName]: language
            });
            return memo.insert(nodeText);
          }, delta);
        }], /* @__PURE__ */ new WeakMap());
      }
    }
    Syntax.DEFAULTS = {
      hljs: (() => {
        return window.hljs;
      })(),
      interval: 1e3,
      languages: [{
        key: "plain",
        label: "Plain"
      }, {
        key: "bash",
        label: "Bash"
      }, {
        key: "cpp",
        label: "C++"
      }, {
        key: "cs",
        label: "C#"
      }, {
        key: "css",
        label: "CSS"
      }, {
        key: "diff",
        label: "Diff"
      }, {
        key: "xml",
        label: "HTML/XML"
      }, {
        key: "java",
        label: "Java"
      }, {
        key: "javascript",
        label: "JavaScript"
      }, {
        key: "markdown",
        label: "Markdown"
      }, {
        key: "php",
        label: "PHP"
      }, {
        key: "python",
        label: "Python"
      }, {
        key: "ruby",
        label: "Ruby"
      }, {
        key: "sql",
        label: "SQL"
      }]
    };
    const _TableCell = class _TableCell extends Block {
      static create(value2) {
        const node = super.create();
        if (value2) {
          node.setAttribute("data-row", value2);
        } else {
          node.setAttribute("data-row", tableId());
        }
        return node;
      }
      static formats(domNode) {
        if (domNode.hasAttribute("data-row")) {
          return domNode.getAttribute("data-row");
        }
        return void 0;
      }
      cellOffset() {
        if (this.parent) {
          return this.parent.children.indexOf(this);
        }
        return -1;
      }
      format(name2, value2) {
        if (name2 === _TableCell.blotName && value2) {
          this.domNode.setAttribute("data-row", value2);
        } else {
          super.format(name2, value2);
        }
      }
      row() {
        return this.parent;
      }
      rowOffset() {
        if (this.row()) {
          return this.row().rowOffset();
        }
        return -1;
      }
      table() {
        return this.row() && this.row().table();
      }
    };
    __publicField(_TableCell, "blotName", "table");
    __publicField(_TableCell, "tagName", "TD");
    let TableCell = _TableCell;
    class TableRow extends Container {
      checkMerge() {
        if (super.checkMerge() && this.next.children.head != null) {
          const thisHead = this.children.head.formats();
          const thisTail = this.children.tail.formats();
          const nextHead = this.next.children.head.formats();
          const nextTail = this.next.children.tail.formats();
          return thisHead.table === thisTail.table && thisHead.table === nextHead.table && thisHead.table === nextTail.table;
        }
        return false;
      }
      optimize(context) {
        super.optimize(context);
        this.children.forEach((child) => {
          if (child.next == null) return;
          const childFormats = child.formats();
          const nextFormats = child.next.formats();
          if (childFormats.table !== nextFormats.table) {
            const next = this.splitAfter(child);
            if (next) {
              next.optimize();
            }
            if (this.prev) {
              this.prev.optimize();
            }
          }
        });
      }
      rowOffset() {
        if (this.parent) {
          return this.parent.children.indexOf(this);
        }
        return -1;
      }
      table() {
        return this.parent && this.parent.parent;
      }
    }
    __publicField(TableRow, "blotName", "table-row");
    __publicField(TableRow, "tagName", "TR");
    class TableBody extends Container {
    }
    __publicField(TableBody, "blotName", "table-body");
    __publicField(TableBody, "tagName", "TBODY");
    class TableContainer extends Container {
      balanceCells() {
        const rows = this.descendants(TableRow);
        const maxColumns = rows.reduce((max2, row) => {
          return Math.max(row.children.length, max2);
        }, 0);
        rows.forEach((row) => {
          new Array(maxColumns - row.children.length).fill(0).forEach(() => {
            let value2;
            if (row.children.head != null) {
              value2 = TableCell.formats(row.children.head.domNode);
            }
            const blot = this.scroll.create(TableCell.blotName, value2);
            row.appendChild(blot);
            blot.optimize();
          });
        });
      }
      cells(column) {
        return this.rows().map((row) => row.children.at(column));
      }
      deleteColumn(index) {
        const [body2] = this.descendant(TableBody);
        if (body2 == null || body2.children.head == null) return;
        body2.children.forEach((row) => {
          const cell = row.children.at(index);
          if (cell != null) {
            cell.remove();
          }
        });
      }
      insertColumn(index) {
        const [body2] = this.descendant(TableBody);
        if (body2 == null || body2.children.head == null) return;
        body2.children.forEach((row) => {
          const ref = row.children.at(index);
          const value2 = TableCell.formats(row.children.head.domNode);
          const cell = this.scroll.create(TableCell.blotName, value2);
          row.insertBefore(cell, ref);
        });
      }
      insertRow(index) {
        const [body2] = this.descendant(TableBody);
        if (body2 == null || body2.children.head == null) return;
        const id = tableId();
        const row = this.scroll.create(TableRow.blotName);
        body2.children.head.children.forEach(() => {
          const cell = this.scroll.create(TableCell.blotName, id);
          row.appendChild(cell);
        });
        const ref = body2.children.at(index);
        body2.insertBefore(row, ref);
      }
      rows() {
        const body2 = this.children.head;
        if (body2 == null) return [];
        return body2.children.map((row) => row);
      }
    }
    __publicField(TableContainer, "blotName", "table-container");
    __publicField(TableContainer, "tagName", "TABLE");
    TableContainer.allowedChildren = [TableBody];
    TableBody.requiredContainer = TableContainer;
    TableBody.allowedChildren = [TableRow];
    TableRow.requiredContainer = TableBody;
    TableRow.allowedChildren = [TableCell];
    TableCell.requiredContainer = TableRow;
    function tableId() {
      const id = Math.random().toString(36).slice(2, 6);
      return `row-${id}`;
    }
    class Table extends Module {
      static register() {
        Quill.register(TableCell);
        Quill.register(TableRow);
        Quill.register(TableBody);
        Quill.register(TableContainer);
      }
      constructor() {
        super(...arguments);
        this.listenBalanceCells();
      }
      balanceTables() {
        this.quill.scroll.descendants(TableContainer).forEach((table) => {
          table.balanceCells();
        });
      }
      deleteColumn() {
        const [table, , cell] = this.getTable();
        if (cell == null) return;
        table.deleteColumn(cell.cellOffset());
        this.quill.update(Quill.sources.USER);
      }
      deleteRow() {
        const [, row] = this.getTable();
        if (row == null) return;
        row.remove();
        this.quill.update(Quill.sources.USER);
      }
      deleteTable() {
        const [table] = this.getTable();
        if (table == null) return;
        const offset = table.offset();
        table.remove();
        this.quill.update(Quill.sources.USER);
        this.quill.setSelection(offset, Quill.sources.SILENT);
      }
      getTable() {
        let range = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.quill.getSelection();
        if (range == null) return [null, null, null, -1];
        const [cell, offset] = this.quill.getLine(range.index);
        if (cell == null || cell.statics.blotName !== TableCell.blotName) {
          return [null, null, null, -1];
        }
        const row = cell.parent;
        const table = row.parent.parent;
        return [table, row, cell, offset];
      }
      insertColumn(offset) {
        const range = this.quill.getSelection();
        if (!range) return;
        const [table, row, cell] = this.getTable(range);
        if (cell == null) return;
        const column = cell.cellOffset();
        table.insertColumn(column + offset);
        this.quill.update(Quill.sources.USER);
        let shift = row.rowOffset();
        if (offset === 0) {
          shift += 1;
        }
        this.quill.setSelection(range.index + shift, range.length, Quill.sources.SILENT);
      }
      insertColumnLeft() {
        this.insertColumn(0);
      }
      insertColumnRight() {
        this.insertColumn(1);
      }
      insertRow(offset) {
        const range = this.quill.getSelection();
        if (!range) return;
        const [table, row, cell] = this.getTable(range);
        if (cell == null) return;
        const index = row.rowOffset();
        table.insertRow(index + offset);
        this.quill.update(Quill.sources.USER);
        if (offset > 0) {
          this.quill.setSelection(range, Quill.sources.SILENT);
        } else {
          this.quill.setSelection(range.index + row.children.length, range.length, Quill.sources.SILENT);
        }
      }
      insertRowAbove() {
        this.insertRow(0);
      }
      insertRowBelow() {
        this.insertRow(1);
      }
      insertTable(rows, columns) {
        const range = this.quill.getSelection();
        if (range == null) return;
        const delta = new Array(rows).fill(0).reduce((memo) => {
          const text = new Array(columns).fill("\n").join("");
          return memo.insert(text, {
            table: tableId()
          });
        }, new Delta().retain(range.index));
        this.quill.updateContents(delta, Quill.sources.USER);
        this.quill.setSelection(range.index, Quill.sources.SILENT);
        this.balanceTables();
      }
      listenBalanceCells() {
        this.quill.on(Quill.events.SCROLL_OPTIMIZE, (mutations) => {
          mutations.some((mutation) => {
            if (["TD", "TR", "TBODY", "TABLE"].includes(mutation.target.tagName)) {
              this.quill.once(Quill.events.TEXT_CHANGE, (delta, old, source) => {
                if (source !== Quill.sources.USER) return;
                this.balanceTables();
              });
              return true;
            }
            return false;
          });
        });
      }
    }
    const debug = namespace("quill:toolbar");
    class Toolbar extends Module {
      constructor(quill, options) {
        var _a2, _b;
        super(quill, options);
        if (Array.isArray(this.options.container)) {
          const container = document.createElement("div");
          container.setAttribute("role", "toolbar");
          addControls(container, this.options.container);
          (_b = (_a2 = quill.container) == null ? void 0 : _a2.parentNode) == null ? void 0 : _b.insertBefore(container, quill.container);
          this.container = container;
        } else if (typeof this.options.container === "string") {
          this.container = document.querySelector(this.options.container);
        } else {
          this.container = this.options.container;
        }
        if (!(this.container instanceof HTMLElement)) {
          debug.error("Container required for toolbar", this.options);
          return;
        }
        this.container.classList.add("ql-toolbar");
        this.controls = [];
        this.handlers = {};
        if (this.options.handlers) {
          Object.keys(this.options.handlers).forEach((format) => {
            var _a3;
            const handler = (_a3 = this.options.handlers) == null ? void 0 : _a3[format];
            if (handler) {
              this.addHandler(format, handler);
            }
          });
        }
        Array.from(this.container.querySelectorAll("button, select")).forEach((input2) => {
          this.attach(input2);
        });
        this.quill.on(Quill.events.EDITOR_CHANGE, () => {
          const [range] = this.quill.selection.getRange();
          this.update(range);
        });
      }
      addHandler(format, handler) {
        this.handlers[format] = handler;
      }
      attach(input2) {
        let format = Array.from(input2.classList).find((className) => {
          return className.indexOf("ql-") === 0;
        });
        if (!format) return;
        format = format.slice("ql-".length);
        if (input2.tagName === "BUTTON") {
          input2.setAttribute("type", "button");
        }
        if (this.handlers[format] == null && this.quill.scroll.query(format) == null) {
          debug.warn("ignoring attaching to nonexistent format", format, input2);
          return;
        }
        const eventName = input2.tagName === "SELECT" ? "change" : "click";
        input2.addEventListener(eventName, (e) => {
          let value2;
          if (input2.tagName === "SELECT") {
            if (input2.selectedIndex < 0) return;
            const selected = input2.options[input2.selectedIndex];
            if (selected.hasAttribute("selected")) {
              value2 = false;
            } else {
              value2 = selected.value || false;
            }
          } else {
            if (input2.classList.contains("ql-active")) {
              value2 = false;
            } else {
              value2 = input2.value || !input2.hasAttribute("value");
            }
            e.preventDefault();
          }
          this.quill.focus();
          const [range] = this.quill.selection.getRange();
          if (this.handlers[format] != null) {
            this.handlers[format].call(this, value2);
          } else if (
            // @ts-expect-error
            this.quill.scroll.query(format).prototype instanceof EmbedBlot$1
          ) {
            value2 = prompt(`Enter ${format}`);
            if (!value2) return;
            this.quill.updateContents(new Delta().retain(range.index).delete(range.length).insert({
              [format]: value2
            }), Quill.sources.USER);
          } else {
            this.quill.format(format, value2, Quill.sources.USER);
          }
          this.update(range);
        });
        this.controls.push([format, input2]);
      }
      update(range) {
        const formats = range == null ? {} : this.quill.getFormat(range);
        this.controls.forEach((pair) => {
          const [format, input2] = pair;
          if (input2.tagName === "SELECT") {
            let option2 = null;
            if (range == null) {
              option2 = null;
            } else if (formats[format] == null) {
              option2 = input2.querySelector("option[selected]");
            } else if (!Array.isArray(formats[format])) {
              let value2 = formats[format];
              if (typeof value2 === "string") {
                value2 = value2.replace(/"/g, '\\"');
              }
              option2 = input2.querySelector(`option[value="${value2}"]`);
            }
            if (option2 == null) {
              input2.value = "";
              input2.selectedIndex = -1;
            } else {
              option2.selected = true;
            }
          } else if (range == null) {
            input2.classList.remove("ql-active");
            input2.setAttribute("aria-pressed", "false");
          } else if (input2.hasAttribute("value")) {
            const value2 = formats[format];
            const isActive = value2 === input2.getAttribute("value") || value2 != null && value2.toString() === input2.getAttribute("value") || value2 == null && !input2.getAttribute("value");
            input2.classList.toggle("ql-active", isActive);
            input2.setAttribute("aria-pressed", isActive.toString());
          } else {
            const isActive = formats[format] != null;
            input2.classList.toggle("ql-active", isActive);
            input2.setAttribute("aria-pressed", isActive.toString());
          }
        });
      }
    }
    Toolbar.DEFAULTS = {};
    function addButton(container, format, value2) {
      const input2 = document.createElement("button");
      input2.setAttribute("type", "button");
      input2.classList.add(`ql-${format}`);
      input2.setAttribute("aria-pressed", "false");
      if (value2 != null) {
        input2.value = value2;
        input2.setAttribute("aria-label", `${format}: ${value2}`);
      } else {
        input2.setAttribute("aria-label", format);
      }
      container.appendChild(input2);
    }
    function addControls(container, groups) {
      if (!Array.isArray(groups[0])) {
        groups = [groups];
      }
      groups.forEach((controls) => {
        const group = document.createElement("span");
        group.classList.add("ql-formats");
        controls.forEach((control) => {
          if (typeof control === "string") {
            addButton(group, control);
          } else {
            const format = Object.keys(control)[0];
            const value2 = control[format];
            if (Array.isArray(value2)) {
              addSelect(group, format, value2);
            } else {
              addButton(group, format, value2);
            }
          }
        });
        container.appendChild(group);
      });
    }
    function addSelect(container, format, values) {
      const input2 = document.createElement("select");
      input2.classList.add(`ql-${format}`);
      values.forEach((value2) => {
        const option2 = document.createElement("option");
        if (value2 !== false) {
          option2.setAttribute("value", String(value2));
        } else {
          option2.setAttribute("selected", "selected");
        }
        input2.appendChild(option2);
      });
      container.appendChild(input2);
    }
    Toolbar.DEFAULTS = {
      container: null,
      handlers: {
        clean() {
          const range = this.quill.getSelection();
          if (range == null) return;
          if (range.length === 0) {
            const formats = this.quill.getFormat();
            Object.keys(formats).forEach((name2) => {
              if (this.quill.scroll.query(name2, Scope.INLINE) != null) {
                this.quill.format(name2, false, Quill.sources.USER);
              }
            });
          } else {
            this.quill.removeFormat(range.index, range.length, Quill.sources.USER);
          }
        },
        direction(value2) {
          const {
            align
          } = this.quill.getFormat();
          if (value2 === "rtl" && align == null) {
            this.quill.format("align", "right", Quill.sources.USER);
          } else if (!value2 && align === "right") {
            this.quill.format("align", false, Quill.sources.USER);
          }
          this.quill.format("direction", value2, Quill.sources.USER);
        },
        indent(value2) {
          const range = this.quill.getSelection();
          const formats = this.quill.getFormat(range);
          const indent = parseInt(formats.indent || 0, 10);
          if (value2 === "+1" || value2 === "-1") {
            let modifier = value2 === "+1" ? 1 : -1;
            if (formats.direction === "rtl") modifier *= -1;
            this.quill.format("indent", indent + modifier, Quill.sources.USER);
          }
        },
        link(value2) {
          if (value2 === true) {
            value2 = prompt("Enter link URL:");
          }
          this.quill.format("link", value2, Quill.sources.USER);
        },
        list(value2) {
          const range = this.quill.getSelection();
          const formats = this.quill.getFormat(range);
          if (value2 === "check") {
            if (formats.list === "checked" || formats.list === "unchecked") {
              this.quill.format("list", false, Quill.sources.USER);
            } else {
              this.quill.format("list", "unchecked", Quill.sources.USER);
            }
          } else {
            this.quill.format("list", value2, Quill.sources.USER);
          }
        }
      }
    };
    const alignLeftIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="3" x2="15" y1="9" y2="9"/><line class="ql-stroke" x1="3" x2="13" y1="14" y2="14"/><line class="ql-stroke" x1="3" x2="9" y1="4" y2="4"/></svg>';
    const alignCenterIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="15" x2="3" y1="9" y2="9"/><line class="ql-stroke" x1="14" x2="4" y1="14" y2="14"/><line class="ql-stroke" x1="12" x2="6" y1="4" y2="4"/></svg>';
    const alignRightIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="15" x2="3" y1="9" y2="9"/><line class="ql-stroke" x1="15" x2="5" y1="14" y2="14"/><line class="ql-stroke" x1="15" x2="9" y1="4" y2="4"/></svg>';
    const alignJustifyIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="15" x2="3" y1="9" y2="9"/><line class="ql-stroke" x1="15" x2="3" y1="14" y2="14"/><line class="ql-stroke" x1="15" x2="3" y1="4" y2="4"/></svg>';
    const backgroundIcon = '<svg viewbox="0 0 18 18"><g class="ql-fill ql-color-label"><polygon points="6 6.868 6 6 5 6 5 7 5.942 7 6 6.868"/><rect height="1" width="1" x="4" y="4"/><polygon points="6.817 5 6 5 6 6 6.38 6 6.817 5"/><rect height="1" width="1" x="2" y="6"/><rect height="1" width="1" x="3" y="5"/><rect height="1" width="1" x="4" y="7"/><polygon points="4 11.439 4 11 3 11 3 12 3.755 12 4 11.439"/><rect height="1" width="1" x="2" y="12"/><rect height="1" width="1" x="2" y="9"/><rect height="1" width="1" x="2" y="15"/><polygon points="4.63 10 4 10 4 11 4.192 11 4.63 10"/><rect height="1" width="1" x="3" y="8"/><path d="M10.832,4.2L11,4.582V4H10.708A1.948,1.948,0,0,1,10.832,4.2Z"/><path d="M7,4.582L7.168,4.2A1.929,1.929,0,0,1,7.292,4H7V4.582Z"/><path d="M8,13H7.683l-0.351.8a1.933,1.933,0,0,1-.124.2H8V13Z"/><rect height="1" width="1" x="12" y="2"/><rect height="1" width="1" x="11" y="3"/><path d="M9,3H8V3.282A1.985,1.985,0,0,1,9,3Z"/><rect height="1" width="1" x="2" y="3"/><rect height="1" width="1" x="6" y="2"/><rect height="1" width="1" x="3" y="2"/><rect height="1" width="1" x="5" y="3"/><rect height="1" width="1" x="9" y="2"/><rect height="1" width="1" x="15" y="14"/><polygon points="13.447 10.174 13.469 10.225 13.472 10.232 13.808 11 14 11 14 10 13.37 10 13.447 10.174"/><rect height="1" width="1" x="13" y="7"/><rect height="1" width="1" x="15" y="5"/><rect height="1" width="1" x="14" y="6"/><rect height="1" width="1" x="15" y="8"/><rect height="1" width="1" x="14" y="9"/><path d="M3.775,14H3v1H4V14.314A1.97,1.97,0,0,1,3.775,14Z"/><rect height="1" width="1" x="14" y="3"/><polygon points="12 6.868 12 6 11.62 6 12 6.868"/><rect height="1" width="1" x="15" y="2"/><rect height="1" width="1" x="12" y="5"/><rect height="1" width="1" x="13" y="4"/><polygon points="12.933 9 13 9 13 8 12.495 8 12.933 9"/><rect height="1" width="1" x="9" y="14"/><rect height="1" width="1" x="8" y="15"/><path d="M6,14.926V15H7V14.316A1.993,1.993,0,0,1,6,14.926Z"/><rect height="1" width="1" x="5" y="15"/><path d="M10.668,13.8L10.317,13H10v1h0.792A1.947,1.947,0,0,1,10.668,13.8Z"/><rect height="1" width="1" x="11" y="15"/><path d="M14.332,12.2a1.99,1.99,0,0,1,.166.8H15V12H14.245Z"/><rect height="1" width="1" x="14" y="15"/><rect height="1" width="1" x="15" y="11"/></g><polyline class="ql-stroke" points="5.5 13 9 5 12.5 13"/><line class="ql-stroke" x1="11.63" x2="6.38" y1="11" y2="11"/></svg>';
    const blockquoteIcon = '<svg viewbox="0 0 18 18"><rect class="ql-fill ql-stroke" height="3" width="3" x="4" y="5"/><rect class="ql-fill ql-stroke" height="3" width="3" x="11" y="5"/><path class="ql-even ql-fill ql-stroke" d="M7,8c0,4.031-3,5-3,5"/><path class="ql-even ql-fill ql-stroke" d="M14,8c0,4.031-3,5-3,5"/></svg>';
    const boldIcon = '<svg viewbox="0 0 18 18"><path class="ql-stroke" d="M5,4H9.5A2.5,2.5,0,0,1,12,6.5v0A2.5,2.5,0,0,1,9.5,9H5A0,0,0,0,1,5,9V4A0,0,0,0,1,5,4Z"/><path class="ql-stroke" d="M5,9h5.5A2.5,2.5,0,0,1,13,11.5v0A2.5,2.5,0,0,1,10.5,14H5a0,0,0,0,1,0,0V9A0,0,0,0,1,5,9Z"/></svg>';
    const cleanIcon = '<svg class="" viewbox="0 0 18 18"><line class="ql-stroke" x1="5" x2="13" y1="3" y2="3"/><line class="ql-stroke" x1="6" x2="9.35" y1="12" y2="3"/><line class="ql-stroke" x1="11" x2="15" y1="11" y2="15"/><line class="ql-stroke" x1="15" x2="11" y1="11" y2="15"/><rect class="ql-fill" height="1" rx="0.5" ry="0.5" width="7" x="2" y="14"/></svg>';
    const codeIcon = '<svg viewbox="0 0 18 18"><polyline class="ql-even ql-stroke" points="5 7 3 9 5 11"/><polyline class="ql-even ql-stroke" points="13 7 15 9 13 11"/><line class="ql-stroke" x1="10" x2="8" y1="5" y2="13"/></svg>';
    const colorIcon = '<svg viewbox="0 0 18 18"><line class="ql-color-label ql-stroke ql-transparent" x1="3" x2="15" y1="15" y2="15"/><polyline class="ql-stroke" points="5.5 11 9 3 12.5 11"/><line class="ql-stroke" x1="11.63" x2="6.38" y1="9" y2="9"/></svg>';
    const directionLeftToRightIcon = '<svg viewbox="0 0 18 18"><polygon class="ql-stroke ql-fill" points="3 11 5 9 3 7 3 11"/><line class="ql-stroke ql-fill" x1="15" x2="11" y1="4" y2="4"/><path class="ql-fill" d="M11,3a3,3,0,0,0,0,6h1V3H11Z"/><rect class="ql-fill" height="11" width="1" x="11" y="4"/><rect class="ql-fill" height="11" width="1" x="13" y="4"/></svg>';
    const directionRightToLeftIcon = '<svg viewbox="0 0 18 18"><polygon class="ql-stroke ql-fill" points="15 12 13 10 15 8 15 12"/><line class="ql-stroke ql-fill" x1="9" x2="5" y1="4" y2="4"/><path class="ql-fill" d="M5,3A3,3,0,0,0,5,9H6V3H5Z"/><rect class="ql-fill" height="11" width="1" x="5" y="4"/><rect class="ql-fill" height="11" width="1" x="7" y="4"/></svg>';
    const formulaIcon = '<svg viewbox="0 0 18 18"><path class="ql-fill" d="M11.759,2.482a2.561,2.561,0,0,0-3.53.607A7.656,7.656,0,0,0,6.8,6.2C6.109,9.188,5.275,14.677,4.15,14.927a1.545,1.545,0,0,0-1.3-.933A0.922,0.922,0,0,0,2,15.036S1.954,16,4.119,16s3.091-2.691,3.7-5.553c0.177-.826.36-1.726,0.554-2.6L8.775,6.2c0.381-1.421.807-2.521,1.306-2.676a1.014,1.014,0,0,0,1.02.56A0.966,0.966,0,0,0,11.759,2.482Z"/><rect class="ql-fill" height="1.6" rx="0.8" ry="0.8" width="5" x="5.15" y="6.2"/><path class="ql-fill" d="M13.663,12.027a1.662,1.662,0,0,1,.266-0.276q0.193,0.069.456,0.138a2.1,2.1,0,0,0,.535.069,1.075,1.075,0,0,0,.767-0.3,1.044,1.044,0,0,0,.314-0.8,0.84,0.84,0,0,0-.238-0.619,0.8,0.8,0,0,0-.594-0.239,1.154,1.154,0,0,0-.781.3,4.607,4.607,0,0,0-.781,1q-0.091.15-.218,0.346l-0.246.38c-0.068-.288-0.137-0.582-0.212-0.885-0.459-1.847-2.494-.984-2.941-0.8-0.482.2-.353,0.647-0.094,0.529a0.869,0.869,0,0,1,1.281.585c0.217,0.751.377,1.436,0.527,2.038a5.688,5.688,0,0,1-.362.467,2.69,2.69,0,0,1-.264.271q-0.221-.08-0.471-0.147a2.029,2.029,0,0,0-.522-0.066,1.079,1.079,0,0,0-.768.3A1.058,1.058,0,0,0,9,15.131a0.82,0.82,0,0,0,.832.852,1.134,1.134,0,0,0,.787-0.3,5.11,5.11,0,0,0,.776-0.993q0.141-.219.215-0.34c0.046-.076.122-0.194,0.223-0.346a2.786,2.786,0,0,0,.918,1.726,2.582,2.582,0,0,0,2.376-.185c0.317-.181.212-0.565,0-0.494A0.807,0.807,0,0,1,14.176,15a5.159,5.159,0,0,1-.913-2.446l0,0Q13.487,12.24,13.663,12.027Z"/></svg>';
    const headerIcon = '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Zm6.06787,9.209H14.98975V7.59863a.54085.54085,0,0,0-.605-.60547h-.62744a1.01119,1.01119,0,0,0-.748.29688L11.645,8.56641a.5435.5435,0,0,0-.022.8584l.28613.30762a.53861.53861,0,0,0,.84717.0332l.09912-.08789a1.2137,1.2137,0,0,0,.2417-.35254h.02246s-.01123.30859-.01123.60547V13.209H12.041a.54085.54085,0,0,0-.605.60547v.43945a.54085.54085,0,0,0,.605.60547h4.02686a.54085.54085,0,0,0,.605-.60547v-.43945A.54085.54085,0,0,0,16.06787,13.209Z"/></svg>';
    const header2Icon = '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M16.73975,13.81445v.43945a.54085.54085,0,0,1-.605.60547H11.855a.58392.58392,0,0,1-.64893-.60547V14.0127c0-2.90527,3.39941-3.42187,3.39941-4.55469a.77675.77675,0,0,0-.84717-.78125,1.17684,1.17684,0,0,0-.83594.38477c-.2749.26367-.561.374-.85791.13184l-.4292-.34082c-.30811-.24219-.38525-.51758-.1543-.81445a2.97155,2.97155,0,0,1,2.45361-1.17676,2.45393,2.45393,0,0,1,2.68408,2.40918c0,2.45312-3.1792,2.92676-3.27832,3.93848h2.79443A.54085.54085,0,0,1,16.73975,13.81445ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z"/></svg>';
    const header3Icon = '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M16.65186,12.30664a2.6742,2.6742,0,0,1-2.915,2.68457,3.96592,3.96592,0,0,1-2.25537-.6709.56007.56007,0,0,1-.13232-.83594L11.64648,13c.209-.34082.48389-.36328.82471-.1543a2.32654,2.32654,0,0,0,1.12256.33008c.71484,0,1.12207-.35156,1.12207-.78125,0-.61523-.61621-.86816-1.46338-.86816H13.2085a.65159.65159,0,0,1-.68213-.41895l-.05518-.10937a.67114.67114,0,0,1,.14307-.78125l.71533-.86914a8.55289,8.55289,0,0,1,.68213-.7373V8.58887a3.93913,3.93913,0,0,1-.748.05469H11.9873a.54085.54085,0,0,1-.605-.60547V7.59863a.54085.54085,0,0,1,.605-.60547h3.75146a.53773.53773,0,0,1,.60547.59375v.17676a1.03723,1.03723,0,0,1-.27539.748L14.74854,10.0293A2.31132,2.31132,0,0,1,16.65186,12.30664ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z"/></svg>';
    const header4Icon = '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Zm7.05371,7.96582v.38477c0,.39648-.165.60547-.46191.60547h-.47314v1.29785a.54085.54085,0,0,1-.605.60547h-.69336a.54085.54085,0,0,1-.605-.60547V12.95605H11.333a.5412.5412,0,0,1-.60547-.60547v-.15332a1.199,1.199,0,0,1,.22021-.748l2.56348-4.05957a.7819.7819,0,0,1,.72607-.39648h1.27637a.54085.54085,0,0,1,.605.60547v3.7627h.33008A.54055.54055,0,0,1,17.05371,11.96582ZM14.28125,8.7207h-.022a4.18969,4.18969,0,0,1-.38525.81348l-1.188,1.80469v.02246h1.5293V9.60059A7.04058,7.04058,0,0,1,14.28125,8.7207Z"/></svg>';
    const header5Icon = '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M16.74023,12.18555a2.75131,2.75131,0,0,1-2.91553,2.80566,3.908,3.908,0,0,1-2.25537-.68164.54809.54809,0,0,1-.13184-.8252L11.73438,13c.209-.34082.48389-.36328.8252-.1543a2.23757,2.23757,0,0,0,1.1001.33008,1.01827,1.01827,0,0,0,1.1001-.96777c0-.61621-.53906-.97949-1.25439-.97949a2.15554,2.15554,0,0,0-.64893.09961,1.15209,1.15209,0,0,1-.814.01074l-.12109-.04395a.64116.64116,0,0,1-.45117-.71484l.231-3.00391a.56666.56666,0,0,1,.62744-.583H15.541a.54085.54085,0,0,1,.605.60547v.43945a.54085.54085,0,0,1-.605.60547H13.41748l-.04395.72559a1.29306,1.29306,0,0,1-.04395.30859h.022a2.39776,2.39776,0,0,1,.57227-.07715A2.53266,2.53266,0,0,1,16.74023,12.18555ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z"/></svg>';
    const header6Icon = '<svg viewBox="0 0 18 18"><path class="ql-fill" d="M14.51758,9.64453a1.85627,1.85627,0,0,0-1.24316.38477H13.252a1.73532,1.73532,0,0,1,1.72754-1.4082,2.66491,2.66491,0,0,1,.5498.06641c.35254.05469.57227.01074.70508-.40723l.16406-.5166a.53393.53393,0,0,0-.373-.75977,4.83723,4.83723,0,0,0-1.17773-.14258c-2.43164,0-3.7627,2.17773-3.7627,4.43359,0,2.47559,1.60645,3.69629,3.19043,3.69629A2.70585,2.70585,0,0,0,16.96,12.19727,2.43861,2.43861,0,0,0,14.51758,9.64453Zm-.23047,3.58691c-.67187,0-1.22168-.81445-1.22168-1.45215,0-.47363.30762-.583.72559-.583.96875,0,1.27734.59375,1.27734,1.12207A.82182.82182,0,0,1,14.28711,13.23145ZM10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Z"/></svg>';
    const italicIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="7" x2="13" y1="4" y2="4"/><line class="ql-stroke" x1="5" x2="11" y1="14" y2="14"/><line class="ql-stroke" x1="8" x2="10" y1="14" y2="4"/></svg>';
    const imageIcon = '<svg viewbox="0 0 18 18"><rect class="ql-stroke" height="10" width="12" x="3" y="4"/><circle class="ql-fill" cx="6" cy="7" r="1"/><polyline class="ql-even ql-fill" points="5 12 5 11 7 9 8 10 11 7 13 9 13 12 5 12"/></svg>';
    const indentIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="3" x2="15" y1="14" y2="14"/><line class="ql-stroke" x1="3" x2="15" y1="4" y2="4"/><line class="ql-stroke" x1="9" x2="15" y1="9" y2="9"/><polyline class="ql-fill ql-stroke" points="3 7 3 11 5 9 3 7"/></svg>';
    const outdentIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="3" x2="15" y1="14" y2="14"/><line class="ql-stroke" x1="3" x2="15" y1="4" y2="4"/><line class="ql-stroke" x1="9" x2="15" y1="9" y2="9"/><polyline class="ql-stroke" points="5 7 5 11 3 9 5 7"/></svg>';
    const linkIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="7" x2="11" y1="7" y2="11"/><path class="ql-even ql-stroke" d="M8.9,4.577a3.476,3.476,0,0,1,.36,4.679A3.476,3.476,0,0,1,4.577,8.9C3.185,7.5,2.035,6.4,4.217,4.217S7.5,3.185,8.9,4.577Z"/><path class="ql-even ql-stroke" d="M13.423,9.1a3.476,3.476,0,0,0-4.679-.36,3.476,3.476,0,0,0,.36,4.679c1.392,1.392,2.5,2.542,4.679.36S14.815,10.5,13.423,9.1Z"/></svg>';
    const listBulletIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="6" x2="15" y1="4" y2="4"/><line class="ql-stroke" x1="6" x2="15" y1="9" y2="9"/><line class="ql-stroke" x1="6" x2="15" y1="14" y2="14"/><line class="ql-stroke" x1="3" x2="3" y1="4" y2="4"/><line class="ql-stroke" x1="3" x2="3" y1="9" y2="9"/><line class="ql-stroke" x1="3" x2="3" y1="14" y2="14"/></svg>';
    const listCheckIcon = '<svg class="" viewbox="0 0 18 18"><line class="ql-stroke" x1="9" x2="15" y1="4" y2="4"/><polyline class="ql-stroke" points="3 4 4 5 6 3"/><line class="ql-stroke" x1="9" x2="15" y1="14" y2="14"/><polyline class="ql-stroke" points="3 14 4 15 6 13"/><line class="ql-stroke" x1="9" x2="15" y1="9" y2="9"/><polyline class="ql-stroke" points="3 9 4 10 6 8"/></svg>';
    const listOrderedIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke" x1="7" x2="15" y1="4" y2="4"/><line class="ql-stroke" x1="7" x2="15" y1="9" y2="9"/><line class="ql-stroke" x1="7" x2="15" y1="14" y2="14"/><line class="ql-stroke ql-thin" x1="2.5" x2="4.5" y1="5.5" y2="5.5"/><path class="ql-fill" d="M3.5,6A0.5,0.5,0,0,1,3,5.5V3.085l-0.276.138A0.5,0.5,0,0,1,2.053,3c-0.124-.247-0.023-0.324.224-0.447l1-.5A0.5,0.5,0,0,1,4,2.5v3A0.5,0.5,0,0,1,3.5,6Z"/><path class="ql-stroke ql-thin" d="M4.5,10.5h-2c0-.234,1.85-1.076,1.85-2.234A0.959,0.959,0,0,0,2.5,8.156"/><path class="ql-stroke ql-thin" d="M2.5,14.846a0.959,0.959,0,0,0,1.85-.109A0.7,0.7,0,0,0,3.75,14a0.688,0.688,0,0,0,.6-0.736,0.959,0.959,0,0,0-1.85-.109"/></svg>';
    const subscriptIcon = '<svg viewbox="0 0 18 18"><path class="ql-fill" d="M15.5,15H13.861a3.858,3.858,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.921,1.921,0,0,0,12.021,11.7a0.50013,0.50013,0,1,0,.957.291h0a0.914,0.914,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.076-1.16971,1.86982-1.93971,2.43082A1.45639,1.45639,0,0,0,12,15.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,15Z"/><path class="ql-fill" d="M9.65,5.241a1,1,0,0,0-1.409.108L6,7.964,3.759,5.349A1,1,0,0,0,2.192,6.59178Q2.21541,6.6213,2.241,6.649L4.684,9.5,2.241,12.35A1,1,0,0,0,3.71,13.70722q0.02557-.02768.049-0.05722L6,11.036,8.241,13.65a1,1,0,1,0,1.567-1.24277Q9.78459,12.3777,9.759,12.35L7.316,9.5,9.759,6.651A1,1,0,0,0,9.65,5.241Z"/></svg>';
    const superscriptIcon = '<svg viewbox="0 0 18 18"><path class="ql-fill" d="M15.5,7H13.861a4.015,4.015,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.922,1.922,0,0,0,12.021,3.7a0.5,0.5,0,1,0,.957.291,0.917,0.917,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.077-1.164,1.925-1.934,2.486A1.423,1.423,0,0,0,12,7.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,7Z"/><path class="ql-fill" d="M9.651,5.241a1,1,0,0,0-1.41.108L6,7.964,3.759,5.349a1,1,0,1,0-1.519,1.3L4.683,9.5,2.241,12.35a1,1,0,1,0,1.519,1.3L6,11.036,8.241,13.65a1,1,0,0,0,1.519-1.3L7.317,9.5,9.759,6.651A1,1,0,0,0,9.651,5.241Z"/></svg>';
    const strikeIcon = '<svg viewbox="0 0 18 18"><line class="ql-stroke ql-thin" x1="15.5" x2="2.5" y1="8.5" y2="9.5"/><path class="ql-fill" d="M9.007,8C6.542,7.791,6,7.519,6,6.5,6,5.792,7.283,5,9,5c1.571,0,2.765.679,2.969,1.309a1,1,0,0,0,1.9-.617C13.356,4.106,11.354,3,9,3,6.2,3,4,4.538,4,6.5a3.2,3.2,0,0,0,.5,1.843Z"/><path class="ql-fill" d="M8.984,10C11.457,10.208,12,10.479,12,11.5c0,0.708-1.283,1.5-3,1.5-1.571,0-2.765-.679-2.969-1.309a1,1,0,1,0-1.9.617C4.644,13.894,6.646,15,9,15c2.8,0,5-1.538,5-3.5a3.2,3.2,0,0,0-.5-1.843Z"/></svg>';
    const tableIcon = '<svg viewbox="0 0 18 18"><rect class="ql-stroke" height="12" width="12" x="3" y="3"/><rect class="ql-fill" height="2" width="3" x="5" y="5"/><rect class="ql-fill" height="2" width="4" x="9" y="5"/><g class="ql-fill ql-transparent"><rect height="2" width="3" x="5" y="8"/><rect height="2" width="4" x="9" y="8"/><rect height="2" width="3" x="5" y="11"/><rect height="2" width="4" x="9" y="11"/></g></svg>';
    const underlineIcon = '<svg viewbox="0 0 18 18"><path class="ql-stroke" d="M5,3V9a4.012,4.012,0,0,0,4,4H9a4.012,4.012,0,0,0,4-4V3"/><rect class="ql-fill" height="1" rx="0.5" ry="0.5" width="12" x="3" y="15"/></svg>';
    const videoIcon = '<svg viewbox="0 0 18 18"><rect class="ql-stroke" height="12" width="12" x="3" y="3"/><rect class="ql-fill" height="12" width="1" x="5" y="3"/><rect class="ql-fill" height="12" width="1" x="12" y="3"/><rect class="ql-fill" height="2" width="8" x="5" y="8"/><rect class="ql-fill" height="1" width="3" x="3" y="5"/><rect class="ql-fill" height="1" width="3" x="3" y="7"/><rect class="ql-fill" height="1" width="3" x="3" y="10"/><rect class="ql-fill" height="1" width="3" x="3" y="12"/><rect class="ql-fill" height="1" width="3" x="12" y="5"/><rect class="ql-fill" height="1" width="3" x="12" y="7"/><rect class="ql-fill" height="1" width="3" x="12" y="10"/><rect class="ql-fill" height="1" width="3" x="12" y="12"/></svg>';
    const Icons = {
      align: {
        "": alignLeftIcon,
        center: alignCenterIcon,
        right: alignRightIcon,
        justify: alignJustifyIcon
      },
      background: backgroundIcon,
      blockquote: blockquoteIcon,
      bold: boldIcon,
      clean: cleanIcon,
      code: codeIcon,
      "code-block": codeIcon,
      color: colorIcon,
      direction: {
        "": directionLeftToRightIcon,
        rtl: directionRightToLeftIcon
      },
      formula: formulaIcon,
      header: {
        "1": headerIcon,
        "2": header2Icon,
        "3": header3Icon,
        "4": header4Icon,
        "5": header5Icon,
        "6": header6Icon
      },
      italic: italicIcon,
      image: imageIcon,
      indent: {
        "+1": indentIcon,
        "-1": outdentIcon
      },
      link: linkIcon,
      list: {
        bullet: listBulletIcon,
        check: listCheckIcon,
        ordered: listOrderedIcon
      },
      script: {
        sub: subscriptIcon,
        super: superscriptIcon
      },
      strike: strikeIcon,
      table: tableIcon,
      underline: underlineIcon,
      video: videoIcon
    };
    const DropdownIcon = '<svg viewbox="0 0 18 18"><polygon class="ql-stroke" points="7 11 9 13 11 11 7 11"/><polygon class="ql-stroke" points="7 7 9 5 11 7 7 7"/></svg>';
    let optionsCounter = 0;
    function toggleAriaAttribute(element, attribute) {
      element.setAttribute(attribute, `${!(element.getAttribute(attribute) === "true")}`);
    }
    class Picker {
      constructor(select2) {
        this.select = select2;
        this.container = document.createElement("span");
        this.buildPicker();
        this.select.style.display = "none";
        this.select.parentNode.insertBefore(this.container, this.select);
        this.label.addEventListener("mousedown", () => {
          this.togglePicker();
        });
        this.label.addEventListener("keydown", (event) => {
          switch (event.key) {
            case "Enter":
              this.togglePicker();
              break;
            case "Escape":
              this.escape();
              event.preventDefault();
              break;
          }
        });
        this.select.addEventListener("change", this.update.bind(this));
      }
      togglePicker() {
        this.container.classList.toggle("ql-expanded");
        toggleAriaAttribute(this.label, "aria-expanded");
        toggleAriaAttribute(this.options, "aria-hidden");
      }
      buildItem(option2) {
        const item = document.createElement("span");
        item.tabIndex = "0";
        item.setAttribute("role", "button");
        item.classList.add("ql-picker-item");
        const value2 = option2.getAttribute("value");
        if (value2) {
          item.setAttribute("data-value", value2);
        }
        if (option2.textContent) {
          item.setAttribute("data-label", option2.textContent);
        }
        item.addEventListener("click", () => {
          this.selectItem(item, true);
        });
        item.addEventListener("keydown", (event) => {
          switch (event.key) {
            case "Enter":
              this.selectItem(item, true);
              event.preventDefault();
              break;
            case "Escape":
              this.escape();
              event.preventDefault();
              break;
          }
        });
        return item;
      }
      buildLabel() {
        const label = document.createElement("span");
        label.classList.add("ql-picker-label");
        label.innerHTML = DropdownIcon;
        label.tabIndex = "0";
        label.setAttribute("role", "button");
        label.setAttribute("aria-expanded", "false");
        this.container.appendChild(label);
        return label;
      }
      buildOptions() {
        const options = document.createElement("span");
        options.classList.add("ql-picker-options");
        options.setAttribute("aria-hidden", "true");
        options.tabIndex = "-1";
        options.id = `ql-picker-options-${optionsCounter}`;
        optionsCounter += 1;
        this.label.setAttribute("aria-controls", options.id);
        this.options = options;
        Array.from(this.select.options).forEach((option2) => {
          const item = this.buildItem(option2);
          options.appendChild(item);
          if (option2.selected === true) {
            this.selectItem(item);
          }
        });
        this.container.appendChild(options);
      }
      buildPicker() {
        Array.from(this.select.attributes).forEach((item) => {
          this.container.setAttribute(item.name, item.value);
        });
        this.container.classList.add("ql-picker");
        this.label = this.buildLabel();
        this.buildOptions();
      }
      escape() {
        this.close();
        setTimeout(() => this.label.focus(), 1);
      }
      close() {
        this.container.classList.remove("ql-expanded");
        this.label.setAttribute("aria-expanded", "false");
        this.options.setAttribute("aria-hidden", "true");
      }
      selectItem(item) {
        let trigger = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        const selected = this.container.querySelector(".ql-selected");
        if (item === selected) return;
        if (selected != null) {
          selected.classList.remove("ql-selected");
        }
        if (item == null) return;
        item.classList.add("ql-selected");
        this.select.selectedIndex = Array.from(item.parentNode.children).indexOf(item);
        if (item.hasAttribute("data-value")) {
          this.label.setAttribute("data-value", item.getAttribute("data-value"));
        } else {
          this.label.removeAttribute("data-value");
        }
        if (item.hasAttribute("data-label")) {
          this.label.setAttribute("data-label", item.getAttribute("data-label"));
        } else {
          this.label.removeAttribute("data-label");
        }
        if (trigger) {
          this.select.dispatchEvent(new Event("change"));
          this.close();
        }
      }
      update() {
        let option2;
        if (this.select.selectedIndex > -1) {
          const item = (
            // @ts-expect-error Fix me later
            this.container.querySelector(".ql-picker-options").children[this.select.selectedIndex]
          );
          option2 = this.select.options[this.select.selectedIndex];
          this.selectItem(item);
        } else {
          this.selectItem(null);
        }
        const isActive = option2 != null && option2 !== this.select.querySelector("option[selected]");
        this.label.classList.toggle("ql-active", isActive);
      }
    }
    class ColorPicker extends Picker {
      constructor(select2, label) {
        super(select2);
        this.label.innerHTML = label;
        this.container.classList.add("ql-color-picker");
        Array.from(this.container.querySelectorAll(".ql-picker-item")).slice(0, 7).forEach((item) => {
          item.classList.add("ql-primary");
        });
      }
      buildItem(option2) {
        const item = super.buildItem(option2);
        item.style.backgroundColor = option2.getAttribute("value") || "";
        return item;
      }
      selectItem(item, trigger) {
        super.selectItem(item, trigger);
        const colorLabel = this.label.querySelector(".ql-color-label");
        const value2 = item ? item.getAttribute("data-value") || "" : "";
        if (colorLabel) {
          if (colorLabel.tagName === "line") {
            colorLabel.style.stroke = value2;
          } else {
            colorLabel.style.fill = value2;
          }
        }
      }
    }
    class IconPicker extends Picker {
      constructor(select2, icons) {
        super(select2);
        this.container.classList.add("ql-icon-picker");
        Array.from(this.container.querySelectorAll(".ql-picker-item")).forEach((item) => {
          item.innerHTML = icons[item.getAttribute("data-value") || ""];
        });
        this.defaultItem = this.container.querySelector(".ql-selected");
        this.selectItem(this.defaultItem);
      }
      selectItem(target, trigger) {
        super.selectItem(target, trigger);
        const item = target || this.defaultItem;
        if (item != null) {
          if (this.label.innerHTML === item.innerHTML) return;
          this.label.innerHTML = item.innerHTML;
        }
      }
    }
    const isScrollable = (el) => {
      const {
        overflowY
      } = getComputedStyle(el, null);
      return overflowY !== "visible" && overflowY !== "clip";
    };
    class Tooltip {
      constructor(quill, boundsContainer) {
        this.quill = quill;
        this.boundsContainer = boundsContainer || document.body;
        this.root = quill.addContainer("ql-tooltip");
        this.root.innerHTML = this.constructor.TEMPLATE;
        if (isScrollable(this.quill.root)) {
          this.quill.root.addEventListener("scroll", () => {
            this.root.style.marginTop = `${-1 * this.quill.root.scrollTop}px`;
          });
        }
        this.hide();
      }
      hide() {
        this.root.classList.add("ql-hidden");
      }
      position(reference) {
        const left2 = reference.left + reference.width / 2 - this.root.offsetWidth / 2;
        const top2 = reference.bottom + this.quill.root.scrollTop;
        this.root.style.left = `${left2}px`;
        this.root.style.top = `${top2}px`;
        this.root.classList.remove("ql-flip");
        const containerBounds = this.boundsContainer.getBoundingClientRect();
        const rootBounds = this.root.getBoundingClientRect();
        let shift = 0;
        if (rootBounds.right > containerBounds.right) {
          shift = containerBounds.right - rootBounds.right;
          this.root.style.left = `${left2 + shift}px`;
        }
        if (rootBounds.left < containerBounds.left) {
          shift = containerBounds.left - rootBounds.left;
          this.root.style.left = `${left2 + shift}px`;
        }
        if (rootBounds.bottom > containerBounds.bottom) {
          const height = rootBounds.bottom - rootBounds.top;
          const verticalShift = reference.bottom - reference.top + height;
          this.root.style.top = `${top2 - verticalShift}px`;
          this.root.classList.add("ql-flip");
        }
        return shift;
      }
      show() {
        this.root.classList.remove("ql-editing");
        this.root.classList.remove("ql-hidden");
      }
    }
    const ALIGNS = [false, "center", "right", "justify"];
    const COLORS = ["#000000", "#e60000", "#ff9900", "#ffff00", "#008a00", "#0066cc", "#9933ff", "#ffffff", "#facccc", "#ffebcc", "#ffffcc", "#cce8cc", "#cce0f5", "#ebd6ff", "#bbbbbb", "#f06666", "#ffc266", "#ffff66", "#66b966", "#66a3e0", "#c285ff", "#888888", "#a10000", "#b26b00", "#b2b200", "#006100", "#0047b2", "#6b24b2", "#444444", "#5c0000", "#663d00", "#666600", "#003700", "#002966", "#3d1466"];
    const FONTS = [false, "serif", "monospace"];
    const HEADERS = ["1", "2", "3", false];
    const SIZES = ["small", false, "large", "huge"];
    class BaseTheme extends Theme {
      constructor(quill, options) {
        super(quill, options);
        const listener = (e) => {
          if (!document.body.contains(quill.root)) {
            document.body.removeEventListener("click", listener);
            return;
          }
          if (this.tooltip != null && // @ts-expect-error
          !this.tooltip.root.contains(e.target) && // @ts-expect-error
          document.activeElement !== this.tooltip.textbox && !this.quill.hasFocus()) {
            this.tooltip.hide();
          }
          if (this.pickers != null) {
            this.pickers.forEach((picker) => {
              if (!picker.container.contains(e.target)) {
                picker.close();
              }
            });
          }
        };
        quill.emitter.listenDOM("click", document.body, listener);
      }
      addModule(name2) {
        const module2 = super.addModule(name2);
        if (name2 === "toolbar") {
          this.extendToolbar(module2);
        }
        return module2;
      }
      buildButtons(buttons, icons) {
        Array.from(buttons).forEach((button2) => {
          const className = button2.getAttribute("class") || "";
          className.split(/\s+/).forEach((name2) => {
            if (!name2.startsWith("ql-")) return;
            name2 = name2.slice("ql-".length);
            if (icons[name2] == null) return;
            if (name2 === "direction") {
              button2.innerHTML = icons[name2][""] + icons[name2].rtl;
            } else if (typeof icons[name2] === "string") {
              button2.innerHTML = icons[name2];
            } else {
              const value2 = button2.value || "";
              if (value2 != null && icons[name2][value2]) {
                button2.innerHTML = icons[name2][value2];
              }
            }
          });
        });
      }
      buildPickers(selects, icons) {
        this.pickers = Array.from(selects).map((select2) => {
          if (select2.classList.contains("ql-align")) {
            if (select2.querySelector("option") == null) {
              fillSelect(select2, ALIGNS);
            }
            if (typeof icons.align === "object") {
              return new IconPicker(select2, icons.align);
            }
          }
          if (select2.classList.contains("ql-background") || select2.classList.contains("ql-color")) {
            const format = select2.classList.contains("ql-background") ? "background" : "color";
            if (select2.querySelector("option") == null) {
              fillSelect(select2, COLORS, format === "background" ? "#ffffff" : "#000000");
            }
            return new ColorPicker(select2, icons[format]);
          }
          if (select2.querySelector("option") == null) {
            if (select2.classList.contains("ql-font")) {
              fillSelect(select2, FONTS);
            } else if (select2.classList.contains("ql-header")) {
              fillSelect(select2, HEADERS);
            } else if (select2.classList.contains("ql-size")) {
              fillSelect(select2, SIZES);
            }
          }
          return new Picker(select2);
        });
        const update = () => {
          this.pickers.forEach((picker) => {
            picker.update();
          });
        };
        this.quill.on(Emitter.events.EDITOR_CHANGE, update);
      }
    }
    BaseTheme.DEFAULTS = merge({}, Theme.DEFAULTS, {
      modules: {
        toolbar: {
          handlers: {
            formula() {
              this.quill.theme.tooltip.edit("formula");
            },
            image() {
              let fileInput = this.container.querySelector("input.ql-image[type=file]");
              if (fileInput == null) {
                fileInput = document.createElement("input");
                fileInput.setAttribute("type", "file");
                fileInput.setAttribute("accept", this.quill.uploader.options.mimetypes.join(", "));
                fileInput.classList.add("ql-image");
                fileInput.addEventListener("change", () => {
                  const range = this.quill.getSelection(true);
                  this.quill.uploader.upload(range, fileInput.files);
                  fileInput.value = "";
                });
                this.container.appendChild(fileInput);
              }
              fileInput.click();
            },
            video() {
              this.quill.theme.tooltip.edit("video");
            }
          }
        }
      }
    });
    class BaseTooltip extends Tooltip {
      constructor(quill, boundsContainer) {
        super(quill, boundsContainer);
        this.textbox = this.root.querySelector('input[type="text"]');
        this.listen();
      }
      listen() {
        this.textbox.addEventListener("keydown", (event) => {
          if (event.key === "Enter") {
            this.save();
            event.preventDefault();
          } else if (event.key === "Escape") {
            this.cancel();
            event.preventDefault();
          }
        });
      }
      cancel() {
        this.hide();
        this.restoreFocus();
      }
      edit() {
        let mode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "link";
        let preview = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        this.root.classList.remove("ql-hidden");
        this.root.classList.add("ql-editing");
        if (this.textbox == null) return;
        if (preview != null) {
          this.textbox.value = preview;
        } else if (mode !== this.root.getAttribute("data-mode")) {
          this.textbox.value = "";
        }
        const bounds2 = this.quill.getBounds(this.quill.selection.savedRange);
        if (bounds2 != null) {
          this.position(bounds2);
        }
        this.textbox.select();
        this.textbox.setAttribute("placeholder", this.textbox.getAttribute(`data-${mode}`) || "");
        this.root.setAttribute("data-mode", mode);
      }
      restoreFocus() {
        this.quill.focus({
          preventScroll: true
        });
      }
      save() {
        let {
          value: value2
        } = this.textbox;
        switch (this.root.getAttribute("data-mode")) {
          case "link": {
            const {
              scrollTop
            } = this.quill.root;
            if (this.linkRange) {
              this.quill.formatText(this.linkRange, "link", value2, Emitter.sources.USER);
              delete this.linkRange;
            } else {
              this.restoreFocus();
              this.quill.format("link", value2, Emitter.sources.USER);
            }
            this.quill.root.scrollTop = scrollTop;
            break;
          }
          case "video": {
            value2 = extractVideoUrl(value2);
          }
          // eslint-disable-next-line no-fallthrough
          case "formula": {
            if (!value2) break;
            const range = this.quill.getSelection(true);
            if (range != null) {
              const index = range.index + range.length;
              this.quill.insertEmbed(
                index,
                // @ts-expect-error Fix me later
                this.root.getAttribute("data-mode"),
                value2,
                Emitter.sources.USER
              );
              if (this.root.getAttribute("data-mode") === "formula") {
                this.quill.insertText(index + 1, " ", Emitter.sources.USER);
              }
              this.quill.setSelection(index + 2, Emitter.sources.USER);
            }
            break;
          }
        }
        this.textbox.value = "";
        this.hide();
      }
    }
    function extractVideoUrl(url) {
      let match2 = url.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtube\.com\/watch.*v=([a-zA-Z0-9_-]+)/) || url.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtu\.be\/([a-zA-Z0-9_-]+)/);
      if (match2) {
        return `${match2[1] || "https"}://www.youtube.com/embed/${match2[2]}?showinfo=0`;
      }
      if (match2 = url.match(/^(?:(https?):\/\/)?(?:www\.)?vimeo\.com\/(\d+)/)) {
        return `${match2[1] || "https"}://player.vimeo.com/video/${match2[2]}/`;
      }
      return url;
    }
    function fillSelect(select2, values) {
      let defaultValue2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      values.forEach((value2) => {
        const option2 = document.createElement("option");
        if (value2 === defaultValue2) {
          option2.setAttribute("selected", "selected");
        } else {
          option2.setAttribute("value", String(value2));
        }
        select2.appendChild(option2);
      });
    }
    const TOOLBAR_CONFIG$1 = [["bold", "italic", "link"], [{
      header: 1
    }, {
      header: 2
    }, "blockquote"]];
    class BubbleTooltip extends BaseTooltip {
      constructor(quill, bounds2) {
        super(quill, bounds2);
        this.quill.on(Emitter.events.EDITOR_CHANGE, (type, range, oldRange, source) => {
          if (type !== Emitter.events.SELECTION_CHANGE) return;
          if (range != null && range.length > 0 && source === Emitter.sources.USER) {
            this.show();
            this.root.style.left = "0px";
            this.root.style.width = "";
            this.root.style.width = `${this.root.offsetWidth}px`;
            const lines = this.quill.getLines(range.index, range.length);
            if (lines.length === 1) {
              const bounds3 = this.quill.getBounds(range);
              if (bounds3 != null) {
                this.position(bounds3);
              }
            } else {
              const lastLine = lines[lines.length - 1];
              const index = this.quill.getIndex(lastLine);
              const length = Math.min(lastLine.length() - 1, range.index + range.length - index);
              const indexBounds = this.quill.getBounds(new Range(index, length));
              if (indexBounds != null) {
                this.position(indexBounds);
              }
            }
          } else if (document.activeElement !== this.textbox && this.quill.hasFocus()) {
            this.hide();
          }
        });
      }
      listen() {
        super.listen();
        this.root.querySelector(".ql-close").addEventListener("click", () => {
          this.root.classList.remove("ql-editing");
        });
        this.quill.on(Emitter.events.SCROLL_OPTIMIZE, () => {
          setTimeout(() => {
            if (this.root.classList.contains("ql-hidden")) return;
            const range = this.quill.getSelection();
            if (range != null) {
              const bounds2 = this.quill.getBounds(range);
              if (bounds2 != null) {
                this.position(bounds2);
              }
            }
          }, 1);
        });
      }
      cancel() {
        this.show();
      }
      position(reference) {
        const shift = super.position(reference);
        const arrow = this.root.querySelector(".ql-tooltip-arrow");
        arrow.style.marginLeft = "";
        if (shift !== 0) {
          arrow.style.marginLeft = `${-1 * shift - arrow.offsetWidth / 2}px`;
        }
        return shift;
      }
    }
    __publicField(BubbleTooltip, "TEMPLATE", ['<span class="ql-tooltip-arrow"></span>', '<div class="ql-tooltip-editor">', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-close"></a>', "</div>"].join(""));
    class BubbleTheme extends BaseTheme {
      constructor(quill, options) {
        if (options.modules.toolbar != null && options.modules.toolbar.container == null) {
          options.modules.toolbar.container = TOOLBAR_CONFIG$1;
        }
        super(quill, options);
        this.quill.container.classList.add("ql-bubble");
      }
      extendToolbar(toolbar2) {
        this.tooltip = new BubbleTooltip(this.quill, this.options.bounds);
        if (toolbar2.container != null) {
          this.tooltip.root.appendChild(toolbar2.container);
          this.buildButtons(toolbar2.container.querySelectorAll("button"), Icons);
          this.buildPickers(toolbar2.container.querySelectorAll("select"), Icons);
        }
      }
    }
    BubbleTheme.DEFAULTS = merge({}, BaseTheme.DEFAULTS, {
      modules: {
        toolbar: {
          handlers: {
            link(value2) {
              if (!value2) {
                this.quill.format("link", false, Quill.sources.USER);
              } else {
                this.quill.theme.tooltip.edit();
              }
            }
          }
        }
      }
    });
    const TOOLBAR_CONFIG = [[{
      header: ["1", "2", "3", false]
    }], ["bold", "italic", "underline", "link"], [{
      list: "ordered"
    }, {
      list: "bullet"
    }], ["clean"]];
    class SnowTooltip extends BaseTooltip {
      constructor() {
        super(...arguments);
        __publicField(this, "preview", this.root.querySelector("a.ql-preview"));
      }
      listen() {
        super.listen();
        this.root.querySelector("a.ql-action").addEventListener("click", (event) => {
          if (this.root.classList.contains("ql-editing")) {
            this.save();
          } else {
            this.edit("link", this.preview.textContent);
          }
          event.preventDefault();
        });
        this.root.querySelector("a.ql-remove").addEventListener("click", (event) => {
          if (this.linkRange != null) {
            const range = this.linkRange;
            this.restoreFocus();
            this.quill.formatText(range, "link", false, Emitter.sources.USER);
            delete this.linkRange;
          }
          event.preventDefault();
          this.hide();
        });
        this.quill.on(Emitter.events.SELECTION_CHANGE, (range, oldRange, source) => {
          if (range == null) return;
          if (range.length === 0 && source === Emitter.sources.USER) {
            const [link, offset] = this.quill.scroll.descendant(Link, range.index);
            if (link != null) {
              this.linkRange = new Range(range.index - offset, link.length());
              const preview = Link.formats(link.domNode);
              this.preview.textContent = preview;
              this.preview.setAttribute("href", preview);
              this.show();
              const bounds2 = this.quill.getBounds(this.linkRange);
              if (bounds2 != null) {
                this.position(bounds2);
              }
              return;
            }
          } else {
            delete this.linkRange;
          }
          this.hide();
        });
      }
      show() {
        super.show();
        this.root.removeAttribute("data-mode");
      }
    }
    __publicField(SnowTooltip, "TEMPLATE", ['<a class="ql-preview" rel="noopener noreferrer" target="_blank" href="about:blank"></a>', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-action"></a>', '<a class="ql-remove"></a>'].join(""));
    class SnowTheme extends BaseTheme {
      constructor(quill, options) {
        if (options.modules.toolbar != null && options.modules.toolbar.container == null) {
          options.modules.toolbar.container = TOOLBAR_CONFIG;
        }
        super(quill, options);
        this.quill.container.classList.add("ql-snow");
      }
      extendToolbar(toolbar2) {
        if (toolbar2.container != null) {
          toolbar2.container.classList.add("ql-snow");
          this.buildButtons(toolbar2.container.querySelectorAll("button"), Icons);
          this.buildPickers(toolbar2.container.querySelectorAll("select"), Icons);
          this.tooltip = new SnowTooltip(this.quill, this.options.bounds);
          if (toolbar2.container.querySelector(".ql-link")) {
            this.quill.keyboard.addBinding({
              key: "k",
              shortKey: true
            }, (_range, context) => {
              toolbar2.handlers.link.call(toolbar2, !context.format.link);
            });
          }
        }
      }
    }
    SnowTheme.DEFAULTS = merge({}, BaseTheme.DEFAULTS, {
      modules: {
        toolbar: {
          handlers: {
            link(value2) {
              if (value2) {
                const range = this.quill.getSelection();
                if (range == null || range.length === 0) return;
                let preview = this.quill.getText(range);
                if (/^\S+@\S+\.\S+$/.test(preview) && preview.indexOf("mailto:") !== 0) {
                  preview = `mailto:${preview}`;
                }
                const {
                  tooltip
                } = this.quill.theme;
                tooltip.edit("link", preview);
              } else {
                this.quill.format("link", false, Quill.sources.USER);
              }
            }
          }
        }
      }
    });
    Quill.register({
      "attributors/attribute/direction": DirectionAttribute,
      "attributors/class/align": AlignClass,
      "attributors/class/background": BackgroundClass,
      "attributors/class/color": ColorClass,
      "attributors/class/direction": DirectionClass,
      "attributors/class/font": FontClass,
      "attributors/class/size": SizeClass,
      "attributors/style/align": AlignStyle,
      "attributors/style/background": BackgroundStyle,
      "attributors/style/color": ColorStyle,
      "attributors/style/direction": DirectionStyle,
      "attributors/style/font": FontStyle,
      "attributors/style/size": SizeStyle
    }, true);
    Quill.register({
      "formats/align": AlignClass,
      "formats/direction": DirectionClass,
      "formats/indent": IndentClass,
      "formats/background": BackgroundStyle,
      "formats/color": ColorStyle,
      "formats/font": FontClass,
      "formats/size": SizeClass,
      "formats/blockquote": Blockquote,
      "formats/code-block": CodeBlock,
      "formats/header": Header,
      "formats/list": ListItem,
      "formats/bold": Bold,
      "formats/code": Code,
      "formats/italic": Italic,
      "formats/link": Link,
      "formats/script": Script,
      "formats/strike": Strike,
      "formats/underline": Underline,
      "formats/formula": Formula,
      "formats/image": Image,
      "formats/video": Video,
      "modules/syntax": Syntax,
      "modules/table": Table,
      "modules/toolbar": Toolbar,
      "themes/bubble": BubbleTheme,
      "themes/snow": SnowTheme,
      "ui/icons": Icons,
      "ui/picker": Picker,
      "ui/icon-picker": IconPicker,
      "ui/color-picker": ColorPicker,
      "ui/tooltip": Tooltip
    }, true);
    class TextEditorPresenter {
      constructor(defaultText = "") {
        __publicField(this, "_editor");
        __publicField(this, "_defaultText");
        __publicField(this, "_editorElement");
        this._editor = null;
        this._defaultText = defaultText;
        this._editorElement = null;
      }
      get editor() {
        if (this._editor == null) {
          throw new Error("Editor isn't made yet.");
        }
        return this._editor;
      }
      initialize(element) {
        if (this._editor != null) {
          return;
        }
        element.setAttribute("spellcheck", "false");
        this._editorElement = element;
        this._editor = new Quill(element, {
          theme: "snow",
          modules: {
            toolbar: false,
            clipboard: {
              matchers: [],
              matchVisual: false
            }
          }
        });
        this.editor.setText(this._defaultText);
      }
      setText(text) {
        this.editor.setText(text);
      }
      getText() {
        return this.editor.getText();
      }
      syntaxHighlight(start, end, className) {
        this.editor.formatText(start, end - start, "syntax-highlight", className);
      }
      clearFormatting() {
        const length = this.editor.getLength();
        this.editor.formatText(0, length, "syntax-highlight", false);
      }
      disable() {
        this.editor.enable(false);
      }
      enable() {
        this.editor.enable(true);
      }
      dispose() {
        this._editorElement && (this._editorElement.innerHTML = "");
        this._editor = null;
      }
      onChange(callback) {
        this.editor.on("text-change", callback);
      }
      onSelectionChange(callback) {
        this.editor.on("selection-change", callback);
      }
    }
    class TestEditorPresenter {
      constructor() {
        __publicField(this, "_ast");
        __publicField(this, "_selectedPattern");
        __publicField(this, "_patterns");
        __publicField(this, "textEditor");
        this._ast = new Signal("");
        this._selectedPattern = new Signal(null);
        this._patterns = new Signal({});
        this.textEditor = new TextEditorPresenter();
      }
      get patternsBroadcast() {
        return this._patterns.broadcast;
      }
      get selectedPatternBroadcast() {
        return this._selectedPattern.broadcast;
      }
      get astBroadcast() {
        return this._ast.broadcast;
      }
      get selectedPattern() {
        const name2 = this.selectedPatternBroadcast.get();
        return this._patterns.get()[String(name2)] || null;
      }
      initialize() {
        this.textEditor.onChange((_d, _od, source) => {
          if (source === "user") {
            this._process();
          }
        });
      }
      _process() {
        const patterns = this._patterns.get();
        const testPatternName = this._selectedPattern.get();
        const pattern2 = patterns[String(testPatternName)];
        if (pattern2 != null) {
          const editorPattern = new Sequence("editor-pattern-wrapper", [
            new Optional("optional-space", new Regex("space", "\\s+")),
            pattern2,
            new Optional("optional-space", new Regex("space", "\\s+"))
          ]);
          this.textEditor.clearFormatting();
          const text = this.textEditor.getText();
          const startTime = performance.now();
          try {
            const { ast, cursor } = editorPattern.exec(text);
            const parseDuration = performance.now() - startTime;
            console.log("Test Parse Time: ", parseDuration);
            if (ast != null) {
              const rootAst = ast.children[0];
              this._ast.set(rootAst.toJson(2));
            } else {
              this._ast.set("");
              if (cursor.furthestError != null) {
                const { endIndex: startIndex } = cursor.furthestError;
                const endIndex = cursor.length;
                this.textEditor.syntaxHighlight(startIndex, endIndex, "syntax-error");
                console.log(startIndex);
              } else {
                this.textEditor.syntaxHighlight(0, cursor.length, "syntax-error");
              }
            }
          } catch (e) {
            console.log(e);
          }
        }
      }
      setPatterns(patterns) {
        this._patterns.set(patterns);
        this._process();
      }
      selectPattern(name2) {
        this._selectedPattern.set(name2);
        this._process();
      }
      dispose() {
      }
    }
    const Inline = Quill.import("blots/inline");
    class SyntaxHighlightBlot extends Inline {
      static create(value2) {
        let node = super.create();
        if (value2) {
          node.classList.add(value2);
        }
        return node;
      }
      static formats(node) {
        return node.className || null;
      }
      format(name2, value2) {
        if (name2 === this.statics.blotName && value2) {
          this.domNode.classList.add(value2);
        } else if (name2 === this.statics.blotName && !value2) {
          this.domNode.classList.remove("syntax-error");
          this.domNode.classList.remove("syntax-keyword");
          this.domNode.classList.remove("syntax-literal");
          this.domNode.classList.remove("syntax-comment");
          this.domNode.classList.remove("syntax-name");
          this.domNode.classList.remove("syntax-structure");
          this.domNode.classList.remove("syntax-regex");
          this.domNode.classList.remove("highlight-match");
          this.domNode.classList.remove("highlight-move");
          this.domNode.classList.remove("highlight-error");
        } else {
          super.format(name2, value2);
        }
      }
    }
    SyntaxHighlightBlot.blotName = "syntax-highlight";
    SyntaxHighlightBlot.tagName = "span";
    Quill.register(SyntaxHighlightBlot);
    const KEYWORD_CLASS = "syntax-keyword";
    const LITERAL_CLASS = "syntax-literal";
    const COMMENT_CLASS = "syntax-comment";
    const NAME_CLASS = "syntax-name";
    const STRUCTURE_CLASS = "syntax-structure";
    const REGEX_CLASS = "syntax-regex";
    const nodeColorMap = {
      // String Literals
      "literal": LITERAL_CLASS,
      "resource": LITERAL_CLASS,
      // Keywords
      "import": KEYWORD_CLASS,
      "use-params": KEYWORD_CLASS,
      "with-params": KEYWORD_CLASS,
      "from": KEYWORD_CLASS,
      "as": KEYWORD_CLASS,
      // Comments
      "comment": COMMENT_CLASS,
      // Names
      "name": NAME_CLASS,
      "alias-literal": NAME_CLASS,
      "pattern-name": NAME_CLASS,
      "import-name": NAME_CLASS,
      "import-name-alias": NAME_CLASS,
      "divider-pattern": NAME_CLASS,
      "param-name": NAME_CLASS,
      // Language Structure
      "open-bracket": STRUCTURE_CLASS,
      "close-bracket": STRUCTURE_CLASS,
      "open-paren": STRUCTURE_CLASS,
      "close-paren": STRUCTURE_CLASS,
      "quantifier-shorthand": STRUCTURE_CLASS,
      "is-optional": STRUCTURE_CLASS,
      // Regex
      "regex-literal": REGEX_CLASS
    };
    class GrammarEditorPresenter {
      constructor({ onGrammarProcess, onSave, fileSystem, onPattern }) {
        __publicField(this, "_fileSystem");
        __publicField(this, "_cursorPosition");
        __publicField(this, "_path");
        __publicField(this, "_onGrammarProcess");
        __publicField(this, "_onSave");
        __publicField(this, "_allPatterns");
        __publicField(this, "_onPattern");
        __publicField(this, "textEditor");
        this._fileSystem = fileSystem;
        this._cursorPosition = null;
        this._path = "";
        this._onGrammarProcess = onGrammarProcess;
        this._onSave = onSave;
        this._allPatterns = {};
        this.textEditor = new TextEditorPresenter();
        this._onPattern = onPattern;
      }
      initialize() {
        this.textEditor.onChange((_1, _2, source) => {
          if (source === "user") {
            this._processGrammar();
            this._highlight();
          }
        });
        this.textEditor.onSelectionChange((range) => {
          if (range != null) {
            this._cursorPosition = range.index;
          }
          this._processCursorToPattern();
        });
        this.textEditor.editor.keyboard.addBinding({
          key: "s",
          shortKey: true
        }, () => {
          this._onSave(this.textEditor.getText());
          return false;
        });
      }
      async _processGrammar() {
        const text = this.textEditor.getText();
        try {
          const allPatterns = await Grammar.parse(text, {
            originResource: this._path,
            resolveImport: async (resource2, originResource) => {
              const origin = originResource == null ? "/" : originResource;
              const url = new URL(resource2, window.location.origin + origin);
              const path = url.pathname;
              try {
                const expression = await this._fileSystem.readFile(path);
                return { expression, resource: path };
              } catch {
                throw new Error(`File not found: ${path}`);
              }
            }
          });
          this._allPatterns = allPatterns;
          this._processCursorToPattern();
          this._onGrammarProcess(allPatterns);
        } catch (e) {
          console.log(e);
        }
        if (text === "") {
          this._allPatterns = {};
          this._onGrammarProcess({});
        }
      }
      _processCursorToPattern() {
        if (this._cursorPosition == null) {
          this._onPattern(null);
          return;
        }
        try {
          const text = this.textEditor.getText();
          const { ast } = grammar.exec(text);
          const index = this._cursorPosition;
          if (ast != null) {
            const node = ast.find((n) => (n.name === "assign-statement" || n.name === "export-name") && index > n.startIndex && index < n.endIndex);
            if (node != null && node.name === "assign-statement") {
              const name2 = node.children[0].value;
              const pattern2 = this._allPatterns[name2];
              this._onPattern(pattern2);
            } else if (node != null && node.name === "export-name") {
              const name2 = node.value;
              const pattern2 = this._allPatterns[name2];
              this._onPattern(pattern2);
            }
          }
        } catch {
        }
      }
      _highlight() {
        const textEditor = this.textEditor;
        const text = textEditor.getText();
        const { ast, cursor } = grammar.exec(text);
        if (ast != null) {
          textEditor.clearFormatting();
          ast.walkDown((node) => {
            if (nodeColorMap[node.name] != null) {
              textEditor.syntaxHighlight(node.startIndex, node.endIndex, nodeColorMap[node.name]);
            }
          });
        } else {
          if (cursor.furthestError != null) {
            const { endIndex: startIndex } = cursor.furthestError;
            const endIndex = cursor.length;
            textEditor.syntaxHighlight(startIndex, endIndex, "syntax-error");
          } else {
            textEditor.syntaxHighlight(0, cursor.length, "syntax-error");
          }
        }
      }
      disable() {
        this.textEditor.editor.disable();
      }
      setText(text, path) {
        this.textEditor.editor.enable();
        this._path = path;
        this.textEditor.setText(text);
        this._processGrammar();
        this._highlight();
        this._clearEditorState();
      }
      _clearEditorState() {
        const history = this.textEditor.editor.getModule("history");
        if (history != null) {
          history.stack.undo = [];
          history.stack.redo = [];
        }
      }
    }
    class FileCreation {
      constructor(path, fileSystem, onComplete, onAbort) {
        __publicField(this, "_fileSystem");
        __publicField(this, "_name");
        __publicField(this, "_error");
        __publicField(this, "_path");
        __publicField(this, "_onComplete");
        __publicField(this, "_onAbort");
        this._fileSystem = fileSystem;
        this._path = path;
        this._name = new Signal("");
        this._error = new Signal(null);
        this._onComplete = onComplete;
        this._onAbort = onAbort;
      }
      get directory() {
        return this._path;
      }
      get nameBroadcast() {
        return this._name.broadcast;
      }
      get errorBroadcast() {
        return this._error.broadcast;
      }
      updateName(value2) {
        this._name.set(value2);
        if (value2.trim().length === 0) {
          this._error.set("File name cannot be empty.");
          return;
        }
        if (value2.includes(" ")) {
          this._error.set("Cannot have spaces in file name.");
          return;
        }
        if (value2.includes("/")) {
          this._error.set("Cannot have forward slashes in file name.");
          return;
        }
        this._error.set(null);
      }
      async commit() {
        if (this._error.get() == null) {
          const fileName = this._path + this._name.get();
          await this._fileSystem.writeFile(fileName, "");
          this._onComplete(fileName);
        }
      }
      async abort() {
        this._onAbort();
      }
    }
    class DirectoryCreation {
      constructor(path, fileSystem, onComplete) {
        __publicField(this, "_fileSystem");
        __publicField(this, "_name");
        __publicField(this, "_error");
        __publicField(this, "_path");
        __publicField(this, "_onComplete");
        this._fileSystem = fileSystem;
        this._path = path;
        this._name = new Signal("");
        this._error = new Signal(null);
        this._onComplete = onComplete;
      }
      get directory() {
        return this._path;
      }
      get nameBroadcast() {
        return this._name.broadcast;
      }
      get errorBroadcast() {
        return this._error.broadcast;
      }
      updateName(value2) {
        this._name.set(value2);
        if (value2.trim().length === 0) {
          this._error.set("Directory name cannot be empty.");
          return;
        }
        if (value2.includes(" ")) {
          this._error.set("Cannot have spaces in directory name.");
          return;
        }
        if (value2.includes("/")) {
          this._error.set("Cannot have forward slashes in directory name.");
          return;
        }
        if (value2.includes(".")) {
          this._error.set("Cannot have periods in there name.");
          return;
        }
        this._error.set(null);
      }
      async commit() {
        if (this._error.get() == null) {
          await this._fileSystem.createDirectory(this._path + this._name.get());
          this._onComplete();
        }
      }
      async abort() {
        this._onComplete();
      }
    }
    class FileRenaming {
      constructor(filePath, fileSystem, onComplete, onAbort) {
        __publicField(this, "_fileSystem");
        __publicField(this, "_name");
        __publicField(this, "_error");
        __publicField(this, "_directory");
        __publicField(this, "_originalFilePath");
        __publicField(this, "_onComplete");
        __publicField(this, "_onAbort");
        this._fileSystem = fileSystem;
        this._name = new Signal(this._getFileName(filePath));
        this._originalFilePath = filePath;
        this._directory = this._getDirectory(filePath);
        this._error = new Signal(null);
        this._onComplete = onComplete;
        this._onAbort = onAbort;
      }
      get directory() {
        return this._directory;
      }
      get nameBroadcast() {
        return this._name.broadcast;
      }
      get filePath() {
        return this._originalFilePath;
      }
      get errorBroadcast() {
        return this._error.broadcast;
      }
      _getDirectory(filePath) {
        return filePath.split("/").slice(0, -1).join("/") + "/";
      }
      _getFileName(filePath) {
        return filePath.split("/").slice(-1)[0];
      }
      updateName(value2) {
        this._name.set(value2);
        if (value2.trim().length === 0) {
          this._error.set("File name cannot be empty.");
          return;
        }
        if (value2.includes(" ")) {
          this._error.set("Cannot have spaces in file name.");
          return;
        }
        if (value2.includes("/")) {
          this._error.set("Cannot have forward slashes in file name.");
          return;
        }
        this._error.set(null);
      }
      async commit() {
        if (this._error.get() == null) {
          const newFilePath = this._directory + this._name.get();
          await this._fileSystem.renameFile(this._originalFilePath, this._name.get());
          this._onComplete(newFilePath);
        }
      }
      async abort() {
        this._onAbort();
      }
    }
    class DirectoryRenaming {
      constructor(directoryPath, fileSystem, onComplete, onAbort) {
        __publicField(this, "_fileSystem");
        __publicField(this, "_name");
        __publicField(this, "_error");
        __publicField(this, "_directory");
        __publicField(this, "_originalFilePath");
        __publicField(this, "_onComplete");
        __publicField(this, "_onAbort");
        this._fileSystem = fileSystem;
        this._name = new Signal(this._getDirectoryName(directoryPath));
        this._originalFilePath = directoryPath;
        this._directory = this._getParentDirectory(directoryPath);
        this._error = new Signal(null);
        this._onComplete = onComplete;
        this._onAbort = onAbort;
      }
      get directory() {
        return this._directory;
      }
      get nameBroadcast() {
        return this._name.broadcast;
      }
      get directoryPath() {
        return this._originalFilePath;
      }
      get errorBroadcast() {
        return this._error.broadcast;
      }
      _getParentDirectory(directoryPath) {
        return directoryPath.split("/").slice(0, -1).join("/") + "/";
      }
      _getDirectoryName(directoryPath) {
        return directoryPath.split("/").slice(-1)[0];
      }
      updateName(value2) {
        this._name.set(value2);
        if (value2.trim().length === 0) {
          this._error.set("Directory name cannot be empty.");
          return;
        }
        if (value2.includes(" ")) {
          this._error.set("Cannot have spaces in directory name.");
          return;
        }
        if (value2.includes("/")) {
          this._error.set("Cannot have forward slashes in directory name.");
          return;
        }
        if (value2.includes(".")) {
          this._error.set("Cannot have periods in there name.");
          return;
        }
        this._error.set(null);
      }
      async commit() {
        if (this._error.get() == null) {
          const newFilePath = this._directory + this._name.get();
          await this._fileSystem.renameDirectory(this._originalFilePath, this._name.get());
          this._onComplete(newFilePath);
        }
      }
      async abort() {
        this._onAbort();
      }
    }
    class FileExplorerPresenter {
      constructor(options) {
        __publicField(this, "_fileSystem");
        __publicField(this, "_directory");
        __publicField(this, "_directories");
        __publicField(this, "_files");
        __publicField(this, "_openDirectories");
        __publicField(this, "_focusedItem");
        __publicField(this, "_onPathFocus");
        __publicField(this, "_pendingFileCreation");
        __publicField(this, "_pendingDirectoryCreation");
        __publicField(this, "_pendingFileRenaming");
        __publicField(this, "_pendingDirectoryRenaming");
        this._fileSystem = options.fileSystem;
        this._onPathFocus = options.onPathFocus;
        this._directory = new Signal({
          type: "directory",
          name: "",
          items: [],
          path: "",
          directory: ""
        });
        this._directories = /* @__PURE__ */ new Map();
        this._files = /* @__PURE__ */ new Map();
        this._openDirectories = new Signal(/* @__PURE__ */ new Map());
        this._directories.set(this._directory.get().path, this._directory.get());
        this._focusedItem = new Signal(null);
        this._pendingFileCreation = new Signal(null);
        this._pendingDirectoryCreation = new Signal(null);
        this._pendingFileRenaming = new Signal(null);
        this._pendingDirectoryRenaming = new Signal(null);
      }
      get directoryBroadcast() {
        return this._directory.broadcast;
      }
      get openDirectoriesBroadcast() {
        return this._openDirectories.broadcast;
      }
      get focusedItemBroadcast() {
        return this._focusedItem.broadcast;
      }
      get pendingFileCreationBroadcast() {
        return this._pendingFileCreation.broadcast;
      }
      get pendingDirectoryCreationBroadcast() {
        return this._pendingDirectoryCreation.broadcast;
      }
      get pendingFileRenamingBroadcast() {
        return this._pendingFileRenaming.broadcast;
      }
      get pendingDirectoryRenamingBroadcast() {
        return this._pendingDirectoryRenaming.broadcast;
      }
      async initialize() {
        await this._updateDirectories();
      }
      async refresh() {
        return this._updateDirectories();
      }
      async _updateDirectories() {
        const directories = /* @__PURE__ */ new Map();
        const files = /* @__PURE__ */ new Map();
        directories.set("/", {
          type: "directory",
          directory: "",
          name: "",
          path: "/",
          items: []
        });
        await this._fileSystem.walk((itemMeta) => {
          const path = this._makePathFromMetaData(itemMeta);
          const name2 = this._fileSystem.getName(path);
          const directoryPath = this._fileSystem.getDirectoryPath(path);
          const isFile = itemMeta.type === "file";
          if (path === "/") {
            return;
          }
          let directory = directories.get(directoryPath);
          if (directory == null) {
            directory = this._makeDirectoryFromPath(directoryPath);
            directories.set(directoryPath, directory);
          }
          if (isFile) {
            const file = {
              type: "file",
              directory: directoryPath,
              name: name2,
              path
            };
            directory.items.push(file);
            files.set(path, file);
          } else {
            let childDirectory = directories.get(path);
            if (childDirectory == null) {
              childDirectory = this._makeDirectoryFromPath(path);
              directories.set(path, childDirectory);
            }
            directory.items.push(childDirectory);
          }
        });
        const rootDirectory = directories.get("/");
        Array.from(directories.values()).forEach((d) => {
          d.items.sort((a, b) => {
            if (a.type === "directory" && b.type === "directory") {
              return a.name.localeCompare(b.name, void 0, { sensitivity: "base" });
            } else if (a.type === "directory" && b.type === "file") {
              return -1;
            } else if (a.type === "file" && b.type === "file") {
              return 1;
            } else {
              return a.name.localeCompare(b.name, void 0, { sensitivity: "base" });
            }
          });
        });
        if (rootDirectory != null) {
          this._directory.set(rootDirectory);
        }
        this._directories = directories;
        this._files = files;
      }
      _makePathFromMetaData(metaData) {
        if (metaData.parent == null) {
          return "/";
        }
        const parts = [];
        let item = metaData;
        parts.unshift(metaData.name);
        item = metaData.parent;
        while ((item == null ? void 0 : item.parent) != null) {
          parts.unshift(item.name);
          item = item.parent;
        }
        const path = "/" + parts.join("/");
        if (metaData.type === "directory") {
          return path + "/";
        }
        return path;
      }
      _makeDirectoryFromPath(path) {
        return {
          type: "directory",
          directory: this._fileSystem.getDirectoryPath(path),
          name: this._fileSystem.getName(path),
          path,
          items: []
        };
      }
      focus(path) {
        const file = this._files.get(path);
        const focusedItem = this._focusedItem.get();
        const oldPath = focusedItem == null ? null : focusedItem.path;
        if (oldPath === path) {
          return;
        }
        if (file != null) {
          this._focusedItem.set(file);
          this._onPathFocus(path, oldPath);
          return;
        }
        const directory = this._directories.get(path);
        if (directory != null) {
          this._focusedItem.set(directory);
          this._onPathFocus(path, oldPath);
          return;
        }
      }
      startRenamingFile(filePath) {
        this._pendingFileRenaming.set(new FileRenaming(filePath, this._fileSystem, async (filePath2) => {
          this._pendingFileRenaming.set(null);
          await this.refresh();
          this.focus(filePath2);
        }, async () => {
          this._pendingFileRenaming.set(null);
          await this.refresh();
        }));
      }
      startFileCreation() {
        const currentDirectory = this._focusedItem.get();
        let path = "/";
        if (currentDirectory && currentDirectory.type === "file") {
          path = currentDirectory.directory;
        } else if (currentDirectory && currentDirectory.type === "directory") {
          path = currentDirectory.path;
        }
        this._pendingFileCreation.set(new FileCreation(path, this._fileSystem, async (filePath) => {
          this._pendingFileCreation.set(null);
          await this.refresh();
          this.focus(filePath);
        }, async () => {
          this._pendingFileCreation.set(null);
          await this.refresh();
        }));
      }
      startDirectoryCreation() {
        const currentDirectory = this._focusedItem.get();
        let path = "/";
        if (currentDirectory && currentDirectory.type === "file") {
          path = currentDirectory.directory;
        } else if (currentDirectory && currentDirectory.type === "directory") {
          path = currentDirectory.path;
        }
        this._pendingDirectoryCreation.set(new DirectoryCreation(path, this._fileSystem, async () => {
          this._pendingDirectoryCreation.set(null);
          await this.refresh();
          this.focus(path);
        }));
      }
      startRenamingDirectory(filePath) {
        this._pendingDirectoryRenaming.set(new DirectoryRenaming(filePath, this._fileSystem, async (filePath2) => {
          this._pendingDirectoryRenaming.set(null);
          await this.refresh();
          this.focus(filePath2);
        }, async () => {
          this._pendingDirectoryRenaming.set(null);
          await this.refresh();
        }));
      }
      async createFile(name2, content = "") {
        name2 = name2.endsWith("cpat") ? name2 : `${name2}.cpat`;
        const currentDirectory = this._focusedItem.get();
        if (currentDirectory == null) {
          await this._fileSystem.writeFile(`/${name2}`, content);
        } else if (currentDirectory.type === "directory") {
          await this._fileSystem.writeFile(currentDirectory.path + name2, "");
        } else {
          await this._fileSystem.writeFile(`${currentDirectory.directory}/${name2}`, "");
        }
        await this._updateDirectories();
      }
      async deleteFile(path) {
        try {
          await this._fileSystem.deleteFile(path);
        } catch (_) {
        }
        await this._updateDirectories();
      }
      async updateFile(path, content) {
        await this._fileSystem.writeFile(path, content);
        await this._updateDirectories();
      }
      async createDirectory(name2) {
        name2 = name2.endsWith("/") ? name2 : `${name2}/`;
        const currentDirectory = this._focusedItem.get();
        if (currentDirectory == null) {
          await this._fileSystem.createDirectory(`/${name2}`);
        } else if (currentDirectory.type === "directory") {
          await this._fileSystem.createDirectory(currentDirectory.path + name2);
        } else {
          await this._fileSystem.createDirectory(`${currentDirectory.directory}/${name2}`);
        }
        await this._updateDirectories();
      }
      async deleteDirectory(path) {
        await this._fileSystem.deleteDirectory(path);
        await this._updateDirectories();
      }
      openDirectory(path) {
        this._openDirectories.transform((m) => {
          m.set(path, true);
          return m;
        });
      }
      closeDirectory(path) {
        this._openDirectories.transform((m) => {
          m.set(path, false);
          return m;
        });
      }
      toggleDirectory(path) {
        this._openDirectories.transform((m) => {
          m.set(path, !m.get(path));
          return m;
        });
      }
    }
    function generateGUID() {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (char) => {
        const random = Math.random() * 16 | 0;
        const value2 = char === "x" ? random : random & 3 | 8;
        return value2.toString(16);
      });
    }
    const META_KEY = "$__File_System__META$";
    function replacer(key, value2) {
      if (key === "parent") {
        return null;
      }
      return value2;
    }
    class FileSystem {
      constructor(storage = window.localStorage) {
        __publicField(this, "_storage");
        __publicField(this, "_meta");
        this._storage = storage;
        this._meta = this._getRoot();
      }
      _getRoot() {
        let metaString = this._storage.getItem(META_KEY);
        let meta = null;
        try {
          if (metaString != null) {
            meta = JSON.parse(metaString);
          }
        } catch {
        }
        if (meta == null) {
          meta = {
            type: "directory",
            name: "",
            parent: null,
            items: []
          };
          this._storage.setItem(META_KEY, JSON.stringify(meta, replacer));
        }
        return this._normalizeMetaData(meta);
      }
      _normalizeMetaData(metaData) {
        this._walkDown(metaData, (item, parent) => {
          item.parent = parent;
        }, this._meta);
        return metaData;
      }
      _walkDown(item, callback, fromDirectory) {
        callback(item, fromDirectory);
        if (item.type === "directory") {
          const directories = [];
          item.items.forEach((i) => {
            if (i.type === "file") {
              this._walkDown(i, callback, item);
            } else {
              directories.push(i);
            }
          });
          directories.forEach((d) => this._walkDown(d, callback, item));
        }
      }
      _getMetaDataForPath(path) {
        if (path.startsWith("/")) {
          path = path.slice(1);
        }
        if (path.endsWith("/")) {
          path = path.slice(0, -1);
        }
        const parts = path.split("/");
        let directory = this._meta;
        parts.slice(0, -1).forEach((part) => {
          const match2 = directory.items.find((i) => i.name === part);
          if (match2 == null || match2.type === "file") {
            throw new Error("Not Found");
          }
          directory = match2;
        });
        const result = directory.items.find((i) => i.name === parts[parts.length - 1]);
        if (result == null) {
          throw new Error("Not Found");
        }
        return result;
      }
      async isFile(path) {
        return this._getMetaDataForPath(path).type === "file";
      }
      async hasFile(path) {
        try {
          return await this.isFile(path);
        } catch {
          return false;
        }
      }
      async readFile(path) {
        const metaData = this._getMetaDataForPath(path);
        if (metaData.type === "directory") {
          throw new Error("File Not Found");
        }
        return this._storage.getItem(metaData.guid) || "";
      }
      async writeFile(path, content) {
        path = this._normalizeFile(path);
        const name2 = this.getName(path);
        const directoryPath = this.getDirectoryPath(path);
        try {
          const metaItem = this._getMetaDataForPath(path);
          if (metaItem.type === "directory") {
            throw new Error("Cannot Write File");
          }
          this._storage.setItem(metaItem.guid, content);
        } catch {
          this._actIfPathIsEmpty(path, () => {
            const directory = this._createDirectoriesForPath(directoryPath);
            const guid = generateGUID();
            directory.items.push({
              type: "file",
              guid,
              name: name2,
              parent: directory
            });
            this._persist();
            this._storage.setItem(guid, content);
          });
        }
      }
      async renameFile(path, newName) {
        const metaData = this._getMetaDataForPath(path);
        if (metaData.type === "directory") {
          throw new Error("File Not Found");
        }
        if (newName.includes("/")) {
          throw new Error("Invalid File Name");
        }
        metaData.name = newName;
        this._persist();
      }
      async deleteFile(path) {
        const metaData = this._getMetaDataForPath(path);
        if (metaData.type === "directory") {
          throw new Error("File Not Found");
        }
        if (metaData.parent != null) {
          const index = metaData.parent.items.indexOf(metaData);
          if (index > -1) {
            metaData.parent.items.splice(index, 1);
          }
          this._storage.removeItem(metaData.guid);
          this._persist();
        }
      }
      async move(path, newPath) {
        const metaData = this._getMetaDataForPath(path);
        this._actIfPathIsEmpty(newPath, () => {
          if (metaData.parent != null) {
            const index = metaData.parent.items.indexOf(metaData);
            if (index > -1) {
              metaData.parent.items.splice(index, 1);
            }
            const directoryPath = this.getDirectoryPath(newPath);
            const directory = this._createDirectoriesForPath(directoryPath);
            directory.items.push(metaData);
            this._persist();
          }
        });
      }
      async isDirectory(path) {
        return this._getMetaDataForPath(path).type === "directory";
      }
      async hasDirectory(path) {
        try {
          return await this.isDirectory(path);
        } catch {
          return false;
        }
      }
      async createDirectory(path) {
        path = this._normalizeDirectory(path);
        const name2 = this.getName(path);
        const directoryPath = this.getDirectoryPath(path);
        this._actIfPathIsEmpty(path, () => {
          const directory = this._createDirectoriesForPath(directoryPath);
          const meta = {
            type: "directory",
            name: name2,
            parent: directory,
            items: []
          };
          directory.items.push(meta);
          this._persist();
        });
      }
      _createDirectoriesForPath(path) {
        const parts = this._normalizeDirectory(path).split("/").slice(1, -1);
        let directory = this._meta;
        if (path === "/") {
          return this._meta;
        }
        parts.forEach((part) => {
          let match2 = directory.items.find((i) => i.name === part);
          if (match2 == null) {
            match2 = {
              type: "directory",
              name: part,
              parent: directory,
              items: []
            };
            directory.items.push(match2);
          } else if (match2.type === "file") {
            throw new Error("Cannot Create Directory");
          }
          directory = match2;
        });
        this._persist();
        return directory;
      }
      _normalizeDirectory(path) {
        path = path.trim();
        if (!path.endsWith("/")) {
          path = path + "/";
        }
        if (!path.startsWith("/")) {
          return "/" + path;
        }
        return path;
      }
      _normalizeFile(path) {
        path = path.trim();
        if (path.endsWith("/")) {
          path = path.slice(0, -1);
        }
        if (!path.startsWith("/")) {
          return "/" + path;
        }
        return path;
      }
      getName(path) {
        if (path.endsWith("/")) {
          path = this._normalizeDirectory(path);
          path = path.slice(0, -1);
        } else {
          path = this._normalizeFile(path);
        }
        return path.split("/").slice(-1)[0];
      }
      getDirectoryPath(path) {
        if (path.endsWith("/")) {
          path = path.slice(0, -1);
        }
        return path.split("/").slice(0, -1).join("/") + "/";
      }
      _actIfPathIsEmpty(path, action) {
        let metaData = null;
        try {
          metaData = this._getMetaDataForPath(path);
        } catch {
          action();
          return;
        }
        if (metaData.type === "file") {
          throw new Error("File Already Exists");
        } else {
          throw new Error("Directory Already Exists");
        }
      }
      async renameDirectory(path, newName) {
        const metaData = this._getMetaDataForPath(path);
        if (metaData.type === "file") {
          throw new Error("Directory Not Found");
        }
        metaData.name = newName;
        this._persist();
      }
      async deleteDirectory(path) {
        const metaData = this._getMetaDataForPath(path);
        if (metaData.type === "file") {
          throw new Error("Directory Not Found");
        }
        if (metaData.parent != null) {
          const index = metaData.parent.items.indexOf(metaData);
          if (index > -1) {
            metaData.parent.items.splice(index, 1);
            this._recursiveFileDelete(metaData);
            this._persist();
          }
        }
      }
      _recursiveFileDelete(meta) {
        meta.items.forEach((i) => {
          if (i.type === "file") {
            this._storage.removeItem(i.guid);
          } else {
            this._recursiveFileDelete(i);
          }
        });
      }
      async readDirectory(path) {
        const directory = this._getMetaDataForPath(path);
        if (directory.type === "file") {
          throw new Error("Directory Not Found");
        }
        return JSON.parse(JSON.stringify(directory, replacer));
      }
      async walk(callback) {
        this._walkDown(this._meta, callback, this._meta);
      }
      async getMetaData() {
        return this._normalizeMetaData(JSON.parse(JSON.stringify(this._meta, replacer)));
      }
      _persist() {
        this._storage.setItem(META_KEY, JSON.stringify(this._meta, replacer));
      }
      async refresh() {
        this._meta = this._getRoot();
      }
    }
    class DebuggerPresenter {
      constructor(text, pattern2) {
        __publicField(this, "_text");
        __publicField(this, "_pattern");
        __publicField(this, "_steps");
        __publicField(this, "_onStep");
        __publicField(this, "_tickId");
        __publicField(this, "_isPlaying");
        __publicField(this, "_playbackSpeed");
        __publicField(this, "diagramPresenter");
        __publicField(this, "textEditorPresenter");
        this._text = text;
        this._onStep = new Signal(0);
        this._steps = [];
        this._tickId = 0;
        this._isPlaying = new Signal(false);
        this._playbackSpeed = new Signal(500);
        this.diagramPresenter = new DiagramPresenter();
        this.textEditorPresenter = new TextEditorPresenter();
        this._pattern = new Sequence("editor-pattern-wrapper", [
          new Optional("optional-space", new Regex("space", "\\s+")),
          pattern2,
          new Optional("optional-space", new Regex("space", "\\s+"))
        ]);
      }
      get isPlayingBroadcast() {
        return this._isPlaying.broadcast;
      }
      get playbackSpeedBroadcast() {
        return this._playbackSpeed.broadcast;
      }
      initialize() {
        this.textEditorPresenter.setText(this._text);
        this.textEditorPresenter.disable();
        this._onStep.set(0);
        this.diagramPresenter.selectPattern([this._pattern]);
        try {
          const { ast, cursor } = this._pattern.exec(this._text, true);
          this._steps = generateSteps(this._pattern, cursor.records);
          if (ast == null) {
            const furthestError = cursor.furthestError;
            this._steps.push({
              type: "error",
              path: "_",
              pattern: this._pattern,
              record: {
                ast: null,
                error: new ParseError((furthestError == null ? void 0 : furthestError.startIndex) || 0, this._text.length, this._pattern),
                pattern: this._pattern
              }
            });
          }
          this._update();
        } catch {
        }
      }
      play() {
        if (this._onStep.get() === this._steps.length - 1) {
          this._onStep.set(0);
        }
        this.stop();
        this._isPlaying.set(true);
        this._tickId = window.setInterval(() => {
          if (this.hasNext()) {
            this.next();
          } else {
            this.stop();
          }
        }, this._playbackSpeed.get());
      }
      stop() {
        window.clearInterval(this._tickId);
        this._isPlaying.set(false);
      }
      hasNext() {
        const onStep = this._onStep.get() + 1;
        return onStep < this._steps.length;
      }
      next() {
        const onStep = this._onStep.get() + 1;
        if (onStep < this._steps.length) {
          this._onStep.set(onStep);
          this._update();
        }
      }
      previous() {
        const onStep = this._onStep.get() - 1;
        if (onStep > -1) {
          this._onStep.set(onStep);
          this._update();
        }
      }
      start() {
        this._onStep.set(0);
        this._update();
      }
      end() {
        this._onStep.set(this._steps.length - 1);
        this._update();
      }
      _update() {
        this._updateDiagramStyles();
        this._updateTextStyles();
      }
      _updateDiagramStyles() {
        const step = this._steps[this._onStep.get()];
        this.diagramPresenter.expandPatternPath(step.path);
        this.diagramPresenter.clearClasses();
        this.diagramPresenter.setClasses([{
          patternPath: step.path,
          className: step.type
        }]);
        this.diagramPresenter.focusPath(step.path);
      }
      _updateTextStyles() {
        const step = this._steps[this._onStep.get()];
        this.textEditorPresenter.clearFormatting();
        if (step.type === "move") {
          if (step.record.ast != null) {
            const startIndex = step.record.ast.firstIndex;
            this.textEditorPresenter.syntaxHighlight(
              startIndex,
              startIndex + 1,
              "highlight-move"
            );
          } else if (step.record.error != null) {
            const startIndex = step.record.error.startIndex;
            this.textEditorPresenter.syntaxHighlight(
              startIndex,
              startIndex + 1,
              "highlight-move"
            );
          }
        } else if (step.type === "match") {
          if (step.record.ast != null) {
            const startIndex = step.record.ast.firstIndex;
            const endIndex = step.record.ast.endIndex;
            this.textEditorPresenter.syntaxHighlight(
              startIndex,
              endIndex,
              "highlight-match"
            );
          }
        } else if (step.type === "error") {
          if (step.record.error != null) {
            const startIndex = step.record.error.startIndex;
            const endIndex = step.record.error.endIndex;
            this.textEditorPresenter.syntaxHighlight(
              startIndex,
              endIndex + 1,
              "highlight-error"
            );
          }
        }
      }
      setPlaybackSpeed(value2) {
        if (this._isPlaying.get()) {
          this.stop();
          this._playbackSpeed.set(value2);
          this.play();
          return;
        }
        this._playbackSpeed.set(value2);
      }
    }
    class AppPresenter {
      constructor() {
        __publicField(this, "_isDocumentationOpen");
        __publicField(this, "_fileSystem");
        __publicField(this, "_currentPath");
        __publicField(this, "grammarEditor");
        __publicField(this, "testEditor");
        __publicField(this, "diagramPresenter");
        __publicField(this, "fileExplorer");
        __publicField(this, "debuggerPresenter");
        this._fileSystem = new FileSystem();
        this._currentPath = null;
        this._isDocumentationOpen = new Signal(false);
        this.grammarEditor = new GrammarEditorPresenter({
          onGrammarProcess: (patterns) => {
            this.testEditor.setPatterns(patterns);
          },
          onSave: (content) => {
            if (this._currentPath != null) {
              this._fileSystem.writeFile(this._currentPath, content);
            }
          },
          fileSystem: this._fileSystem,
          onPattern: (pattern2) => {
            if (pattern2 != null) {
              this.diagramPresenter.selectPattern([pattern2]);
            } else {
              this.diagramPresenter.selectPattern([]);
            }
          }
        });
        this.testEditor = new TestEditorPresenter();
        this.diagramPresenter = new DiagramPresenter();
        this.fileExplorer = new FileExplorerPresenter({
          fileSystem: this._fileSystem,
          onPathFocus: async (path, oldPath) => {
            this.testEditor.selectPattern(null);
            this._currentPath = path;
            if (oldPath != null) {
              try {
                const hasFile = await this._fileSystem.hasFile(oldPath);
                if (!hasFile) {
                  throw new Error("File Not Found.");
                }
                const content = this.grammarEditor.textEditor.getText();
                await this._fileSystem.writeFile(oldPath, content);
              } catch {
              }
            }
            try {
              const content = await this._fileSystem.readFile(path);
              this.grammarEditor.setText(content, path);
            } catch {
              this.grammarEditor.setText("", path);
              this.grammarEditor.disable();
            }
          }
        });
        this.debuggerPresenter = new Signal(null);
      }
      get isDocumentationOpenBroadcast() {
        return this._isDocumentationOpen.broadcast;
      }
      async initialize() {
        var _a2;
        await this.fileExplorer.initialize();
        const directory = this.fileExplorer.directoryBroadcast.get();
        if (directory.items.length === 0) {
          await this.fileExplorer.createFile("examples.cpat");
          this.fileExplorer.focus("/examples.cpat");
        } else {
          this.fileExplorer.focus((_a2 = directory.items[0]) == null ? void 0 : _a2.path);
        }
      }
      toggleDocumentation() {
        this._isDocumentationOpen.transform((v) => !v);
      }
      showDebugger() {
        const pattern2 = this.testEditor.selectedPattern;
        if (pattern2 != null) {
          const presenter2 = new DebuggerPresenter(this.testEditor.textEditor.getText(), pattern2);
          this.debuggerPresenter.set(presenter2);
        }
      }
      closeDebugger() {
        this.debuggerPresenter.set(null);
      }
      dispose() {
      }
    }
    const presenter = new AppPresenter();
    clientExports.createRoot(document.getElementById("root")).render(
      /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, { presenter }) })
    );
  }
});
export default require_index_001();
//# sourceMappingURL=index-BIt8DA9z.js.map
